var documenterSearchIndex = {"docs":
[{"location":"tutorials/1_loading/#Loading-and-converting-model-data","page":"Loading and converting model data","title":"Loading and converting model data","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"COBREXA.jl supports several constraint-based model formats that can be loaded with built-in functions. You can load SBML models that are compatible with libsbml, JSON models (such as the ones from CobraPy), and MATLAB-style models (such as those from COBRA Toolbox).","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"These formats are commonly available from many model repositories, such as from BIGG, as seen e.g. on the BIGG entry for the core E. Coli entry. Here, we show how to load the basic formats and work with such models.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"tip: Notebook available!\nExample code for this tutorial is available here.","category":"page"},{"location":"tutorials/1_loading/#Loading-models-from-files","page":"Loading and converting model data","title":"Loading models from files","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"For most purposes, you should be able to open and load any model with load_model, which detects the file type from the extension (.xml, .json and .mat), and calls the appropriate loading function. After loading the COBREXA.jl library with using COBREXA and you may load the downloaded model data into Julia as follows:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"my_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"You should see some information about the loaded model, possibly looking like this:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Metabolic model of type JSONModel\n\n  [9 ,  1]  =  1.0\n  [51,  1]  =  1.0\n  ⋮\n  [57, 95]  =  1.0\n  [59, 95]  =  -1.0\nNumber of reactions: 95\nNumber of metabolites: 72","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"If the file type can not be guessed from the file extension, use any of the specific loader functions:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"load_sbml_model for SBML\nload_json_model for JSON\nload_mat_model for MATLAB models","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"All formats may store slightly different information. By default, COBREXA attempts not to discard any information unless a conversion to a more strict format is required. For example, the JSONModel (which is returned by load_json_model) still holds the original JSON structure that you can freely access for any specific purposes:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"jm = load_json_model(\"e_coli_core.json\")\njm.json[\"reactions\"][1]","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"That should print out the first reaction in the model in a JSON-style scheme, in our case the process catalyzed by phosphofructokinase:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Dict{String,Any} with 9 entries:\n  \"name\"               => \"Phosphofructokinase\"\n  \"metabolites\"        => Dict{String,Any}(\"adp_c\"=>1.0,\"atp_c\"=>-1.0,\"f6p_c\"=>…\n  \"lower_bound\"        => 0.0\n  \"id\"                 => \"PFK\"\n  \"notes\"              => Dict{String,Any}(\"original_bigg_ids\"=>Any[\"PFK\"])\n  \"gene_reaction_rule\" => \"b3916 or b1723\"\n  \"upper_bound\"        => 1000.0\n  \"subsystem\"          => \"Glycolysis/Gluconeogenesis\"\n  \"annotation\"         => Dict{String,Any}(\"ec-code\"=>Any[\"2.7.1.11\"],\"metanetx…","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"MATModel and SBMLModel (returned by the respective loading functions) contain similar \"full\" model information – you can access the whole MATLAB and SBML data and build on them without any restrictions.","category":"page"},{"location":"tutorials/1_loading/#Converting-to-other-model-types","page":"Loading and converting model data","title":"Converting to other model types","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Despite JSON and SBML are great for storing and exchanging the models, the data representation is not very suitable for analyzing the model and processing it mathematically.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"COBREXA.jl contains several model types that are much better suited  for supporting the analysis tasks. You can use the following:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"CoreModel, which represents the \"core\" of the optimization problem and the corresponding linear programming problem – a sparse representation of the stoichiometric matrix, flux bounds vectors, objective vector, etc.\nStandardModel (a \"standard\" for COBREXA.jl), which represents a highly flexible, object-like, dictionary-based representation of a model that contains individual Reactions, Metabolites, Genes, and other things.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"note: Conversion limitations and possible data loss\nBecause of the specifics of the format of each model structure, the conversion is not always able to preserve all information from the source data. You may need to check if any complicated and less-standard annotations are still present. If you require them, and either use a more complicated model, or collect them manually.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"A loaded model can be converted to any other model type using the standard Julia conversion:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"cm = convert(CoreModel, jm)","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"You can also use a shortcut in load_model to convert the model to the desired format in one command:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"cm = load_model(CoreModel, \"e_coli_core.xml\")","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"With CoreModel, the information is easily accessible in matrix form. For example, cm.S now contains the sparse stoichiometric matrix, which you can convert to a dense matrix and manipulate it in Julia as any other matrix:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Matrix(cm.S)","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"...should show you the (relatively empty) stoichiometry of the model.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"StandardModel is more suitable for fine-grained access to individual items of the model, perhaps closer to the SBML-style models. For example, you can view and set reaction bounds as follows:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"sm = load_model(StandardModel, \"e_coli_core.json\")\nsm.reactions[\"PGI\"].ub","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"...this prints the upper bound of the reaction (in this case, 1000.0); you can change it the usual way:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"sm.reactions[\"PGI\"].ub = 500","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"This change will naturally project to future analysis results.","category":"page"},{"location":"tutorials/#COBREXA-Tutorials","page":"Quickstart tutorials","title":"COBREXA Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Quickstart tutorials","title":"Quickstart tutorials","text":"Pages = joinpath.(\"tutorials\", filter(x -> endswith(x, \".md\"), readdir(\"tutorials\")))\nDepth = 2","category":"page"},{"location":"advanced/2_custom_model/#Working-with-custom-models","page":"Working with custom models","title":"Working with custom models","text":"","category":"section"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"It may happen that the intuitive representation of your data does not really match what is supported by a given COBRA package. COBREXA.jl attempts to avoid this problem by providing a flexible framework for containing any data structure that can, somehow, represent the constraint-based model.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The task of having such a polymorphic model definition can be split into 2 separate concerns:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"How to allow the analysis functions to gather the required information from any user-specified model data structure?\nHow to make the reconstruction functions (i.e., reaction or gene deletions) work properly on any data structure?","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"To solve the first concern, COBREXA.jl specifies a set of generic accessors that work over the abstract type MetabolicModel. To use your data structure in a model, you just make it a subtype of MetabolicModel and overload the required accessors. The accessors are functions that extract some relevant information, such as stoichiometry and bounds, returning a fixed simple data type that can be further used by COBREXA.  You may see a complete list of accessors here.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"A good solution to the second concern is a slightly more involved, as writing generic data modifiers is notoriously hard. Still, there is support for easily making small changes to the model using the modifications system, with functions such as with_added_reactions and with_changed_bound.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"tip: Notebook available\nA better example of using a custom model structure is available in a separate notebook.","category":"page"},{"location":"advanced/2_custom_model/#Writing-the-generic-accessors","page":"Working with custom models","title":"Writing the generic accessors","text":"","category":"section"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"Let's write a data structure that represents a very small model that contains N metabolites that are converted in a circle through N linear, coupled reactions. (E.g., for N=3, we would have a conversion of metabolites A, B and C ordered as A → B → C → A.) This may be useful for testing purposes; we will use it for a simple demonstration.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The whole model can thus be specified with a single integer N that represents the length of the reaction cycle:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"struct CircularModel <: MetabolicModel\n    size::Int\nend","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"First, define the reactions and metabolites:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"COBREXA.n_reactions(m::CircularModel) = m.size\nCOBREXA.n_metabolites(m::CircularModel) = m.size\n\nCOBREXA.reactions(m::CircularModel) = [\"rxn$i\" for i in 1:n_reactions(m)]\nCOBREXA.metabolites(m::CircularModel) = [\"met$i\" for i in 1:n_metabolites(m)]","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"It is useful to re-use the already defined functions, as that improves the code maintainability.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"We can continue with the actual linear model properties:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"function COBREXA.objective(m::CircularModel)\n    c = spzeros(n_reactions(m))\n    c[1] = 1 #optimize the first reaction\n    return c\nend\n\nCOBREXA.bounds(m::CircularModel) = (\n    spzeros(n_reactions(m)), # lower bounds\n    sparse(ones(n_reactions(m))), # upper bounds\n)\n\nfunction COBREXA.stoichiometry(m::CircularModel)\n    nr = n_reactions(m)\n    stoi(i,j) =\n        i == j ? 1.0 :\n        (i % nr + 1) == j  ? -1.0 :\n        0.0\n\n    sparse([stoi(i,j) for i in 1:nr, j in 1:nr])\nend","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"You may check that the result now works just as with CoreModel and StandardModel:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"julia> m = CircularModel(5)\nMetabolic model of type CircularModel\n\n  1.0  -1.0    ⋅     ⋅     ⋅\n   ⋅    1.0  -1.0    ⋅     ⋅\n   ⋅     ⋅    1.0  -1.0    ⋅\n   ⋅     ⋅     ⋅    1.0  -1.0\n -1.0    ⋅     ⋅     ⋅    1.0\nNumber of reactions: 5\nNumber of metabolites: 5\n","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"This interface is sufficient to run most of the basic analyses, especially the flux balance finding ones:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"julia> flux_balance_analysis_dict(m, Tulip.Optimizer)\nDict{String, Float64} with 5 entries:\n  \"rxn5\" => 1.0\n  \"rxn2\" => 1.0\n  \"rxn1\" => 1.0\n  \"rxn3\" => 1.0\n  \"rxn4\" => 1.0\n","category":"page"},{"location":"advanced/2_custom_model/#Writing-generic-model-modifications","page":"Working with custom models","title":"Writing generic model modifications","text":"","category":"section"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The custom model structure can also be made compatible with many of the existing variant-generating functions and analysis modifiers.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The functions prepared for use as \"variants\" in screen, usually prefixed by with_, have their generic variants that only call simpler, overloadable functions for each specific model. This choice is based on the overloading dispatch system of Julia. For example,with_removed_metabolites is implemented very generically by reducing the problem to some specific remove_metabolites functions selected by the dispatch, as follows:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"with_removed_metabolites(args...; kwargs...) =\n    m -> remove_metabolites(m, args...; kwargs...)","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"To be able to use with_removed_metabolites in your model, we can just overload the actual inner function. For the simple circular model, the modification might as well look like this:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"COBREXA.remove_metabolites(m::CircularModel, n::Int) =\n    return CircularModel(m.size - n)","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"danger: Functions that generate model variants must be pure\nNotice that the function is \"pure\", i.e., does not make any in-place modifications to the original model structure. That property is required for screen and other functions to properly and predictably apply the modifications to the model. To expose potential in-place modifications to your codebase, you should instead overload the \"bang\" counterpart of remove metabolites, called remove_metabolites!.","category":"page"},{"location":"tutorials/2_analysis/#Basic-analysis-of-constraint-based-models","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"COBREXA.jl supports several common analysis methods that are often used for exploring the biological models. The currently supported methods include","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Flux balance analysis (FBA), in function flux_balance_analysis\nFlux variability analysis (FVA), in flux_variability_analysis\nFlux sampling by linearized hit-and-run algorithm, in affine_hit_and_run\nParsimonious flux balance analysis (pFBA), in parsimonious_flux_balance_analysis","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Other analysis methods are either in development and testing, or may be specified or customized by the user. Implementing new analyses is generally feasible; you may want to watch the COBREXA.jl repository for newly incoming analysis methods.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"COBREXA.jl additionally exports several helper functions that may help you in running custom analysis methods:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"you can convert all types of MetabolicModels to JuMP.jl models using make_optimization_model, then you may explore and analyze the models independently of COBREXA.jl using the tools provided by JuMP.jl\nthere is a system of analysis modifications that allows you to easily specify various adjustments to the existing analysis methods","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"tip: Notebook available!\nExamples of running the analysis functions are available here.","category":"page"},{"location":"tutorials/2_analysis/#Optimization-problem-solvers","page":"Basic analysis of constraint-based models","title":"Optimization problem solvers","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For solving most analysis tasks, you need an optimization problem solver that is compatible with JuMP.jl. You may refer to the official list of supported solvers, but we generally recommend to use either of these:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Tulip (pure Julia implementation) for linear problems\nGLPK (based on a C library) for linear and mixed-integer problems\nGurobi (based on an external library, but requires a license that is free for academic use) for linear, mixed-integer and quadratic problems","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"All solvers can be installed using the Julia package manger.","category":"page"},{"location":"tutorials/2_analysis/#Flux-balance-analysis","page":"Basic analysis of constraint-based models","title":"Flux balance analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"The above methods generally accept 2 arguments: the model, and the optimizer.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"In particular, having installed e.g. GLPK from the above optimizers, you can run FBA on your favorite E. Coli core model as follows:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"using COBREXA\nm = load_model(CoreModel, \"e_coli_core.xml\")\n\nusing GLPK\nopt_model = flux_balance_analysis(m, GLPK.Optimizer)","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"After a short while (the solver machinery usually needs to get precompiled before the first use), you should get opt_model, which is now an optimized JuMP.jl model. It may print out information like this:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"A JuMP Model\nMaximization problem with:\nVariables: 95\nObjective function type: JuMP.GenericAffExpr{Float64,JuMP.VariableRef}\n`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 73 constraints\n`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 192 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: GLPK\nNames registered in the model: lbs, mb, ubs, x","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"From that, you can extract the required information with the JuMP interface, loaded with using JuMP. With that,","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"objective_value(opt_model) prints roughly 0.87,\nvalue.(opt_model[:x]) prints the vector of individual reaction fluxes.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For convenience, you can get the results nicely formatted without manually getting them out of the optimized models:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"flux_balance_analysis_vec works like flux_balance_analysis, but returns the vector of fluxes directly (in the same order as in reactions(m))\nflux_balance_analysis_dict returns a dictionary with the fluxes, keyed by reaction identifier","category":"page"},{"location":"tutorials/2_analysis/#Flux-variability-analysis","page":"Basic analysis of constraint-based models","title":"Flux variability analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"FVA is implemented in flux_variability_analysis, which returns the usual matrix of minimal and maximal feasible fluxes for each reaction in the model.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"The result of calling flux_variability_analysis(m, GLPK.Optimizer) may look like this (possibly showing minor numeric errors in the GLPK optimizer):","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×2 Array{Float64,2}:\n   0.0            0.0\n   6.00725        6.00725\n   ⋮\n   3.64414e-13    3.17348e-13\n   3.2149         3.2149","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You can relax the optimality requirement of the reactions by specifying a wider objective bound, getting a wider range of reaction fluxes, e.g. using gamma_bounds (for COBRA-like γ-bound) and objective_bounds (for a multiplicative bound around the original optimal objective).","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"As a result, flux_variability_analysis(m, GLPK.Optimizer; bounds=gamma_bounds(0.8)) will return a much less constrained system:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×2 Array{Float64,2}:\n   0.0            0.0\n   0.754299      10.1285\n   ⋮\n  -4.42865        0.0\n   2.57192        3.2149","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You may additionally restrict the analysis to a list of reactions (passing the list as the second argument, see documentation of flux_variability_analysis), or retrieve a dictionary of the resulting fluxes with flux_variability_analysis_dict.","category":"page"},{"location":"tutorials/2_analysis/#Parsimonious-flux-balance-analysis","page":"Basic analysis of constraint-based models","title":"Parsimonious flux balance analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Parsimonious flux balance analysis (pFBA) requires a solver that can handle quadratic problems. Some examples include, e.g. OSQP, Gurobi, Mosek, etc.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Otherwise, the function behaves just like flux_balance_analysis:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"parsimonious_flux_balance_analysis(m, OSQP.Optimizer) will return a JuMP.jl model optimized to a slightly more realistic (parsimonious) optimum than plain FBA,\nparsimonious_flux_balance_analysis_vec will return the fluxes in a vector,\nparsimonious_flux_balance_analysis_dict will return a reaction-keyed dictionary.","category":"page"},{"location":"tutorials/2_analysis/#Flux-sampling","page":"Basic analysis of constraint-based models","title":"Flux sampling","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For the affine_hit_and_run, you need a previously optimized and constrained model from another analysis function, such as flux_balance_analysis, or created by make_optimization_model. You may need to carefully choose the number of iterations and sample sizes to match your model; see the documentation of affine_hit_and_run for details.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"As an example, you can run the sampling for 100 thousand iterations with:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"affine_hit_and_run(100_000, make_optimization_model(m, GLPK.Optimizer))","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You should receive a matching flux sample with the (default) 1000 samples in a matrix that may look like this one:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×1000 Array{Float64,2}:\n   0.0           0.0         …   0.0\n   7.82669       9.38895         3.30653\n   7.13016       4.36813         9.64434\n  -0.290925     -9.3037         -0.0908829\n  24.1294       17.4794          0.0511032\n   ⋮                         ⋱\n -16.243       -37.4763         -5.57301\n   0.0           0.0             0.0\n  -0.310819     -1.20057e-7     -2.13126\n   5.71597e-5    0.00990677      0.692399","category":"page"},{"location":"notebooks/#Notebooks-and-example-workflows","page":"Examples and notebooks","title":"Notebooks and example workflows","text":"","category":"section"},{"location":"notebooks/","page":"Examples and notebooks","title":"Examples and notebooks","text":"Pages = joinpath.(\"notebooks\", filter(x -> endswith(x, \".md\"), readdir(\"notebooks\")))\nDepth = 2","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/5_basic_stdmodel_construction.jl\"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Model-construction-and-modification","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"COBREXA can load models stored in .mat, .json, and .xml formats; and convert these into StandardModels. However, it is also possible to construct models from scratch, and modify existing models. This will be demonstrated here.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Model-construction","page":"Model construction and modification","title":"Model construction","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"In COBREXA, model construction is primarily supported through StandardModels. To begin, create an empty StandardModel.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"using COBREXA\n\nmodel = StandardModel(\"FirstModel\") # assign model id = \"FirstModel\"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"Next, genes, metabolites and reactions need to be added to the model.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-genes-to-the-model","page":"Model construction and modification","title":"Add genes to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"gene_list = [Gene(string(\"g\", num)) for num = 1:8]","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"warning: Warning: Don't accidentally overwrite the generic accessors\nIt may be tempting to call a variable genes, metabolites, or   reactions. However, these names conflict with generic accessors   functions and will create problems downstream.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"add_genes!(model, gene_list)","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-metabolites-to-the-model","page":"Model construction and modification","title":"Add metabolites to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"metabolite_list = [Metabolite(string(\"m\", num)) for num = 1:4]\n\nmetabolite_list[1].formula = \"C6H12O6\" # can edit metabolites, etc. directly\n\nadd_metabolites!(model, metabolite_list)","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-reactions-to-the-model","page":"Model construction and modification","title":"Add reactions to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"There are two ways to create and add reactions to a model. These are using functions, or macros.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"r_m1 = Reaction(\"EX_m1\", Dict(\"m1\" => -1.0), :bidirectional) # exchange reaction: m1 <-> (is the same as m1 ↔ nothing)\nr1 = Reaction(\"r1\", Dict(\"m1\" => -1.0, \"m2\" => 1.0), :forward)\nr1.grr = [[\"g1\", \"g2\"], [\"g3\"]] # add some gene reaction rules\nr2 = Reaction(\"r2\", Dict(\"m2\" => -1.0, \"m1\" => 1.0), :backward)\nr3 = Reaction(\"r3\", Dict(\"m2\" => -1.0, \"m3\" => 1.0), :bidirectional)\n\nadd_reactions!(model, [r1, r2, r3, r_m1]) # function approach\n\nm1 = metabolite_list[1]\nm2 = metabolite_list[2]\nm3 = metabolite_list[3]\nm4 = metabolite_list[4]\n\n@add_reactions! model begin # macro approach\n    \"r4\", m2 → m4, 0, 1000\n    \"r_m3\", m3 ↔ nothing, -1000, 1000\n    \"r_m4\", m4 → nothing\n    \"r5\", m4 → m2\nend\n\nmodel.reactions[\"r4\"].grr = [[\"g5\"], [\"g6\", \"g7\"], [\"g8\"]]","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"note: Note: Writing unicode arrows\nThe reaction arrows can be easily written by using the LaTeX completions built into Julia shell (and many Julia-compatible editors). You can type:→ as \\rightarrow (press Tab to complete)\n← as \\leftarrow\n↔ as \\leftrightarrow","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"The constructed model can now be inspected.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"model","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Modifying-existing-models","page":"Model construction and modification","title":"Modifying existing models","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"It is also possible to modify a model by deleting certain genes. This is simply achieved by calling remove_genes!.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"remove_genes!(model, [\"g1\", \"g2\"]; knockout_reactions = false)\nmodel","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"This page was generated using Literate.jl.","category":"page"},{"location":"advanced/1_variants/#Exploring-many-model-variants","page":"Exploring many model variants","title":"Exploring many model variants","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"A major goal of COBREXA.jl is to make exploring of many model variants easy and fast.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"One main concept that can be utilized for doing that is implemented in the function screen, which takes your model, a list of model variants that you want to explore by some specified analysis, and schedules the analysis of the model variants parallely on the available distributed workers.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"In its most basic form, the \"screening\" may use the slightly simplified variant of screen that is called screen_variants, which works as follows:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"m = load_model(StandardModel, \"e_coli_core.json\")\n\nscreen_variants(\n    m,    # the model for screening\n    [\n        [],    # a variant with no modifications\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0)],  # disable CO2 transport\n        [with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable O2 transport\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0), with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable both transports\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The call specifies a model (the m that we have loaded) that is being tested, then a vector of model variants to be created and tested, and then the analysis that is being run on each variant – in this case, we find an optimal steady state of each of the variants, and check out the biomass production rate at that state. In this particular case, we are checking what will be the effect of disabling combinations of CO2 transport and O2 transport in the cells. For that, we get the following result:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"4-element Vector{Float64}:\n 0.8739215022678488\n 0.46166961413944896\n 0.21166294973372135\n 0.21114065173865518","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The numbers are the biomass production rates for the specified variants. We can see that disabling O2 transport really does not help the organism much.","category":"page"},{"location":"advanced/1_variants/#Variant-specification","page":"Exploring many model variants","title":"Variant specification","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"In the above example, we have specified 4 variants, thus the analysis returned 4 different results that correspond with the specifications. Let us have a look at the precise format of the specification and result.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Importantly, the variants argument is of type Array{Vector{Any}}, meaning that it can be an array of any dimensionality that contains vectors. Each of the vectors specifies precisely one variant, possibly with more modifications applied to the model in sequence.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"For example:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"[] specifies no modifications at all\n[with_changed_bound(\"CO2t\", lb=0, ub=10)] limits the CO2 transport\n[with_changed_bound(\"CO2t\", lb=0, ub=2), with_changed_bound(\"O2t\", lb=0, ub=100)] severely limits the CO2 transport and slightly restricts the transport of O2","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"note: Variants are single-parameter model-transforming functions\nBecause the variants are just generators of single parameter functions that take the model and return its modified version, you can also use identity to specify a variant that does nothing – [identity] is perfectly same as []","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The shape of the variants array is important too, because it is precisely retained in the result (just as with pmap). If you pass in a matrix of variants, you will receive a matrix of analysis results of the same size. That can be exploited for easily exploring many combinations of possible model properties. Let's try exploring a \"cube\" of possible restricted reactions:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"using IterTools # for cartesian products\n\nres = screen_variants(m,\n    [\n        # for each variant we restricts 2 reactions\n        [with_changed_bound(r1, lb=-3, ub=3), with_changed_bound(r2, lb=-1, ub=1)]\n\n        # the reaction pair will be chosen from a cartesian product\n        for (r1,r2) in product(\n            [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"], # of this set of transport reactions\n            [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"], # and this set of exchanges\n        )\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"As a result, we will receive a full matrix of the biomass productions:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"4×4 Matrix{Float64}:\n 0.407666  0.454097  0.240106  0.183392\n 0.407666  0.485204  0.24766   0.183392\n 0.314923  0.319654  0.24766   0.183392\n 0.407666  0.485204  0.24766   0.183392","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Notably, this shows that O2 transport and NH4 exchange may be serious bottlenecks for biomass production.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"For clarity, you may always annotate the result by zipping it with the specification structure you have used and collecting the data:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"collect(zip(\n    product(\n        [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"],\n        [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"],\n    ),\n    res,\n))","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"...which gives the following annotated result:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"4×4 Matrix{Tuple{Tuple{String, String}, Float64}}:\n ((\"H2Ot\", \"EX_h2o_e\"), 0.407666)  ((\"H2Ot\", \"EX_co2_e\"), 0.454097)  ((\"H2Ot\", \"EX_o2_e\"), 0.240106)  ((\"H2Ot\", \"EX_nh4_e\"), 0.183392)\n ((\"CO2t\", \"EX_h2o_e\"), 0.407666)  ((\"CO2t\", \"EX_co2_e\"), 0.485204)  ((\"CO2t\", \"EX_o2_e\"), 0.24766)   ((\"CO2t\", \"EX_nh4_e\"), 0.183392)\n ((\"O2t\", \"EX_h2o_e\"), 0.314923)   ((\"O2t\", \"EX_co2_e\"), 0.319654)   ((\"O2t\", \"EX_o2_e\"), 0.24766)    ((\"O2t\", \"EX_nh4_e\"), 0.183392)\n ((\"NH4t\", \"EX_h2o_e\"), 0.407666)  ((\"NH4t\", \"EX_co2_e\"), 0.485204)  ((\"NH4t\", \"EX_o2_e\"), 0.24766)   ((\"NH4t\", \"EX_nh4_e\"), 0.183392)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"This may be easily used for e.g. scrutinizing all possible reaction pairs, to find the ones that are redundant and not.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"tip: Notebook available\nA notebook is available that demonstrates the screening on a larger scale.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"There are many other variant \"specifications\" to choose from. You may use with_added_reactions, with_removed_reactions, with_removed_metabolites, and others. Function reference contains a complete list; as a convention, names of the specifications all start with with_.","category":"page"},{"location":"advanced/1_variants/#Writing-custom-variant-functions","page":"Exploring many model variants","title":"Writing custom variant functions","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"It is actually very easy to create custom specifications that do any modification that you can implement, to be later used with screen_variants and screen.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Generally, the \"specifications\" are supposed to return a function that creates a modified copy of the model. The copy of the model may be shallow, but the functions should always prevent modifying the original model structure – screen is keeping a single copy of the original model at each worker to prevent unnecessary bulk data transport, and if that is changed in-place, all following analyses of the model will work on inconsistent data, usually returning wrong results (even randomly changing ones, because of the asynchronous nature of screen execution).","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Despite of that, writing a modification is easy. The simplest modification that \"does nothing\" (isomorphic to standard identity) can be formatted as follows:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"with_no_change = model -> model","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The modifications may change the model, provided it is copied properly. The following modification will remove a reaction called \"O2t\", effectively removing the possibility to transport oxygen. We require a specific type of model where this change is easy to perform (generally, not all variants may be feasible on all model types).","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"with_disabled_oxygen_transport = (model::StandardModel) -> begin\n\n    # make \"as shallow as possible\" copy of the `model`.\n    # Utilizing `deepcopy` is also possible, but inefficient.\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n\n    # remove the O2 transport from the model copy\n    delete!(new_model.reactions, \"O2t\")\n\n    return new_model #return the newly created variant\nend","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Finally, the whole definition may be parametrized as a normal function. The following variant removes any user-selected reaction:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"with_disabled_reaction(reaction_id) = (model::StandardModel) -> begin\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n    delete!(new_model.reactions, reaction_id) # use the parameter from the specification\n    return new_model\nend","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"In turn, these variants can be used in screen_variants just as we used with_changed_bound above:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"screen_variants(\n    m,    # the model for screening\n    [\n        [with_no_change],\n        [with_disabled_oxygen_transport],\n        [with_disabled_reaction(\"NH4t\")],\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"That should get you the results for all new variants of the model:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"3-element Vector{Float64}:\n 0.8739215022674809\n 0.21166294865468896\n 1.2907224478973395e-15","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"warning: Custom variants with distributed processing\nIf using distributed evaluation, remember the variant-generating functions need to be defined on all used workers (generating the variants in parallel on the workers allows COBREXA to run the screening process very efficiently, without unnecessary sending of bulk model data). Prefixing the definition with @everywhere is usually sufficient for that purpose.","category":"page"},{"location":"advanced/1_variants/#Passing-extra-arguments-to-the-analysis-function","page":"Exploring many model variants","title":"Passing extra arguments to the analysis function","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Some analysis functions may take additional arguments, which you might want to vary for the analysis. modifications argument of flux_balance_analysis_dict is one example of such argument, allowing you to specify details of the optimization procedure.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"screen function allows you to do precisely that – apart from variants, you may also specify an array of args of the same shape as variants, the entries of which will get passed together with the generated model variants to your specified analysis function. If either of the arguments is missing (or set to nothing), it is defaulted to \"no modifications\" or \"no arguments\".","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The arguments must be tuples; you may need to make 1-tuples from your data (e.g. using (value,)) if you want to pass just a single argument.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Let's try to use that functionality for trying to find a sufficient amount of iterations needed for Tulip solver to find a feasible solution:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"screen(m,\n    args = [(i,) for i in 5:15],  # the iteration counts, packed in 1-tuples\n    analysis = (m,a) -> # `args` elements get passed as the extra parameter here\n        flux_balance_analysis_vec(m,\n            Tulip.Optimizer;\n            modifications=[change_optimizer_attribute(\"IPM_IterationsLimit\", a)],\n        ),\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"From the result, we can see that Tulip would need at least 14 iterations to find a feasible region:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"11-element Vector{Union{Nothing, Vector{Float64}}}:\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]","category":"page"},{"location":"tutorials/3_hpc/#Distributed-processing-and-HPC-environments","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Distributed processing in Julia is represented mainly by the package Distributed.jl.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"COBREXA.jl is able to utilize this existing system to almost transparently run the large parallelizable analyses on multiple CPU cores and multiple computers connected through the network. Ultimately, the approach scales to thousands of computing nodes in large HPC facilities.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Here, we give a short overview of how to work in the distributed environment and utilize the resources for COBREXA.jl analyses.","category":"page"},{"location":"tutorials/3_hpc/#Starting-the-distributed-workers","page":"Distributed processing and HPC environments","title":"Starting the distributed workers","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"COBREXA.jl follows the structure imposed by the Distributed package: You operate a main (usually called \"master\") computation node, connect to multiple other computers and start worker Julia processes there, and distribute the workload across this cluster.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To start, you need to load the package and add a few processes. This starts 5 processes locally:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using Distributed\naddprocs(5)","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"note: `Distributed.jl` installation\nDistributed.jl usually comes pre-installed with Julia distribution, but you may still need to \"enable\" it by typing ] add Distributed.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"You may check that the workers are really there, using workers(). In this case, it should give you a vector of worker IDs, very likely equal to [2,3,4,5,6].","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"If you have compute resources available via a network, you may connect these as well, provided you have a secure shell (ssh) access to them. You will likely want to establish a key-based authentication (refer to ssh documentation) to make the connection easier.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With shell, check that you can ssh to a remote node and run Julia there:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"user@pc> ssh server\n...\nuser@server> julia\n...\njulia> _","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"top: Running shell commands from Julia\nIf you don't want to quit your Julia session to try out the ssh connection from the shell, press ; in the Julia prompt on the beginning of the line. The interpreter will execute your next line as a shell command.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"If this works for you, you can add some workers that run on the server from your Julia shell running on your pc. For example, the following starts 20 workers on the remote server and 10 workers on your friend's computer called joe_pc:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"addprocs([('server', 20), ('joe_pc', 10)])","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With this, you can schedule various computation on the workers; see the Julia manual of Distributed for basic details. You may try various convenience packages, such as DistributedArrays.jl and DistributedData.jl, to process any data in a distributed fashion.","category":"page"},{"location":"tutorials/3_hpc/#Running-a-distributed-analysis","page":"Distributed processing and HPC environments","title":"Running a distributed analysis","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"While not all COBREXA functions may be parallelized naturally, these that do will accept a special workers argument that specifies a list of worker IDs where the computation should be distributed. For the value, you can specify your desired worker IDs manually (e.g. [2,3,4]), or simply use workers().","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"For example, flux_variability_analysis can naturally parallelize the computation of all reactions's minima and maxima to finish the computation faster. To enable the parallelization, you first need to make sure that all workers have loaded both the COBREXA package and the optimizer:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using COBREXA, GLPK, Distributed\naddprocs(10)                       # add any kind and number of processes here\n@everywhere using COBREXA, GLPK    # loads the necessary packages on all workers","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"When the package is loaded and precompiled everywhere, you may load your model and run the FVA with the workers parameter:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"model = load_model(\"e_coli_core.xml\")\nresult = flux_variability_analysis(model, GLPK.Optimizer; workers=workers())","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With the extra computing capacity from N workers available, the FVA should be computed roughly N-times faster.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"note: Distribution and parallelization overhead\nCommunication of the workers with your Julia shell is not free. If the task that you are parallelizing is small and the model structure is very large, the distributed computation will actually spend most computation time just distributing the large model to the workers, and almost no time in executing the small parallel task. In such case, the performance will not improve by adding additional resources. You may want to check that the computation task is sufficiently large before investing the extra resources into the distributed execution. Amdahl's and Gustafson's laws can give you a better overview of the consequences of this overhead.","category":"page"},{"location":"tutorials/3_hpc/#Interacting-with-HPC-schedulers","page":"Distributed processing and HPC environments","title":"Interacting with HPC schedulers","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Many researchers have access to institutional HPC facilities that allow time-sharing of the capacity of a large computer cluster between many researchers. Julia and COBREXA.jl work well within this environment; but your programs require some additional customization to be able to find and utilize the resources available from the HPC.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"In our case, this reduces to a relatively complex task: You need to find out how many resources were allocated for your task, and you need to add the remote workers precisely at places that were allocated for your. Fortunately, the package ClusterManagers.jl can do precisely that.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"For simplicily, we will assume that your HPC is scheduled by Slurm.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Adding of the workers from Slurm is done as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"you import the ClusterManagers package\nyou find how many processes to spawn from the environment from SLURM_NTASKS environment variable\nyou use the function addprocs_slurm to precisely connect to your allocated computational resources","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"The Julia script that does a parallel analysis may then start as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using COBREXA, Distributed, ClusterManagers\n\navailable_workers = parse(Int, ENV[\"SLURM_NTASKS\"])\n\naddprocs_slurm(available_workers)\n\n...\nresult = flux_variability_analysis(...; workers=workers())\n...","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"After adding the Slurm workers, you may continue as if the workers were added using normal addprocs, and (for example) run the flux_variability_analysis as shown above.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"tip: What about the other HPC schedulers?\nClusterManagers.jl supports many other common HPC scheduling systems, including LFS, Sun Grid, SGE, PBS, and Scyld, in a way almost identical to Slurm. See the package documentation for details.","category":"page"},{"location":"tutorials/3_hpc/#Wrapping-your-script-in-a-Slurm-job","page":"Distributed processing and HPC environments","title":"Wrapping your script in a Slurm job","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To be able to submit your script for later processing using the sbatch Slurm command, you need to wrap it in a small \"batch\" script that tells Slurm how many resources the process needs.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Assuming you have a Julia computation script written down in myJob.jl and saved on your HPC cluster's access node, the corresponding Slurm batch script (let's call it myJob.sbatch) may look as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"#!/bin/bash -l\n#SBATCH -n 100           # the job will require 100 individual workers\n#SBATCH -c 1             # each worker will sit on a single CPU\n#SBATCH -t 30            # the whole job will take less than 30 minutes\n#SBATCH -J myJob         # the name of the job\n\nmodule load lang/Julia   # this is usually required to make Julia available to your job\n\njulia myJob.jl","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To run the computation, simply run sbatch myJob.sbatch on the access node. The job will be scheduled and eventually executed. You may watch sacct and squeue in the meantime, to see the progress.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Remember that you need to explicitly save the result of your Julia script computation to files, to be able to retrieve them later. Standard outputs of the jobs are often mangled and discarded. If you still want to collect the standard output, you may change the last line of the batch script to","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"julia myJob.jl > myJob.log","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"and collect the output from the log later. This is convenient especially if logging various computation details using the @info and similar macros.","category":"page"},{"location":"functions/#Functions","page":"Function reference","title":"Functions","text":"","category":"section"},{"location":"functions/#Base-Types","page":"Function reference","title":"Base Types","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", \"abstract\", file), readdir(\"../src/base/types/abstract\"))","category":"page"},{"location":"functions/#COBREXA.Maybe","page":"Function reference","title":"COBREXA.Maybe","text":"Maybe{T} = Union{Nothing, T}\n\nA nice name for \"nullable\" type.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA._default-Union{Tuple{T}, Tuple{T, Union{Nothing, T}}} where T","page":"Function reference","title":"COBREXA._default","text":"_default(d::T, x::Maybe{T})::T where {T}\n\nFold the Maybe{T} down to T by defaulting.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._maybemap-Tuple{Any, Union{Nothing, T} where T}","page":"Function reference","title":"COBREXA._maybemap","text":"_maybemap(f, x::Maybe)::Maybe\n\nApply a function to x only if it is not nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Annotations","page":"Function reference","title":"COBREXA.Annotations","text":"Annotations = Dict{String,Vector{String}}\n\nDictionary used to store (possible multiple) standardized annotations of something, such as a Metabolite and a Reaction.\n\nExample\n\nAnnotations(\"PubChem\" => [\"CID12345\", \"CID54321\"])\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.GeneAssociation","page":"Function reference","title":"COBREXA.GeneAssociation","text":"GeneAssociation = Vector{Vector{String}}\n\nAn association to genes, represented as a logical formula in a positive disjunctive normal form (DNF). (The 2nd-level vectors of strings are connected by \"and\" to form conjunctions, and the 1st-level vectors of these conjunctions are connected by \"or\" to form the DNF.)\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.MetabolicModel","page":"Function reference","title":"COBREXA.MetabolicModel","text":"abstract type MetabolicModel end\n\nA helper supertype that wraps everything usable as a linear-like model for COBREXA functions.\n\nIf you want your model type to work with COBREXA, add the MetabolicModel as its supertype, and implement the accessor functions. Accessors reactions, metabolites, stoichiometry, bounds and objective must be implemented; others are not mandatory and default to safe \"empty\" values.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.MetaboliteFormula","page":"Function reference","title":"COBREXA.MetaboliteFormula","text":"MetaboliteFormula = Dict{String,Int}\n\nDictionary of atoms and their abundances in a molecule.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.Notes","page":"Function reference","title":"COBREXA.Notes","text":"Notes = Dict{String,Vector{String}}\n\nFree-form notes about something (e.g. a Gene), categorized by \"topic\".\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.balance-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(a::MetabolicModel)::SparseVec\n\nGet the sparse balance vector of a model (ie. the b from S x = b).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(a::MetabolicModel)::Tuple{SparseVec,SparseVec}\n\nGet the lower and upper flux bounds of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.coupling","text":"coupling(a::MetabolicModel)::SparseMat\n\nGet a matrix of coupling constraint definitions of a model. By default, there is no coupling in the models.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling_bounds-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::MetabolicModel)::Tuple{SparseVec,SparseVec}\n\nGet the lower and upper bounds for each coupling bound in a model, as specified by coupling. By default, the model does not have any coupling bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_annotations-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.gene_annotations","text":"gene_annotations(a::MetabolicModel, gene_id::String)::Annotations\n\nReturn standardized names that identify the corresponding gene or product. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"PDB\" => [\"PROT01\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_notes-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.gene_notes","text":"gene_notes(model::MetabolicModel, gene_id::String)::Notes\n\nReturn the notes associated with the gene gene_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(a::MetabolicModel)::Vector{String}\n\nReturn identifiers of all genes contained in the model. By default, there are no genes.\n\nIn SBML, these are usually called \"gene products\" but we write genes for simplicity.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_annotations-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(a::MetabolicModel, metabolite_id::String)::Annotations\n\nReturn standardized names that may help to reliably identify the metabolite. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"ChEMBL\" => [\"123\"] or \"PubChem\" => [\"CID123\", \"CID654645645\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolitecharge(model::MetabolicModel, metaboliteid::String)::Maybe{Int}\n\nReturn the charge associated with metabolite metabolite_id in model. Returns nothing if charge not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::MetabolicModel, metabolite_id::String)::Maybe{String}\n\nReturn the compartment of metabolite metabolite_id in model if it is assigned. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(\n    a::MetabolicModel,\n    metabolite_id::String,\n)::Maybe{MetaboliteFormula}\n\nReturn the formula of metabolite metabolite_id in model. Return nothing in case the formula is not known or irrelevant.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_notes-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::MetabolicModel, metabolite_id::String)::Notes\n\nReturn the notes associated with metabolite reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(a::MetabolicModel)::Vector{String}\n\nReturn a vector of metabolite identifiers in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_coupling_constraints-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::MetabolicModel)::Int\n\nGet the number of coupling constraints in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_genes-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_genes","text":"n_genes(a::MetabolicModel)::Int\n\nReturn the number of genes in the model (as returned by genes). If you just need the number of the genes, this may be much more efficient than calling genes and measuring the array.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_metabolites-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_metabolites","text":"n_metabolites(a::MetabolicModel)::Int\n\nGet the number of metabolites in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_reactions-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.n_reactions","text":"n_reactions(a::MetabolicModel)::Int\n\nGet the number of reactions in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(a::MetabolicModel)::SparseVec\n\nGet the objective vector of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.precache!-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.precache!","text":"precache!(a::MetabolicModel)::Nothing\n\nDo whatever is feasible to get the model into a state that can be read from as-quickly-as-possible. This may include e.g. generating helper index structures and loading delayed parts of the model from disk. The model should be modified \"transparently\" in-place. Analysis functions call this right before applying modifications or converting the model to the optimization model using make_optimization_model; usually on the same machine where the optimizers (and, generally, the core analysis algorithms) will run. The calls are done in a good hope that the performance will be improved.\n\nBy default, it should be safe to do nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_annotations-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_annotations","text":"reaction_annotations(a::MetabolicModel, reaction_id::String)::Annotations\n\nReturn standardized names that may help identifying the reaction. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"Reactome\" => [\"reactomeID123\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(a::MetabolicModel, gene_id::String)::Maybe{GeneAssociation}\n\nReturns the sets of genes that need to be present so that the reaction can work (technically, a DNF on gene availability, with positive atoms only).\n\nFor simplicity, nothing may be returned, meaning that the reaction always takes place. (in DNF, that would be equivalent to returning [[]].)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_notes-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_notes","text":"reaction_notes(model::MetabolicModel, reaction_id::String)::Notes\n\nReturn the notes associated with reaction reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::MetaboliteModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid in the model. The dictionary maps the metabolite IDs to their stoichiometric coefficients.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_subsystem-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::MetabolicModel, reaction_id::String)::Maybe{String}\n\nReturn the subsystem of reaction reaction_id in model if it is assigned. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(a::MetabolicModel)::Vector{String}\n\nReturn a vector of reaction identifiers in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(a::MetabolicModel)::SparseMat\n\nGet the sparse stoichiometry matrix of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Model-types-and-contents","page":"Function reference","title":"Model types and contents","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", file), readdir(\"../src/base/types\"))","category":"page"},{"location":"functions/#COBREXA.CoreModel","page":"Function reference","title":"COBREXA.CoreModel","text":"struct CoreModel <: MetabolicModel\n\nA \"bare bones\" core linear optimization problem of the form, with reaction and metabolite names.\n\nmin c^T x\ns.t. S x = b\n      xₗ ≤ x ≤ xᵤ\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Union{Tuple{M}, Tuple{Type{CoreModel}, M}} where M<:MetabolicModel","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{CoreModel}, m::M) where {M <: MetabolicModel}\n\nMake a CoreModel out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(a::CoreModel)::SparseVec\n\nCoreModel target flux balance.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(a::CoreModel)::Tuple{SparseVec,SparseVec}\n\nCoreModel flux bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(a::CoreModel)::Vector{String}\n\nMetabolites in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(a::CoreModel)::SparseVec\n\nCoreModel objective vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{CoreModel, Any}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModel, ridx)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction at index ridx.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{CoreModel, String}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(a::CoreModel)::Vector{String}\n\nGet the reactions in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{CoreModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(a::CoreModel)::SparseMat\n\nCoreModel stoichiometry matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.CoreModelCoupled","page":"Function reference","title":"COBREXA.CoreModelCoupled","text":"struct CoreModelCoupled <: MetabolicModel\n\nThe linear model with additional coupling constraints in the form\n\n    cₗ ≤ C x ≤ cᵤ\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{CoreModelCoupled}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{CoreModelCoupled}, mm::MetabolicModel)\n\nMake a CoreModelCoupled out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.balance","text":"balance(a::CoreModelCoupled)\n\nExtract balance from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(a::CoreModelCoupled)\n\nExtract bounds from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.coupling","text":"coupling(a::CoreModelCoupled)::SparseMat\n\nCoupling constraint matrix for a CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling_bounds-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::CoreModelCoupled)::Tuple{SparseVec,SparseVec}\n\nCoupling bounds for a CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(a::CoreModelCoupled)\n\nExtract metabolites from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_coupling_constraints-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::CoreModelCoupled)::Int\n\nThe number of coupling constraints in a CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.objective","text":"objective(a::CoreModelCoupled)\n\nExtract objective from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{CoreModelCoupled, Any}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModelCoupled, ridx)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction at index ridx.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{CoreModelCoupled, String}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModelCoupled, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(a::CoreModelCoupled)\n\nExtract reactions from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{CoreModelCoupled}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(a::CoreModelCoupled)\n\nExtract stoichiometry from CoreModelCoupled (uses the internal CoreModel).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.FluxSummary","page":"Function reference","title":"COBREXA.FluxSummary","text":"FluxSummary\n\nA struct used to store summary information about the solution of a constraint based analysis result.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.FluxSummary-Tuple{}","page":"Function reference","title":"COBREXA.FluxSummary","text":"FluxSummary()\n\nA default empty constructor for FluxSummary.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_summary-Tuple{Union{Nothing, Dict{String, Float64}}}","page":"Function reference","title":"COBREXA.flux_summary","text":"flux_summary(flux_result::Dict{String, Float64};\n            exclude_exchanges = false,\n            exchange_prefixes = _constants.exchange_prefixes,\n            biomass_strings = _constants.biomass_strings,\n            exclude_biomass = false,\n            small_flux_bound = 1.0/_constants.default_reaction_bound^2,\n            large_flux_bound = _constants.default_reaction_bound,\n            keep_unbounded = false,\n            )::FluxSummary\n\nSummarize a dictionary of fluxes into small, useful representation of the most important information contained. Useful for pretty-printing and quickly exploring the results. Internally this function uses looks_like_biomass_reaction and looks_like_exchange_reaction. The corresponding keyword arguments passed to these functions. Use this if your model has non-standard ids for reactions. Fluxes smaller than small_flux_bound are not stored, while fluxes larger than large_flux_bound are only stored if keep_unbounded is true.\n\nExample\n\njulia> sol = flux_balance_analysis_dict(model, Tulip.Optimizer)\njulia> fr = flux_summary(sol)\nBiomass:\n  BIOMASS_Ecoli_core_w_GAM: 0.8739\nImport:\n  EX_o2_e:     -21.7995\n  EX_glc__D_e: -10.0\n  EX_nh4_e:    -4.7653\n  EX_pi_e:     -3.2149\nExport:\n  EX_h_e:      17.5309\n  EX_co2_e:    22.8098\n  EX_h2o_e:    29.1758\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.FluxVariabilitySummary","page":"Function reference","title":"COBREXA.FluxVariabilitySummary","text":"FluxVariabilitySummary\n\nA struct used to store summary information about the solution of a flux variability analysis result.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.FluxVariabilitySummary-Tuple{}","page":"Function reference","title":"COBREXA.FluxVariabilitySummary","text":"FluxVariabilitySummary()\n\nA default empty constructor for FluxVariabilitySummary\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_variability_summary-Tuple{Tuple{Dict{String, Dict{String, Float64}}, Dict{String, Dict{String, Float64}}}}","page":"Function reference","title":"COBREXA.flux_variability_summary","text":"flux_variability_summary(flux_result::Tuple{Dict{String, Dict{String, Float64}}, Dict{String, Dict{String, Float64}}};\n    exclude_exchanges = false,\n    exchange_prefixes = _constants.exchange_prefixes,\n    biomass_strings = _constants.biomass_strings,\n    exclude_biomass = false,\n    )::FluxVariabilitySummary\n\nSummarize a dictionary of flux dictionaries obtained eg. from fluxvariabilityanalysisdict. The simplified summary representation is useful for pretty-printing and easily showing the most important results. Internally this function uses [`lookslikebiomassreaction](@ref) and [lookslikeexchange_reaction`](@ref). The corresponding keyword arguments passed to these functions. Use this if your model has non-standard ids for reactions.\n\nExample\n\njulia> sol = flux_variability_analysis_dict(model, Gurobi.Optimizer; bounds = objective_bounds(0.99))\njulia> flux_res = flux_variability_summary(sol)\nBiomass                     Lower bound   Upper bound\n  BIOMASS_Ecoli_core_w_GAM: 0.8652        0.8652\nExchange\n  EX_h2o_e:                 28.34         28.34\n  EX_co2_e:                 22.0377       22.0377\n  EX_o2_e:                  -22.1815      -22.1815\n  EX_h_e:                   17.3556       17.3556\n  EX_glc__D_e:              -10.0         -10.0\n  EX_nh4_e:                 -4.8448       -4.8448\n  EX_pi_e:                  -3.2149       -3.2149\n  EX_for_e:                 0.0           0.0\n  ...                       ...           ...\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Gene","page":"Function reference","title":"COBREXA.Gene","text":"Gene struct.\n\nFields\n\nid :: String\nnotes :: Dict{String, Vector{String}}\nannotation :: Dict{String, Union{Vector{String}, String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.JSONModel","page":"Function reference","title":"COBREXA.JSONModel","text":"struct JSONModel <: MetabolicModel\n    json::Dict{String,Any}\n    rxn_index::Dict{String,Int}\n    rxns::Vector{Any}\n    met_index::Dict{String,Int}\n    mets::Vector{Any}\n    gene_index::Dict{String,Int}\n    genes::Vector{Any}\nend\n\nA struct used to store the contents of a JSON model, i.e. a model read from a file ending with .json. These model files typically store all the model data in arrays of JSON objects (represented in Julia as vectors of dictionaries).\n\nUsually, not all of the fields of the input JSON can be easily represented when converting to other models, care should be taken to avoid losing information.\n\nDirect work with the json structure is not very efficient; the model structure therefore caches some of the internal structure in the extra fields. The single-parameter JSONModel constructor creates these caches correctly from the json. The model structure is designed as read-only, and changes in json invalidate the cache.\n\nExample\n\nmodel = load_json_model(\"some_model.json\")\nmodel.json # see the actual underlying JSON\nreactions(model) # see the list of reactions\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{JSONModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{JSONModel}, mm::MetabolicModel)\n\nConvert any MetabolicModel to JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(model::JSONModel)\n\nGet the bounds for reactions, assuming the information is stored in .lower_bound and .upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_annotations-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.gene_annotations","text":"gene_annotations(model::JSONModel, gid::String)::Annotations\n\nGene annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_notes-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.gene_notes","text":"gene_notes(model::JSONModel, gid::String)::Notes\n\nGene notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(model::JSONModel)\n\nExtract gene names from a JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_annotations-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::JSONModel, mid::String)::Annotations\n\nMetabolite annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::JSONModel, mid::String)\n\nReturn the metabolite .charge\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::JSONModel, mid::String)\n\nReturn the metabolite .compartment\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::JSONModel, mid::String)\n\nParse and return the metabolite .formula\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_notes-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::JSONModel, mid::String)::Notes\n\nMetabolite notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(model::JSONModel)\n\nExtract metabolite names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(model::JSONModel)\n\nCollect .objective_coefficient keys from model reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_annotations-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::JSONModel, rid::String)::Annotations\n\nReaction annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_associaton(model::JSONModel, rid::String)\n\nParses the .gene_reaction_rule from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_notes-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_notes","text":"reaction_notes(model::JSONModel, rid::String)::Notes\n\nReaction notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::JSONModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_subsystem-Tuple{JSONModel, String}","page":"Function reference","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::JSONModel, rid::String)\n\nParses the .subsystem out from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(model::JSONModel)\n\nExtract reaction names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{JSONModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(model::JSONModel)\n\nGet the stoichiometry. Assuming the information is stored in reaction object under key .metabolites.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.MATModel","page":"Function reference","title":"COBREXA.MATModel","text":"struct MATModel\n\nWrapper around the models loaded in dictionaries from the MATLAB representation.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{MATModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{MATModel}, m::MetabolicModel)\n\nConvert any metabolic model to MATModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._mat_has_squashed_coupling-Tuple{Any}","page":"Function reference","title":"COBREXA._mat_has_squashed_coupling","text":"_mat_has_squashed_coupling(mat)\n\nGuesses whether C in the MAT file is stored in A=[S;C].\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{MATModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(m::MATModel)\n\nExtracts balance from the MAT model, defaulting to zeroes if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{MATModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(m::MATModel)\n\nExtracts bounds from the MAT file, saved under lb and ub.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling-Tuple{MATModel}","page":"Function reference","title":"COBREXA.coupling","text":"coupling(m::MATModel)\n\nExtract coupling matrix stored, in C key.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.coupling_bounds-Tuple{MATModel}","page":"Function reference","title":"COBREXA.coupling_bounds","text":"coupling_bounds(m::MATModel)\n\nExtracts the coupling constraints. Currently, there are several accepted ways to store these in MATLAB models; this takes the constraints from vectors cl and cu.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{MATModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(m::MATModel)\n\nExtracts the possible gene list from genes key.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(m::MATModel, mid::String)\n\nExtract metabolite charge from metCharge or metCharges.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(m::MATModel, mid::String)\n\nExtract metabolite compartment from metCompartment or metCompartments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(m::MATModel, mid::String)\n\nExtract metabolite formula from key metFormula or metFormulas.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{MATModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(m::MATModel)::Vector{String}\n\nExtracts metabolite names from mets key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{MATModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(m::MATModel)\n\nExtracts the objective from the MAT model (defaults to zeroes).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(m::MATModel, rid::String)\n\nExtracts the associations from grRules key, if present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{MATModel, Any}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::MATModel, ridx)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction at index ridx.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{MATModel, String}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::MATModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{MATModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(m::MATModel)::Vector{String}\n\nExtracts reaction names from rxns key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{MATModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(m::MATModel)\n\nExtract the stoichiometry matrix, stored under key S.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Metabolite","page":"Function reference","title":"COBREXA.Metabolite","text":"Metabolite structure.\n\nFields\n\nid :: String\nformula :: String\ncharge :: Int\ncompartment :: String\nnotes :: Dict{String, Vector{String}}\nannotation :: Dict{String, Union{Vector{String}, String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.Reaction","page":"Function reference","title":"COBREXA.Reaction","text":"mutable struct Reaction\n    id::String\n    metabolites::Dict{String,Float64}\n    lb::Float64\n    ub::Float64\n    grr::Maybe{GeneAssociation}\n    subsystem::Maybe{String}\n    notes::Notes\n    annotations::Annotations\n    objective_coefficient::Float64\nend\n\nA structure for representing a single reaction in a StandardModel.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.Reaction-2","page":"Function reference","title":"COBREXA.Reaction","text":"Reaction(\n    id = \"\";\n    metabolites = Dict{String,Float64}(),\n    lb = -_constants.default_reaction_bound,\n    ub = _constants.default_reaction_bound,\n    grr = nothing,\n    subsystem = nothing,\n    notes = Notes(),\n    annotations = Annotations(),\n    objective_coefficient = 0.0,\n)\n\nA constructor for Reaction that only takes a reaction id and assigns default/uninformative values to all the fields that are not explicitely assigned.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.Reaction-3","page":"Function reference","title":"COBREXA.Reaction","text":"Reaction(\n    id::String,\n    metabolites::Dict{String,Union{Int, Float64}},\n    dir = :bidirectional;\n    default_bound = _constants.default_reaction_bound,\n)\n\nConvenience constructor for Reaction. The reaction equation is specified using metabolites, which is a dictionary mapping metabolite ids to stoichiometric coefficients. The direcion of the reaction is set through dir which can take :bidirectional, :forward, and :reverse as values. Finally, the default_bound is the value taken to mean infinity in the context of constraint based models, often this is set to a very high flux value like 1000.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.ReactionStatus","page":"Function reference","title":"COBREXA.ReactionStatus","text":"Used for concise reporting of modeling results.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.SBMLModel","page":"Function reference","title":"COBREXA.SBMLModel","text":"struct SBMLModel\n\nThin wrapper around the model from SBML.jl library. Allows easy conversion from SBML to any other model format.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{SBMLModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{SBMLModel}, mm::MetabolicModel)\n\nConvert any metabolic model to SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(model::SBMLModel)::SparseVec\n\nBalance vector of a SBMLModel. This is always zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(model::SBMLModel)::Tuple{SparseVec,SparseVec}\n\nGet the lower and upper flux bounds of model SBMLModel. Throws DomainError in case if the SBML contains mismatching units.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(model::SBMLModel)::Vector{String}\n\nGet genes of a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{SBMLModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::SBMLModel, mid::String)::Maybe{Int}\n\nGet charge of a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{SBMLModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::SBMLModel, mid::String)::Maybe{MetaboliteFormula}\n\nGet MetaboliteFormula from a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(model::SBMLModel)::Vector{String}\n\nGet metabolites from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_genes-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.n_genes","text":"n_genes(model::SBMLModel)::Int\n\nGet number of genes in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_metabolites-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.n_metabolites","text":"n_metabolites(model::SBMLModel)::Int\n\nEfficient counting of metabolites in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_reactions-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.n_reactions","text":"n_reactions(model::SBMLModel)::Int\n\nEfficient counting of reactions in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(model::SBMLModel)::SparseVec\n\nObjective of the SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{SBMLModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::SBMLModel, rid::String)::Maybe{GeneAssociation}\n\nRetrieve the GeneAssociation from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{SBMLModel, String}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::SBMLModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(model::SBMLModel)::Vector{String}\n\nGet reactions from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{SBMLModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(model::SBMLModel)::SparseMat\n\nRecreate the stoichiometry matrix from the SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.Serialized","page":"Function reference","title":"COBREXA.Serialized","text":"mutable struct Serialized{M <: MetabolicModel}\n    m::Maybe{M}\n    filename::String\nend\n\nA meta-model that represents a model that is serialized on the disk. The internal model will be loaded on-demand by using any accessor, or by calling precache! directly.\n\n\n\n\n\n","category":"type"},{"location":"functions/#COBREXA.precache!-Tuple{Serialized}","page":"Function reference","title":"COBREXA.precache!","text":"precache!(model::Serialized{MetabolicModel})::Nothing\n\nLoad the Serialized model from disk in case it's not alreadly loaded.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.StandardModel","page":"Function reference","title":"COBREXA.StandardModel","text":"mutable struct StandardModel\n\nStandardModel is used to store a constraint based metabolic model with meta-information.  Meta-information is defined as annotation details, which include gene-reaction-rules, formulas, etc.\n\nThis model type seeks to keep as much meta-information as possible, as opposed to CoreModel and CoreModelCoupled, which keep the bare neccessities only. When merging models and keeping meta-information is important, use this as the model type.  If meta-information is not important, use the more efficient core model types.  See CoreModel and CoreModelCoupled for comparison.\n\nIn this model, reactions, metabolites, and genes are stored in ordered dictionaries indexed by each struct's id field.  For example, model.reactions[\"rxn1_id\"] returns a Reaction where the field id equals \"rxn1_id\".  This makes adding and removing reactions efficient.\n\nNote that the stoichiometric matrix (or any other core data, e.g. flux bounds) is not stored directly as in CoreModel.  When this model type is used in analysis functions, these core data structures are built from scratch each time an analysis function is called.  This can cause performance issues if you run many small analysis functions sequentially.  Consider using the core model types if performance is critical.\n\nSee also: Reaction, Metabolite, Gene\n\nFields\n\nid :: String\nreactions :: OrderedDict{String, Reaction}\nmetabolites :: OrderedDict{String, Metabolite}\ngenes :: OrderedDict{String, Gene}\n\nExample\n\nmodel = load_model(StandardModel, \"my_model.json\")\nkeys(model.reactions)\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.convert-Tuple{Type{StandardModel}, MetabolicModel}","page":"Function reference","title":"Base.convert","text":"Base.convert(::Type{StandardModel}, model::MetabolicModel)\n\nConvert any MetabolicModel into a StandardModel. Note, some data loss may occur since only the generic interface is used during the conversion process.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.balance-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.balance","text":"balance(model::StandardModel)\n\nReturn the balance of the linear problem, i.e. b in Sv = 0 where S is the stoichiometric matrix and v is the flux vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.bounds-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.bounds","text":"bounds(model::StandardModel)\n\nReturn the lower and upper bounds, respectively, for reactions in model. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_annotations-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.gene_annotations","text":"gene_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gene_notes-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.gene_notes","text":"gene_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.genes-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.genes","text":"genes(model::StandardModel)\n\nReturn a vector of gene id strings in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.lower_bounds-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.lower_bounds","text":"lower_bounds(model::StandardModel)\n\nReturn the lower bounds for all reactions in model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_annotations-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_charge-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::StandardModel, id::String)\n\nReturn the charge associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_compartment-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::StandardModel, id::String)\n\nReturn compartment associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_formula-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::StandardModel, id::String)\n\nReturn the formula of reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_notes-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolites-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.metabolites","text":"metabolites(model::StandardModel)\n\nReturn a vector of metabolite id strings contained in model. The order of metabolite strings returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_genes-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.n_genes","text":"n_genes(model::StandardModel)\n\nReturn the number of genes in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_metabolites-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.n_metabolites","text":"n_metabolites(model::StandardModel)\n\nReturn the number of metabolites in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.n_reactions-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.n_reactions","text":"n_reactions(model::StandardModel)\n\nReturn the number of reactions contained in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.objective","text":"objective(model::StandardModel)\n\nReturn sparse objective vector for model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_annotations-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_gene_association-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::StandardModel, id::String)\n\nReturn the gene reaction rule in string format for reaction with id in model. Return nothing if not available.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_notes-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_notes","text":"reaction_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_stoichiometry-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::StandardModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_subsystem-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(id::String, model::StandardModel)\n\nReturn the subsystem associated with reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reactions-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.reactions","text":"reactions(model::StandardModel)\n\nReturn a vector of reaction id strings contained in model. The order of reaction ids returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.stoichiometry","text":"stoichiometry(model::StandardModel)\n\nReturn the stoichiometric matrix associated with model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.upper_bounds-Tuple{StandardModel}","page":"Function reference","title":"COBREXA.upper_bounds","text":"upper_bounds(model::StandardModel)\n\nReturn the upper bounds for all reactions in model in sparse format. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base-functions","page":"Function reference","title":"Base functions","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", file), readdir(\"../src/base\"))","category":"page"},{"location":"functions/#COBREXA._constants","page":"Function reference","title":"COBREXA._constants","text":"A named tuple that contains the magic values that are used globally for whatever purposes.\n\n\n\n\n\n","category":"constant"},{"location":"functions/#COBREXA.get_optmodel_bounds-Tuple{Any}","page":"Function reference","title":"COBREXA.get_optmodel_bounds","text":"get_optmodel_bounds(opt_model)\n\nReturns vectors of the lower and upper bounds of opt_model constraints, where opt_model is a JuMP model constructed by e.g. make_optimization_model or flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.is_solved-Tuple{Any}","page":"Function reference","title":"COBREXA.is_solved","text":"is_solved(optmodel)\n\nReturn true if optmodel solved successfully (solution is optimal or locally optimal).  Return false if any other termination status is reached. Termination status is defined in the documentation of JuMP.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.make_optimization_model-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.make_optimization_model","text":"make_optimization_model(\n    model::MetabolicModel,\n    optimizer;\n    sense = MOI.MAX_SENSE,\n)\n\nConvert MetabolicModels to a JuMP model, place objectives and the equality constraint.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.optimize_objective-Tuple{Any}","page":"Function reference","title":"COBREXA.optimize_objective","text":"optimize_objective(optmodel)::Union{Float64,Nothing}\n\nShortcut for running JuMP optimize! on a model and returning the objective value, if solved.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.set_optmodel_bound!-Tuple{Any, Any}","page":"Function reference","title":"COBREXA.set_optmodel_bound!","text":"set_optmodel_bound!(vidx, opt_model;\n    ub::Maybe{Real} = nothing,\n    lb::Maybe{Real} = nothing,\n)\n\nHelper function to set the bounds of a variable in the model. Internally calls set_normalized_rhs from JuMP. If the bounds are set to nothing, they will not be changed.\n\n\n\n\n\n","category":"method"},{"location":"functions/#File-I/O-and-serialization","page":"Function reference","title":"File I/O and serialization","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", file), readdir(\"../src/io\"))","category":"page"},{"location":"functions/#COBREXA.load_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_model","text":"load_model(file_name::String)::MetabolicModel\n\nGeneric function for loading models that chooses a specific loader function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nSBML models (*.xml, loaded with load_sbml_model)\nJSON models (*.json, loaded with load_json_model)\nMATLAB models (*.mat, loaded with load_mat_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_model-Union{Tuple{T}, Tuple{Type{T}, String}} where T<:MetabolicModel","page":"Function reference","title":"COBREXA.load_model","text":"load_model(type::Type{T}, file_name::String)::T where T\n\nHelper function tht loads the model using load_model and return it converted to type.\n\nExample:\n\nload_model(CoreModel, \"mySBMLModel.xml\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.save_model-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.save_model","text":"save_model(model::MetabolicModel, file_name::String)\n\nGeneric function for saving models that chooses a specific writer function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nJSON models (*.json, loaded with save_json_model)\nMATLAB models (*.mat, loaded with save_mat_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_json_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_json_model","text":"load_json_model(filename::String)::JSONModel\n\nLoad and return a JSON-formatted model that is stored in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.save_json_model-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.save_json_model","text":"save_json_model(model::MetabolicModel, file_name::String)\n\nSave a JSONModel in model to a JSON file file_name.\n\nIn case the model is not JSONModel, it will be converted automatically.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_mat_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_mat_model","text":"load_mat_model(file_name::String)\n\nLoad and return a MATLAB file file_name that contains a COBRA-compatible model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.save_mat_model-Tuple{MetabolicModel, String}","page":"Function reference","title":"COBREXA.save_mat_model","text":"save_mat_model(model::MetabolicModel, file_name::String; model_name::String=\"model\")\n\nSave a MATModel in model to a MATLAB file file_name in a format compatible with other MATLAB-based COBRA software.\n\nIn case the model is not MATModel, it will be converted automatically.\n\nmodel_name is the identifier name for the whole model written to the MATLAB file; defaults to just \"model\".\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.load_sbml_model-Tuple{String}","page":"Function reference","title":"COBREXA.load_sbml_model","text":"load_sbml_model(file_name::String)::SBMLModel\n\nLoad and return a SBML XML model in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Pretty-printing","page":"Function reference","title":"Pretty printing","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", \"show\", file), readdir(\"../src/io/show\"))","category":"page"},{"location":"functions/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, MetabolicModel}","page":"Function reference","title":"Base.show","text":"Pretty printing of everything metabolic-modelish.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_substances-Tuple{Vector{String}}","page":"Function reference","title":"COBREXA._pretty_substances","text":"_pretty_substances(ss::Vector{String})::String\n\nNicely format a substance list.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.show-Union{Tuple{M}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Serialized{M}}} where M","page":"Function reference","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", m::Serialized{M}) where {M}\n\nShow the Serialized model without unnecessarily loading it.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Any}","page":"Function reference","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(io, def::String, payload; kwargs...)\n\nNicely prints keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Dict}","page":"Function reference","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(\n    io,\n    def::String,\n    payload::Dict\n)\n\nSpecialization of _pretty_print_keyvals for dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._pretty_print_keyvals-Tuple{Any, String, String}","page":"Function reference","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(\n    io,\n    def::String,\n    payload::String\n)\n\nSpecialization of _pretty_print_keyvals for plain strings.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Model-reconstruction","page":"Function reference","title":"Model reconstruction","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"reconstruction\", file), readdir(\"../src/reconstruction\"))","category":"page"},{"location":"functions/#COBREXA.add_reaction!-Tuple{CoreModel, Reaction}","page":"Function reference","title":"COBREXA.add_reaction!","text":"add_reaction!(model::CoreModel, rxn::Reaction)\n\nAdd rxn to model. The model must already contain the metabolites used by rxn in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions!-Tuple{CoreModel, Vector{Reaction}}","page":"Function reference","title":"COBREXA.add_reactions!","text":"add_reactions!(model::CoreModel, rxns::Vector{Reaction})\n\nAdd rxns to model efficiently. The model must already contain the metabolites used by rxns in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Tuple{CoreModel, CoreModel}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(m1::CoreModel, m2::CoreModel; check_consistency = false)\n\nAdd all reactions from m2 to m1.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V2}, Tuple{V1}, Tuple{CoreModel, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat, String, K}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    s::V1,\n    b::V2,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat,\n    rxn::String,\n    mets::K;\n    check_consistency = false,\n) where {V1<:VecType,V2<:VecType,K<:StringVecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V}, Tuple{M}, Tuple{CoreModel, M, V, V, V, V, K, K}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::V,\n    xu::V,\n    rxns::K,\n    mets::K;\n    check_consistency = false,\n) where {M<:MatType,V<:VecType,K<:StringVecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{V2}, Tuple{V1}, Tuple{CoreModel, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    s::V1,\n    b::V2,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat;\n    check_consistency = false,\n) where {V1<:VecType,V2<:VecType}\n\nAdd reaction(s) to a CoreModel model m.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{V}, Tuple{M}, Tuple{CoreModel, M, V, V, V, V}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::V,\n    xu::V;\n    check_consistency = false,\n) where {M<:MatType,V<:VecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.verify_consistency-Union{Tuple{K}, Tuple{V}, Tuple{M}, Tuple{CoreModel, M, V, V, V, V, K, K, Any, Any}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Function reference","title":"COBREXA.verify_consistency","text":"verify_consistency(\n    m::CoreModel,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::V,\n    xu::V,\n    names::K,\n    mets::K,\n    new_reactions,\n    new_metabolites,\n) where {M<:MatType,V<:VecType,K<:StringVecType}\n\nCheck the consistency of given reactions with existing reactions in m.\n\nTODO: work in progress, doesn't return consistency status.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_coupling_constraints!-Tuple{CoreModelCoupled, AbstractVector{Float64}, AbstractFloat, AbstractFloat}","page":"Function reference","title":"COBREXA.add_coupling_constraints!","text":"add_coupling_constraints!(\n    m::CoreModelCoupled,\n    c::VecType,\n    cl::AbstractFloat,\n    cu::AbstractFloat,\n)\n\nOverload for adding a single coupling constraint.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_coupling_constraints!-Union{Tuple{V}, Tuple{CoreModelCoupled, AbstractMatrix{Float64}, V, V}} where V<:AbstractVector{Float64}","page":"Function reference","title":"COBREXA.add_coupling_constraints!","text":"add_coupling_constraints!(\n    m::CoreModelCoupled,\n    C::MatType,\n    cl::V,\n    cu::V,\n) where {V<:VecType}\n\nIn-place add a single coupling constraint in form\n\n    cₗ ≤ C x ≤ cᵤ\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_coupling_constraints-Tuple{CoreModel, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.add_coupling_constraints","text":"add_coupling_constraints(m::CoreModel, args...)\n\nAdd coupling constraints to a plain CoreModel (returns a CoreModelCoupled).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_coupling_constraints-Tuple{CoreModelCoupled, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.add_coupling_constraints","text":"Add constraints of the following form to a CoreModelCoupled and return a modified one.\n\nAdd constraints to a CoreModelCoupled and return a modified one.\n\nThe arguments are same as for in-place add_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Tuple{CoreModelCoupled, CoreModel}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(m1::CoreModelCoupled, m2::CoreModel; check_consistency = false)\n\nAdd all reactions from m2 to m1.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V2}, Tuple{V1}, Tuple{CoreModelCoupled, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat, String, K}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    s::V1,\n    b::V2,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat,\n    rxn::String,\n    mets::K;\n    check_consistency = false,\n) where {V1<:VecType,V2<:VecType,K<:StringVecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V}, Tuple{M}, Tuple{CoreModelCoupled, M, V, V, V, V, K, K}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::V,\n    xu::V,\n    rxns::K,\n    mets::K;\n    check_consistency = false,\n) where {M<:MatType,V<:VecType,K<:StringVecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{V2}, Tuple{V1}, Tuple{CoreModelCoupled, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    s::V1,\n    b::V2,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat;\n    check_consistency = false,\n) where {V1<:VecType,V2<:VecType}\n\nAdd reaction(s) to a CoreModelCoupled model m.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions-Union{Tuple{V}, Tuple{M}, Tuple{CoreModelCoupled, M, V, V, V, V}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}}","page":"Function reference","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::V,\n    xu::V;\n    check_consistency = false,\n) where {M<:MatType,V<:VecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_coupling_bounds!-Union{Tuple{V}, Tuple{CoreModelCoupled, Vector{Int64}}} where V<:AbstractVector{Float64}","page":"Function reference","title":"COBREXA.change_coupling_bounds!","text":"change_coupling_bounds!(\n    model::CoreModelCoupled,\n    constraints::Vector{Int};\n    cl::V = Float64[],\n    cu::V = Float64[],\n) where {V<:VecType}\n\nChange the lower and/or upper bounds (cl and cu) for the given list of coupling constraints.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_coupling_constraints!-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.remove_coupling_constraints!","text":"remove_coupling_constraints!(m::CoreModelCoupled, constraint::Int)\n\nRemoves a single coupling constraints from a CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_coupling_constraints!-Tuple{CoreModelCoupled, Vector{Int64}}","page":"Function reference","title":"COBREXA.remove_coupling_constraints!","text":"remove_coupling_constraints!(m::CoreModelCoupled, constraints::Vector{Int})\n\nRemoves a set of coupling constraints from a CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_coupling_constraints-Tuple{CoreModelCoupled, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.remove_coupling_constraints","text":"remove_coupling_constraints(m::CoreModelCoupled, args...)\n\nRemove coupling constraints from the linear model, and return the modified model. Arguments are the same as for in-place version remove_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.:←-Tuple{Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}, Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}}","page":"Function reference","title":"COBREXA.:←","text":"←(\n    substrates::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient},\n    },\n    products::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient}\n    },\n)\n\nMake a reverse-only Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.:→-Tuple{Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}, Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}}","page":"Function reference","title":"COBREXA.:→","text":"→(\n    substrates::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient},\n    },\n    products::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient}\n    },\n)\n\nMake a forward-only Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.:↔-Tuple{Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}, Union{Nothing, Metabolite, MetaboliteWithCoefficient, Vector{MetaboliteWithCoefficient}}}","page":"Function reference","title":"COBREXA.:↔","text":"↔(\n    substrates::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient},\n    },\n    products::Union{\n        Nothing,\n        Metabolite,\n        MetaboliteWithCoefficient,\n        Vector{MetaboliteWithCoefficient}\n    },\n)\n\nMake a bidirectional (reversible) Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_gene!-Tuple{StandardModel, Gene}","page":"Function reference","title":"COBREXA.add_gene!","text":"add_gene!(model::StandardModel, genes::Gene)\n\nAdd gene to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_genes!-Tuple{StandardModel, Vector{Gene}}","page":"Function reference","title":"COBREXA.add_genes!","text":"add_genes!(model::StandardModel, genes::Vector{Gene})\n\nAdd genes to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_metabolite!-Tuple{StandardModel, Metabolite}","page":"Function reference","title":"COBREXA.add_metabolite!","text":"add_metabolite!(model::StandardModel, met::Metabolite)\n\nAdd met to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_metabolites!-Tuple{StandardModel, Vector{Metabolite}}","page":"Function reference","title":"COBREXA.add_metabolites!","text":"add_metabolites!(model::StandardModel, mets::Vector{Metabolite})\n\nAdd mets to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reaction!-Tuple{StandardModel, Reaction}","page":"Function reference","title":"COBREXA.add_reaction!","text":"add_reaction!(model::StandardModel, rxn::Reaction)\n\nAdd rxn to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_reactions!-Tuple{StandardModel, Vector{Reaction}}","page":"Function reference","title":"COBREXA.add_reactions!","text":"add_reactions!(model::StandardModel, rxns::Vector{Reaction})\n\nAdd rxns to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_gene!-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_gene!","text":"remove_gene!(\n    model::StandardModel,\n    id::Vector{String};\n    knockout_reactions::Bool = false,\n)\n\nRemove gene with id from model. If knockout_reactions is true, then also constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_gene!(model, \"g1\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_genes!-Tuple{StandardModel, Vector{String}}","page":"Function reference","title":"COBREXA.remove_genes!","text":"remove_genes!(\n    model::StandardModel,\n    ids::Vector{String};\n    knockout_reactions::Bool = false,\n)\n\nRemove all genes with ids from model. If knockout_reactions is true, then also constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_genes!(model, [\"g1\", \"g2\"])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.@add_reactions!-Tuple{Symbol, Expr}","page":"Function reference","title":"COBREXA.@add_reactions!","text":"@add_reactions!(model::Symbol, ex::Expr)\n\nShortcut to add multiple reactions and their lower and upper bounds\n\nCall variants\n\n@add_reactions! model begin\n    reaction_name, reaction\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound, upper_bound\nend\n\nExamples\n\n@add_reactions! model begin\n    \"v1\", nothing → A, 0, 500\n    \"v2\", A ↔ B + C, -500\n    \"v3\", B + C → nothing\nend\n\n\n\n\n\n","category":"macro"},{"location":"functions/#COBREXA.add_model_with_exchanges-Tuple{CoreModel, MetabolicModel, Dict{String, String}}","page":"Function reference","title":"COBREXA.add_model_with_exchanges","text":"add_model_with_exchanges(\n    community::CoreModel,\n    model::MetabolicModel,\n    exchange_rxn_mets::Dict{String,String};\n    model_name = \"unknown_species\",\n    biomass_id = nothing,\n)::CoreModel\n\nAdd model to community, which is a pre-existing community model with exchange reactions and metabolites in the dictionary exchange_rxn_mets. The model_name is appended to each reaction and metabolite, see join_with_exchanges. If biomass_id is specified then a biomass metabolite for model is also added to the resulting model. The column corresponding to the biomass_id reaction then produces this new biomass metabolite with unit coefficient. Note, exchange_rxn_ids and exchange_met_ids must already exist in the community model.\n\nExample\n\ncommunity = add_model_with_exchanges(community,\n    model,\n    exchange_rxn_mets;\n    model_name=\"species_2\",\n    biomass_id=\"BIOMASS_Ecoli_core_w_GAM\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.add_objective!-Tuple{CoreModel, Vector{String}}","page":"Function reference","title":"COBREXA.add_objective!","text":"add_objective!(\n    community::CoreModel,\n    objective_mets::Vector{String};\n    objective_weights = Float64[],\n    objective_column_index = 0,\n)\n\nAdd an objective to the community model. Supply the string names of the objective metabolites in objective_mets. Optionally specify the weight to assign each metabolite in the objective function, if unassigned then equal weight is assumed. Also, optionally specify whether the objective already exists in the model by assigning objective_column_index. If unassigned then an objective column will be added, otherwise the column at objective_column_index will be updated.\n\nNote, the weights are negated inside the function so that the objective metabolites are seen as reagents/substrates, not products in the reaction equation.\n\nExample\n\nadd_objective!(model, [\"met1\", \"met2\"]) # adds a new column with weights = [1,1]\nadd_objective!(model, [\"met1\", \"met2\"]; objective_weights=[0.1, 0.9]) # adds a new column\nadd_objective!(model, [\"met1\", \"met2\"]; objective_weights=[0.1, 0.9], objective_column_index=10) # updates column 10\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.join_with_exchanges-Union{Tuple{M}, Tuple{Vector{M}, Dict{String, String}}} where M<:MetabolicModel","page":"Function reference","title":"COBREXA.join_with_exchanges","text":"join_with_exchanges(models::Vector{M},\n    exchange_rxn_mets::Dict{String, String};\n    biomass_ids::Vector{String},\n    model_names=String[]\n)\n\nReturn a CoreModel representing the community model of models joined through their exchange reactions and metabolites in the dictionary exchange_rxn_mets, which maps exchange reactions to their associated metabolite. These exchange reactions and metabolites link model metabolites to environmental metabolites and reactions. Optionally specify model_names to append a specific name to each reaction and metabolite of an organism for easier reference (default is species_i for each model index i in models). Note, the bounds of the environmental variables are all set to zero. Thus, to run a simulation you need to constrain them appropriately. All the other bounds are inherited from the models used to construct the community model.\n\nIf biomass_ids is supplied, then a community model is returned that has an extra reaction added to the end of the stoichiometric matrix (last column) that can be assigned as the objective reaction. It also creates biomass \"metabolites\" that can be used in this objective reaction. Note, this reaction is unspecified, further action needs to be taken to specify it, e.g. assign weights to the last column of the stoichiometric matrix in the rows corresponding to the biomass metabolites.\n\nTo further clarify how this join works. Suppose you have 2 organisms with stoichiometric matrices S₁ and S₂ and you want to link them with exchange_rxn_mets = Dict(er₁ => em₁, er₂ => em₂, er₃ => em₃, ...). Then a new community stoichiometric matrix is constructed that looks like this:\n\n            _      er₁  er₂  er₃  ...  b_\n           |S₁                           |\n           |   S₂                        |\n        em₁|                             |\nS   =   em₂|                             |\n        em₃|                             |\n        ...|                             |\n        bm₁|                             |\n        bm₂|_                           _|\n\n\nThe exchange reactions in each model get linked to environmental metabolites, emᵢ, and these get linked to environmental exchanges, erᵢ. These erᵢ behave like normal single organism exchange reactions. When biomass_ids are supplied, each model's biomass becomes a pseudo-metabolite (bmᵢ). These can be weighted in column b, called the community_biomass reaction in the community model, if desired. Refer to the tutorial if this is unclear.\n\nExample\n\nm1 = load_model(core_model_path)\nm2 = load_model(CoreModel, core_model_path)\n\n# need to list ALL the exchanges that will form part of the entire model\nexchange_rxn_mets = Dict(k => first(keys(reaction_stoichiometry(m1, ex_rxn)))\n    for filter(looks_like_exchange_reaction, reactions(m1)))\n\nbiomass_ids = [\"BIOMASS_Ecoli_core_w_GAM\", \"BIOMASS_Ecoli_core_w_GAM\"]\n\ncommunity = join_with_exchanges(\n    [m1, m2],\n    exchange_rxn_mets;\n    biomass_ids = biomass_ids,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Model-variant-specifications","page":"Function reference","title":"Model variant specifications","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"reconstruction\", \"modifications\", file), readdir(\"../src/reconstruction/modifications\"))","category":"page"},{"location":"functions/#COBREXA.with_added_reactions-Tuple","page":"Function reference","title":"COBREXA.with_added_reactions","text":"with_added_reactions(args...; kwargs...)\n\nSpecifies a model variant with reactions added. Forwards the arguments to add_reactions. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.with_changed_bound-Tuple","page":"Function reference","title":"COBREXA.with_changed_bound","text":"with_changed_bound(args...; kwargs...)\n\nSpecifies a model variant that has a new bound set. Forwards arguments to change_bound. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.with_changed_bounds-Tuple","page":"Function reference","title":"COBREXA.with_changed_bounds","text":"with_changed_bounds(args...; kwargs...)\n\nSpecifies a model variant that has new bounds set. Forwards arguments to change_bounds. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.with_removed_metabolite-Tuple","page":"Function reference","title":"COBREXA.with_removed_metabolite","text":"with_removed_metabolite(args...; kwargs...)\n\nSpecifies a model variant without a certain metabolite. Forwards arguments to remove_metabolite. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.with_removed_metabolites-Tuple","page":"Function reference","title":"COBREXA.with_removed_metabolites","text":"with_removed_metabolites(args...; kwargs...)\n\nPlural version of with_removed_metabolite, calls remove_metabolites internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.with_removed_reaction-Tuple","page":"Function reference","title":"COBREXA.with_removed_reaction","text":"with_removed_reaction(args...; kwargs...)\n\nSpecifies a model variant without a certain reaction. Forwards arguments to remove_reaction. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.with_removed_reactions-Tuple","page":"Function reference","title":"COBREXA.with_removed_reactions","text":"with_removed_reactions(args...; kwargs...)\n\nPlural version of with_removed_reaction, calls remove_reactions internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Analysis-functions","page":"Function reference","title":"Analysis functions","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", file), readdir(\"../src/analysis\"))","category":"page"},{"location":"functions/#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}","page":"Function reference","title":"COBREXA.envelope_lattice","text":"envelope_lattice(\n    model::MetabolicModel,\n    ridxs::Vector{Int};\n    samples = 10,\n    ranges = collect(zip(bounds(model)...))[ridxs],\n    reaction_samples = fill(samples, length(ridxs)),\n)\n\nCreate a lattice (list of \"tick\" vectors) for reactions at indexes ridxs in a model. Arguments samples, ranges, and reaction_samples may be optionally specified to customize the lattice creation process.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{String}}","page":"Function reference","title":"COBREXA.envelope_lattice","text":"envelope_lattice(model::MetabolicModel, rids::Vector{String}; kwargs...)\n\nVersion of envelope_lattice that works on string reaction IDs instead of integer indexes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Function reference","title":"COBREXA.objective_envelope","text":"objective_envelope(\n    model::MetabolicModel,\n    ridxs::Vector{Int},\n    optimizer;\n    lattice_args = (),\n    lattice = envelope_lattice(model, ridxs; lattice_args...),\n    kwargs...,\n)\n\nCompute an array of objective values for the model for rates of reactions specified ridxs fixed to a regular range of values between their respective lower and upper bounds.\n\nThis can be used to compute a \"production envelope\" of a metabolite; but generalizes to any specifiable objective and to multiple dimensions of the examined space. To retrieve a production envelope of any metabolite, set the objective coefficient vector of the model to a vector that contains a single 1 for the exchange reaction that \"outputs\" this metabolite, and run objective_envelope with the exchange reaction of the \"parameter\" metabolite specified in ridxs.\n\nReturns a named tuple that contains lattice with reference values of the metabolites, and an N-dimensional array values with the computed objective values, where N is the number of specified reactions.  Because of the increasing dimensionality, the computation gets very voluminous with increasing length of ridxs. The lattice for computing the optima can be supplied in the argument; by default it is created by envelope_lattice called on the model and reaction indexes. Additional arguments for the call to envelope_lattice can be optionally specified in lattice_args.\n\nkwargs are internally forwarded to screen_optmodel_modifications.\n\nExample\n\njulia> m = load_model(\"test/downloaded/e_coli_core.xml\");\n\njulia> envelope = objective_envelope(m, [\"R_EX_gln__L_e\", \"R_EX_fum_e\"],\n                                     Tulip.Optimizer;\n                                     lattice_args=(samples=6,));\n\njulia> envelope.lattice   # the reaction rates for which the optima were computed\n2-element Vector{Vector{Float64}}:\n [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]\n [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]\n\njulia> envelope.values   # the computed flux objective values for each reaction rate combination\n6×6 Matrix{Float64}:\n  0.873922   9.25815  17.4538  19.56   20.4121  20.4121\n 13.0354    17.508    19.9369  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{String}, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.objective_envelope","text":"objective_envelope(model::MetabolicModel, rids::Vector{String}, args...; kwargs...)\n\nVersion of objective_envelope that works on string reaction IDs instead of integer indexes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M<:MetabolicModel","page":"Function reference","title":"COBREXA.flux_balance_analysis","text":"flux_balance_analysis(\n    model::M,\n    optimizer;\n    modifications = [],\n) where {M<:MetabolicModel}\n\nRun flux balance analysis (FBA) on the model optionally specifying modifications to the problem.  Basically, FBA solves this optimization problem:\n\nmax cᵀx\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n\nSee \"Orth, J., Thiele, I. & Palsson, B. What is flux balance analysis?. Nat Biotechnol 28, 245-248 (2010). https://doi.org/10.1038/nbt.1614\" for more information.\n\nThe optimizer must be set to a JuMP-compatible optimizer, such as GLPK.Optimizer or Tulip.Optimizer\n\nOptionally, you may specify one or more modifications to be applied to the model before the analysis, such as change_optimizer_attribute, change_objective, and change_sense.\n\nReturns an optimized JuMP model.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nsolution = flux_balance_analysis(model, GLPK.optimizer)\nvalue.(solution[:x])  # extract flux steady state from the optimizer\n\nbiomass_reaction_id = findfirst(model.reactions, \"BIOMASS_Ecoli_core_w_GAM\")\n\nmodified_solution = flux_balance_analysis(model, GLPK.optimizer;\n    modifications=[change_objective(biomass_reaction_id)])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.flux_balance_analysis_dict","text":"flux_balance_analysis_dict(model::MetabolicModel, args...)::Union{Dict{String, Float64},Nothing}\n\nA variant of FBA that returns a dictionary assigning fluxes to reactions, if the solution is found. Arguments are passed to flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_balance_analysis_vec-Tuple","page":"Function reference","title":"COBREXA.flux_balance_analysis_vec","text":"flux_balance_analysis_vec(args...)::Union{Vector{Float64},Nothing}\n\nA variant of FBA that returns a vector of fluxes in the same order as reactions of the model, if the solution is found.\n\nArguments are passed to flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._max_variability_flux-Tuple{Any, Any, Any}","page":"Function reference","title":"COBREXA._max_variability_flux","text":"_max_variability_flux(opt_model, rid, ret)\n\nInternal helper for maximizing reactions in optimization model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(\n    model::MetabolicModel,\n    optimizer;\n    kwargs...\n)\n\nA simpler version of flux_variability_analysis that maximizes and minimizes all reactions in the model. Arguments are forwarded.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Function reference","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(\n    model::MetabolicModel,\n    reactions::Vector{Int},\n    optimizer;\n    modifications = [],\n    workers = [myid()],\n    bounds = z -> (z,z),\n    ret = objective_value,\n)::Matrix{Float64}\n\nFlux variability analysis solves a pair of optimization problems in model for each flux listed in reactions:\n\n min,max xᵢ\ns.t. S x = b\n    xₗ ≤ x ≤ xᵤ\n     cᵀx ≥ bounds(Z₀)[1]\n     cᵀx ≤ bounds(Z₀)[2]\n\nwhere Z₀:= cᵀx₀ is the objective value of an optimal solution of the associated FBA problem (see flux_balance_analysis for a related analysis, also for explanation of the modifications argument).\n\nThe bounds is a user-supplied function that specifies the objective bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in FBA. It can return -Inf and Inf in first and second pair to remove the limit. Use gamma_bounds and objective_bounds for simple bounds.\n\noptimizer must be set to a JuMP-compatible optimizer. The computation of the individual optimization problems is transparently distributed to workers (see Distributed.workers()).\n\nret is a function used to extract results from optimized JuMP models of the individual reactions. By default, it calls and returns the value of JuMP.objective_value. More information can be extracted e.g. by setting it to a function that returns a more elaborate data structure; such as m -> (JuMP.objective_value(m), JuMP.value.(m[:x])).\n\nReturns a matrix of extracted ret values for minima and maxima, of total size (length(reactions),2). The optimizer result status is checked with is_solved; nothing is returned if the optimization failed for any reason.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nflux_variability_analysis(model, [1, 2, 3, 42], GLPK.optimizer)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.flux_variability_analysis_dict-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.flux_variability_analysis_dict","text":"flux_variability_analysis_dict(\n    model::MetabolicModel,\n    optimizer;\n    kwargs...\n)\n\nA variant of flux_variability_analysis that returns the individual maximized and minimized fluxes of all reactions as two dictionaries (of dictionaries). All keyword arguments except ret are passed through.\n\nExample\n\nmins, maxs = flux_variability_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.99),\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"EX_glc__D_e\", -10, -10),\n        change_constraint(\"EX_o2_e\", 0.0, 0.0),\n    ],\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}","page":"Function reference","title":"COBREXA.parsimonious_flux_balance_analysis","text":"parsimonious_flux_balance_analysis(\n    model::MetabolicModel,\n    optimizer;\n    modifications = [],\n    qp_modifications = [],\n    relax_bounds=[1.0, 0.999999, 0.99999, 0.9999, 0.999, 0.99],\n)\n\nRun parsimonious flux balance analysis (pFBA) on the model. In short, pFBA runs two consecutive optimization problems. The first is traditional FBA:\n\nmax cᵀx = μ\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n\nAnd the second is a quadratic optimization problem:\n\nmin Σᵢ xᵢ²\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n     μ = μ⁰\n\nWhere the optimal solution of the FBA problem, μ⁰, has been added as an additional constraint. See \"Lewis, Nathan E, Hixson, Kim K, Conrad, Tom M, Lerman, Joshua A, Charusanti, Pep, Polpitiya, Ashoka D, Adkins, Joshua N, Schramm, Gunnar, Purvine, Samuel O, Lopez-Ferrer, Daniel, Weitz, Karl K, Eils, Roland, König, Rainer, Smith, Richard D, Palsson, Bernhard Ø, (2010) Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6. 390. doi: accession:10.1038/msb.2010.47\" for more details.\n\npFBA gets the model optimum by standard FBA (using flux_balance_analysis with optimizer and modifications), then finds a minimal total flux through the model that still satisfies the (slightly relaxed) optimum. This is done using a quadratic problem optimizer. If the original optimizer does not support quadratic optimization, it can be changed using the callback in qp_modifications, which are applied after the FBA. See the documentation of fluxbalanceanalysis for usage examples of modifications.\n\nThhe optimum relaxation sequence can be specified in relax parameter, it defaults to multiplicative range of [1.0, 0.999999, ..., 0.99] of the original bound.\n\nReturns an optimized model that contains the pFBA solution; or nothing if the optimization failed.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\noptmodel = parsimonious_flux_balance_analysis(model, biomass, Gurobi.Optimizer)\nvalue.(solution[:x])  # extract the flux from the optimizer\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.parsimonious_flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any, N} where N}","page":"Function reference","title":"COBREXA.parsimonious_flux_balance_analysis_dict","text":"parsimonious_flux_balance_analysis_dict(model::MetabolicModel, args...; kwargs...)\n\nPerform parsimonious flux balance analysis on model using optimizer. Returns a dictionary mapping the reaction IDs to fluxes. Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.parsimonious_flux_balance_analysis_vec-Tuple","page":"Function reference","title":"COBREXA.parsimonious_flux_balance_analysis_vec","text":"parsimonious_flux_balance_analysis_vec(args...; kwargs...)\n\nPerform parsimonious flux balance analysis on model using optimizer. Returns a vector of fluxes in the same order as the reactions in model. Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._check_screen_mods_args-Union{Tuple{N}, Tuple{A}, Tuple{V}, Tuple{Union{Nothing, Array{V, N}}, Union{Nothing, Array{A, N}}, Any}} where {V, A, N}","page":"Function reference","title":"COBREXA._check_screen_mods_args","text":"_check_screen_mods_args(mods, args, modsname)\n\nInternal helper to check the presence and shape of modification and argument arrays in screen and pals.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.screen-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{A}, Tuple{V}} where {V<:(AbstractVector{T} where T), A, N}","page":"Function reference","title":"COBREXA.screen","text":"function screen(\n    model::MetabolicModel;\n    variants::Maybe{Array{V,N}} = nothing,\n    analysis,\n    args::Maybe{Array{A,N}} = nothing,\n    workers = [myid()],\n)::Array where {V<:AbstractVector,A,N}\n\nTake an array of model-modifying function vectors in variants, and execute the function analysis on all variants of the model specified by variants. The computation is distributed over worker IDs in workers. If args are supplied (as an array of the same size as the variants), they are forwarded as arguments to the corresponding analysis function calls.\n\nThe array of variants must contain vectors of single-parameter functions, these are applied to model in order. The functions must not modify the model, but rather return a modified copy. The copy should be made as shallow as possible, to increase memory efficiency of the process. Variant generators that modify the argument model in-place will cause unpredictable results. Refer to the definition of screen_variant for details.\n\nThe function analysis will receive a single argument (the modified model), together with arguments from args expanded by .... Supply an array of tuples or vectors to pass in multiple arguments to each function. If the argument values should be left intact (not expanded to multiple arguments), they must be wrapped in single-item tuple or vector.\n\nThe modification and analysis functions are transferred to workers as-is; all packages required to run them (e.g. the optimization solvers) must be loaded there. Typically, you want to use the macro @everywhere using MyFavoriteSolver from Distributed package for loading the solvers.\n\nReturn value\n\nThe results of running analysis are collected in to the resulting array, in a way that preserves the shape of the variants, similarly as with pmap.\n\nThe results of analysis function must be serializable, preferably made only from pure Julia structures, because they may be transferred over the network between the computation nodes. For that reason, functions that return whole JuMP models that contain pointers to allocated C structures (such as flux_balance_analysis used with GLPK or Gurobi otimizers) will generally not in this context.\n\nExample\n\nfunction reverse_reaction(i::Int)\n    (model::CoreModel) -> begin\n        mod = copy(model)\n        mod.S[:,i] .*= -1   # this is unrealistic but sufficient for demonstration\n        mod\n    end\nend\n\nm = load_model(CoreModel, \"e_coli_core.xml\")\n\nscreen_variants(m,\n           [\n               [reverse_reaction(5)],\n               [reverse_reaction(3), reverse_reaction(6)]\n           ],\n           mod -> mod.S[:,3])  # observe the changes in S\n\nscreen_variants(m,\n    [\n        [reverse_reaction(5)],\n        [reverse_reaction(3), reverse_reaction(6)]\n    ],\n    mod -> flux_balance_analysis_vec(mod, GLPK.Optimizer))  # run analysis\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.screen_optimize_objective-Tuple{Any, Any}","page":"Function reference","title":"COBREXA.screen_optimize_objective","text":"screen_optimize_objective(_, optmodel)::Union{Float64,Nothing}\n\nA variant of optimize_objective directly usable in screen_optmodel_modifications.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.screen_optmodel_modifications-Union{Tuple{N}, Tuple{A}, Tuple{V}, Tuple{MetabolicModel, Any}} where {V<:(AbstractVector{T} where T), A, N}","page":"Function reference","title":"COBREXA.screen_optmodel_modifications","text":"function screen_optmodel_modifications(\n    model::MetabolicModel,\n    optimizer;\n    common_modifications::V,\n    modifications::Maybe{Array{V,N}} = nothing,\n    args::Maybe{Array{T,N}} = nothing,\n    analysis = screen_optimize_objective,\n    workers = [myid()],\n) where {V<:AbstractVector,T<:Tuple,N}\n\nScreen multiple modifications of the same optimization model.\n\nThis function is potentially more efficient than screen because it avoids making variants of the model structure and remaking of the optimization model. On the other hand, modification functions need to keep the optimization model in a recoverable state (one that leaves the model usable for the next modification), which limits the possible spectrum of modifications applied.\n\nInternally, model is distributed to workers and transformed into the optimization model using make_optimization_model. common_modifications are applied to the models at that point. Next, vectors of functions in modifications are consecutively applied, and the result of analysis function called on model are collected to an array of the same extent as modifications. Calls of analysis are optionally supplied with extra arguments from args expanded with ..., just like in screen.\n\nBoth the modification functions (in vectors) and the analysis function here have 2 base parameters (as opposed to 1 with screen): first is the model (carried through as-is), second is the prepared JuMP optimization model that may be modified and acted upon. As an example, you can use modification change_constraint and analysis screen_optimize_objective.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.screen_variant","page":"Function reference","title":"COBREXA.screen_variant","text":"screen_variant(model::MetabolicModel, variant::Vector, analysis, args = ())\n\nHelper function for screen that applies all single-argument functions in variant to the model (in order from \"first\" to \"last\"), and executes analysis on the result.\n\nCan be used to test model variants locally.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.screen_variants-Tuple{Any, Any, Any}","page":"Function reference","title":"COBREXA.screen_variants","text":"screen_variants(model, variants, analysis; workers=[myid()])\n\nA shortcut for screen that only works with model variants.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Analysis-modifications","page":"Function reference","title":"Analysis modifications","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"modifications\", file), readdir(\"../src/analysis/modifications\"))","category":"page"},{"location":"functions/#COBREXA.change_constraint-Tuple{String, Any, Any}","page":"Function reference","title":"COBREXA.change_constraint","text":"change_constraint(id::String, lb, ub)\n\nChange the lower and upper bounds (lb and ub respectively) of reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_objective-Tuple{Union{String, Vector{String}}}","page":"Function reference","title":"COBREXA.change_objective","text":"change_objective(new_objective::Union{String,Vector{String}}; weights=[], sense=MAX_SENSE)\n\nModification that changes the objective function used in a constraint based analysis function.  new_objective can be a single reaction identifier, or an array of reactions identifiers.\n\nOptionally, the objective can be weighted by a vector of weights, and a optimization sense can be set to either MAX_SENSE or MIN_SENSE.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.constrain_objective_value-Tuple{Any}","page":"Function reference","title":"COBREXA.constrain_objective_value","text":"constrain_objective_value(tolerance)\n\nLimit the objective value to tolerance-times the current objective value, as with objective_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._do_knockout-Tuple{MetabolicModel, Any, Vector{String}}","page":"Function reference","title":"COBREXA._do_knockout","text":"_do_knockout(model::MetabolicModel, opt_model)\n\nInternal helper for knockouts on generic MetabolicModels. This can be overloaded so that the knockouts may work differently (more efficiently) with other models.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.knockout-Tuple{String}","page":"Function reference","title":"COBREXA.knockout","text":"knockout(gene_id::String)\n\nA helper variant of knockout for a single gene.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.knockout-Tuple{Vector{String}}","page":"Function reference","title":"COBREXA.knockout","text":"knockout(gene_ids::Vector{String})\n\nA modification that zeroes the bounds of all reactions that would be knocked out by the specified genes (effectively disables the reactions).\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_optimizer-Tuple{Any}","page":"Function reference","title":"COBREXA.change_optimizer","text":"change_optimizer(optimizer)\n\nChange the JuMP optimizer used to run the optimization.\n\nThis may be used to try different approaches for reaching the optimum, and in problems that may require different optimizers for different parts, such as the parsimonious_flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_optimizer_attribute-Tuple{Any, Any}","page":"Function reference","title":"COBREXA.change_optimizer_attribute","text":"change_optimizer_attribute(attribute_key, value)\n\nChange a JuMP optimizer attribute. The attributes are optimizer-specific, refer to the JuMP documentation and the documentation of the specific optimizer for usable keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_sense-Tuple{Any}","page":"Function reference","title":"COBREXA.change_sense","text":"change_sense(objective_sense)\n\nChange the objective sense of optimization. Possible arguments are MOI.MAX_SENSE and MOI.MIN_SENSE.\n\nIf you want to change the objective and sense at the same time, use change_objective instead to do both at once.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.silence","page":"Function reference","title":"COBREXA.silence","text":"silence\n\nModification that disable all output from the JuMP optimizer (shortcut for set_silent from JuMP).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Flux-sampling","page":"Function reference","title":"Flux sampling","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"sampling\", file), readdir(\"../src/analysis/sampling\"))","category":"page"},{"location":"functions/#COBREXA._affine_hit_and_run_chain-NTuple{5, Any}","page":"Function reference","title":"COBREXA._affine_hit_and_run_chain","text":"_affine_hit_and_run_chain(warmup, lbs, ubs, iters, chain)\n\nInternal helper function for computing a single affine hit-and-run chain. The number of the chain is passed for possible future initialization of stable RNGs.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.affine_hit_and_run-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"Function reference","title":"COBREXA.affine_hit_and_run","text":"function affine_hit_and_run(\n    warmup_points::Matrix{Float64},\n    lbs::Vector{Float64},\n    ubs::Vector{Float64};\n    sample_iters = 100 .* (1:5),\n    workers = [myid()],\n    chains = length(workers),\n)\n\nRun a hit-and-run style sampling that starts from warmup_points and uses their affine combinations for generating the run directions to sample the space delimited by lbs and ubs.  The points that represent fluxes in warmup_points should be organized in columns, i.e. warmup_points[:,1] is the first warmup flux.\n\nThere are total chains of hit-and-run runs, each on a batch of size(warmup_points, 2) points. The runs are scheduled on workers, for good load balancing chains should be ideally much greater than length(workers).\n\nEach run continues for maximum(sample_iters) iterations; the numbers in sample_iters represent the iterations at which the whole \"current\" batch of points is collected for output. For example, sample_iters=[1,4,5] causes the process run for 5 iterations, returning the sample batch that was produced by 1st, 4th and last (5th) iteration.\n\nReturns a matrix of sampled fluxes (in columns), with all collected samples horizontally concatenated. The total number of samples (columns) will be size(warmup_points,2) * chains * length(sample_iters).\n\nExample\n\nusing COBREXA\nusing Tulip\n\nmodel = load_model(StandardModel, model_path)\n\nwarmup, lbs, ubs = warmup_from_variability(model, Tulip.Optimizer, 100)\nsamples = affine_hit_and_run(warmup, lbs, ubs, sample_iters = 1:3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.warmup_from_variability","page":"Function reference","title":"COBREXA.warmup_from_variability","text":"function warmup_from_variability(\n    model::MetabolicModel,\n    optimizer,\n    min_reactions::Vector{Int}=1:n_reactions(model),\n    max_reactions::Vector{Int}=1:n_reactions(model);\n    modifications = [],\n    workers::Vector{Int} = [myid()],\n)::Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}\n\nGenerate FVA-like warmup points for samplers, by minimizing and maximizing the specified reactions. The result is returned as a matrix, each point occupies as single column in the result.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.warmup_from_variability-Tuple{MetabolicModel, Any, Int64}","page":"Function reference","title":"COBREXA.warmup_from_variability","text":"warmup_from_variability(\n    model::MetabolicModel,\n    optimizer,\n    n_points::Int;\n    kwargs...\n)\n\nGenerates FVA-like warmup points for samplers, by selecting random points by minimizing and maximizing reactions. Can not return more than 2 times the number of reactions in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Miscellaneous-utilities","page":"Function reference","title":"Miscellaneous utilities","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"utils\", file), readdir(\"../src/base/utils\"))","category":"page"},{"location":"functions/#COBREXA.ambiguously_identified_items-Tuple{Dict{String, Dict{String, Set{String}}}}","page":"Function reference","title":"COBREXA.ambiguously_identified_items","text":"ambiguously_identified_items(\n    index::Dict{String,Dict{String,[String]}},\n)::Vector{String}\n\nFind items (genes, metabolites, ...) from the annotation index that are identified non-uniquely by at least one of their annotations.\n\nThis often indicates that the items are duplicate or miscategorized.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.annotation_index-Tuple{AbstractDict{String, V} where V}","page":"Function reference","title":"COBREXA.annotation_index","text":"annotation_index(\n    xs::AbstractDict{String};\n    annotations = _annotations,\n)::Dict{String,Dict{String,[String]}}\n\nExtract annotations from a dictionary of items xs and build an index that maps annotation \"kinds\" (e.g. \"PubChem\") to the mapping from the annotations (e.g.  \"COMPOUND_12345\") to item IDs that carry the annotations.\n\nFunction annotations is used to access the Annotations object in the dictionary values.\n\nThis is extremely useful for finding items by annotation data.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.check_duplicate_reaction-Tuple{Reaction, OrderedCollections.OrderedDict{String, Reaction}}","page":"Function reference","title":"COBREXA.check_duplicate_reaction","text":"check_duplicate_reaction(rxn::Reaction, rxns::Dict{String, Reaction}; only_metabolites=true)\n\nCheck if rxn already exists in rxns but has another id. If only_metabolites is true then only the metabolite ids are checked. Otherwise, compares metabolite ids and the absolute value of their stoichiometric coefficients to those of rxn. If rxn has the same reaction equation as another reaction in rxns, the return the id. Otherwise return nothing.\n\nSee also: reaction_mass_balanced\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.is_boundary-Tuple{Reaction}","page":"Function reference","title":"COBREXA.is_boundary","text":"is_boundary(reaction::Reaction)\n\nReturn true if reaction is a boundary reaction, otherwise return false. Checks if on boundary by inspecting the number of metabolites in reaction equation. Boundary reactions have only one metabolite, e.g. an exchange reaction, or a sink/demand reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_atom_balance-Tuple{StandardModel, Dict{String, Float64}}","page":"Function reference","title":"COBREXA.reaction_atom_balance","text":"reaction_atom_balance(model::StandardModel, rxn)\n\nReturns a dictionary mapping the stoichiometry of atoms through a single reaction. Uses the metabolite information in model to determine the mass balance. Accepts a reaction dictionary, a reaction string id or a Reaction as an argument for rxn.\n\nSee also: reaction_mass_balanced\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.reaction_mass_balanced-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.reaction_mass_balanced","text":"reaction_mass_balanced(model::StandardModel, rxn)\n\nChecks if rxn is atom balanced. Returns a boolean for whether the reaction is balanced, and the associated balance of atoms for convenience (useful if not balanced). Calls reaction_atom_balance internally.\n\nSee also: check_duplicate_reaction, reaction_atom_balance\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry_string-Tuple{Any}","page":"Function reference","title":"COBREXA.stoichiometry_string","text":"stoichiometry_string(rxn_dict::Dict{String, Float64}; format_id = x -> x)\n\nReturn the reaction equation as a string. The metabolite strings can be manipulated by setting format_id.\n\nExample\n\njulia> req = Dict(\"coa_c\" => -1, \"for_c\" => 1, \"accoa_c\" => 1, \"pyr_c\" => -1)\njulia> stoichiometry_string(req)\n\"coa_c + pyr_c = for_c + accoa_c\"\n\njulia> stoichiometry_string(req; format_id = x -> x[1:end-2])\n\"coa + pyr = for + accoa\"\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.stoichiometry_string-Tuple{Reaction}","page":"Function reference","title":"COBREXA.stoichiometry_string","text":"stoichiometry_string(rxn::Reaction; kwargs)\n\nAlternative of stoichiometry_string take takes a Reaction as an argument.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.serialize_model-Tuple{Serialized, String}","page":"Function reference","title":"COBREXA.serialize_model","text":"serialize_model(model::Serialized, filename::String)::Serialized\n\nSpecialization of serialize_model that prevents nested serialization of already-serialized models.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.serialize_model-Union{Tuple{MM}, Tuple{MM, String}} where MM<:MetabolicModel","page":"Function reference","title":"COBREXA.serialize_model","text":"serialize_model(model::MM, filename::String)::Serialized{MM} where {MM<:MetabolicModel}\n\nSerialize the model to file filename, returning a Serialized model that is able to load itself back automatically upon precaching by precache!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{Gene}","page":"Function reference","title":"Base.copy","text":"Base.copy(g::Gene)\n\nShallow copy of a Gene\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{Metabolite}","page":"Function reference","title":"Base.copy","text":"Base.copy(m::Metabolite)\n\nShallow copy of a Metabolite\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{Reaction}","page":"Function reference","title":"Base.copy","text":"Base.copy(r::Reaction)\n\nShallow copy of a Reaction\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{StandardModel}","page":"Function reference","title":"Base.copy","text":"Base.copy(m::StandardModel)\n\nShallow copy of a StandardModel\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.gamma_bounds-Tuple{Any}","page":"Function reference","title":"COBREXA.gamma_bounds","text":"gamma_bounds(gamma)\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to be at least gamma*Z₀, as usual in COBRA packages. Use as the bounds argument:\n\nflux_variability_analysis(model, some_optimizer; bounds = gamma_bounds(0.9))\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.objective_bounds-Tuple{Any}","page":"Function reference","title":"COBREXA.objective_bounds","text":"objective_bounds(tolerance)\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to a small multiple of Z₀. Use as bounds argument, similarly to gamma_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._parse_formula-Tuple{String}","page":"Function reference","title":"COBREXA._parse_formula","text":"_parse_formula(f::String)::MetaboliteFormula\n\nParse a formula in format C2H6O into a MetaboliteFormula, which is basically a dictionary of atom counts in the molecule.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._unparse_formula-Tuple{Dict{String, Int64}}","page":"Function reference","title":"COBREXA._unparse_formula","text":"_unparse_formula(f::MetaboliteFormula)::String\n\nFormat MetaboliteFormula to String.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.atom_fluxes-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Function reference","title":"COBREXA.atom_fluxes","text":"atom_fluxes(model::MetabolicModel, reaction_fluxes::Dict{String, Float64})\n\nReturn a dictionary mapping the flux of atoms across a flux solution given by reaction_fluxes using the reactions in model to determine the appropriate stoichiometry.\n\nNote, this function ignores metabolites with no formula assigned to them, no error message will be displayed.\n\nNote, if a model is mass balanced there should be not net flux of any atom. By removing reactions from the flux_solution you can investigate how that impacts the mass balances.\n\nExample\n\n# Find flux of Carbon through all metabolic reactions except the biomass reaction\ndelete!(fluxes, \"BIOMASS_Ecoli_core_w_GAM\")\natom_fluxes(model, fluxes)[\"C\"]\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.metabolite_fluxes-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Function reference","title":"COBREXA.metabolite_fluxes","text":"metabolite_fluxes(model::MetabolicModel, flux_dict::Dict{String, Float64})\n\nReturn two dictionaries of metabolite ids mapped to reactions that consume or produce them, given the flux distribution supplied in flux_dict.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._parse_grr-Tuple{SBML.GeneProductAssociation}","page":"Function reference","title":"COBREXA._parse_grr","text":"_parse_grr(gpa::SBML.GeneProductAssociation)::GeneAssociation\n\nParse SBML.GeneProductAssociation structure to the simpler GeneAssociation. The input must be (implicitly) in a positive DNF.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._parse_grr-Tuple{String}","page":"Function reference","title":"COBREXA._parse_grr","text":"_parse_grr(s::String)::GeneAssociation\n\nParse a DNF gene association rule in format (YIL010W and YLR043C) or (YIL010W and YGR209C) to GeneAssociation. Also acceptsOR,|,||,AND,&, and&&`.\n\nExample\n\njulia> _parse_grr(\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\")\n2-element Array{Array{String,1},1}:\n [\"YIL010W\", \"YLR043C\"]\n [\"YIL010W\", \"YGR209C\"]\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._unparse_grr-Tuple{Type{SBML.GeneProductAssociation}, Vector{Vector{String}}}","page":"Function reference","title":"COBREXA._unparse_grr","text":"_unparse_grr(\n    ::Type{SBML.GeneProductAssociation},\n    x::GeneAssociation,\n)::SBML.GeneAssociation\n\nConvert a GeneAssociation to the corresponding SBML.jl structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._unparse_grr-Tuple{Type{String}, Vector{Vector{String}}}","page":"Function reference","title":"COBREXA._unparse_grr","text":"unparse_grr(grr::Vector{Vector{Gene}}\n\nConverts a nested string gene reaction array  back into a gene reaction rule string.\n\nExample\n\njulia> _unparse_grr(String, [[\"YIL010W\", \"YLR043C\"], [\"YIL010W\", \"YGR209C\"]])\n\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\"\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA._guesskey-Tuple{Any, Any}","page":"Function reference","title":"COBREXA._guesskey","text":"_guesskey(ks, possibilities)\n\nUnfortunately, many model types that contain dictionares do not have standardized field names, so we need to try a few possibilities and guess the best one. The keys used to look for valid field names should be ideally specified as constants in src/base/constants.jl.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_biomass_reaction_ids-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.find_biomass_reaction_ids","text":"find_biomass_reaction_ids(m::MetabolicModel; kwargs...)\n\nShortcut for finding biomass reaction identifiers in a model; arguments are forwarded to looks_like_biomass_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_biomass_reactions-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.find_biomass_reactions","text":"find_biomass_reactions(m::MetabolicModel; kwargs...)\n\nShortcut for finding biomass reaction indexes in a model; arguments are forwarded to looks_like_biomass_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_exchange_metabolite_ids-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.find_exchange_metabolite_ids","text":"find_exchange_metabolite_ids(m::MetabolicModel; kwargs...)\n\nShortcut for finding exchange metabolite identifiers in a model; arguments are forwarded to looks_like_exchange_metabolite.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_exchange_metabolites-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.find_exchange_metabolites","text":"find_exchange_metabolites(m::MetabolicModel; kwargs...)\n\nShortcut for finding exchange metabolite indexes in a model; arguments are forwarded to looks_like_exchange_metabolite.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_exchange_reaction_ids-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.find_exchange_reaction_ids","text":"find_exchange_reaction_ids(m::MetabolicModel; kwargs...)\n\nShortcut for finding exchange reaction identifiers in a model; arguments are forwarded to looks_like_exchange_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.find_exchange_reactions-Tuple{MetabolicModel}","page":"Function reference","title":"COBREXA.find_exchange_reactions","text":"find_exchange_reactions(m::MetabolicModel; kwargs...)\n\nShortcut for finding exchange reaction indexes in a model; arguments are forwarded to looks_like_exchange_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.looks_like_biomass_reaction-Tuple{String}","page":"Function reference","title":"COBREXA.looks_like_biomass_reaction","text":"looks_like_biomass_reaction(rxn_id::String;\n    exclude_exchanges = false,\n    exchange_prefixes = _constants.exchange_prefixes,\n    biomass_strings = _constants.biomass_strings,\n)::Bool\n\nA predicate that matches reaction identifiers that look like biomass reactions. Biomass reactions are identified by looking for occurences of biomass_strings in the reaction id. If exclude_exchanges is set, the strings that look like exchanges (from looks_like_exchange_reaction) will not match.\n\nExample\n\nfilter(looks_like_biomass_reaction, reactions(model)) # returns strings\nfindall(looks_like_biomass_reaction, reactions(model)) # returns indices\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.looks_like_exchange_metabolite-Tuple{String}","page":"Function reference","title":"COBREXA.looks_like_exchange_metabolite","text":"looks_like_exchange_metabolite(rxn_id::String;\n    exchange_suffixes = _constants.exchange_suffixes,\n    )::Bool\n\nA predicate that matches metabolite identifiers that look like involved in exchange reactions. Exchange metabolites are identified by exchange_suffixes at the end of the metabolite id.\n\nExample\n\nfilter(looks_like_exchange_metabolite, metabolites(model)) # returns strings\nfindall(looks_like_exchange_metabolite, metabolites(model)) # returns indices\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.looks_like_exchange_reaction-Tuple{String}","page":"Function reference","title":"COBREXA.looks_like_exchange_reaction","text":"looks_like_exchange_reaction(rxn_id::String;\n    exclude_biomass = false,\n    biomass_strings = _constants.biomass_strings,\n    exchange_prefixes = _constants.exchange_prefixes,\n)\n\nA predicate that matches reaction identifiers that look like exchange or biomass reactions, given the usual naming schemes in common model repositories. Exchange reactions are identified based on matching prefixes in the set exchange_prefixes and biomass reactions are identified by looking for occurences of biomass_strings in the reaction id.\n\nAlso see find_exchange_reactions.\n\nExample\n\nfindall(looks_like_exchange_reaction, reactions(model)) # returns indices\nfilter(looks_like_exchange_reaction, reactions(model)) # returns Strings\n\n# to use the optional arguments you need to expand the function's arguments\n# using an anonymous function\nfindall(x -> looks_like_exchange_reaction(x; exclude_biomass=true), reactions(model)) # returns indices\nfilter(x -> looks_like_exchange_reaction(x; exclude_biomass=true), reactions(model)) # returns Strings\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"macros\", file), readdir(\"../src/base/macros\"))","category":"page"},{"location":"functions/#COBREXA.change_bound!-Tuple{CoreModel, Int64}","page":"Function reference","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModel,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound!-Tuple{CoreModel, String}","page":"Function reference","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound!-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModelCoupled,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound!-Tuple{CoreModelCoupled, String}","page":"Function reference","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModelCoupled,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound!-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::StandardModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound-Tuple{CoreModel, Int64}","page":"Function reference","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModel,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound-Tuple{CoreModel, String}","page":"Function reference","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModelCoupled,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound-Tuple{CoreModelCoupled, String}","page":"Function reference","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModelCoupled,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bound-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.change_bound","text":"change_bound(\n    model::StandardModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModel,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds!-Tuple{CoreModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds!-Tuple{CoreModelCoupled, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModelCoupled,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds!-Tuple{CoreModelCoupled, AbstractVector{String}}","page":"Function reference","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModelCoupled,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds!-Tuple{StandardModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::StandardModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds-Tuple{CoreModel, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModel,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds-Tuple{CoreModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds-Tuple{CoreModelCoupled, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModelCoupled,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds-Tuple{CoreModelCoupled, AbstractVector{String}}","page":"Function reference","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModelCoupled,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.change_bounds-Tuple{StandardModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::StandardModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite!-Tuple{CoreModel, Int64}","page":"Function reference","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModel, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite!-Tuple{CoreModel, String}","page":"Function reference","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModel, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite!-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModelCoupled, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite!-Tuple{CoreModelCoupled, String}","page":"Function reference","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModelCoupled, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite!-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::StandardModel, metabolite_id::String)\n\nRemove metabolite from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite-Tuple{CoreModel, Int64}","page":"Function reference","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModel, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite-Tuple{CoreModel, String}","page":"Function reference","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModel, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModelCoupled, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite-Tuple{CoreModelCoupled, String}","page":"Function reference","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModelCoupled, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolite-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::StandardModel, metabolite_id::String)\n\nRemove metabolite from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModel, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites!-Tuple{CoreModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites!-Tuple{CoreModelCoupled, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModelCoupled, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites!-Tuple{CoreModelCoupled, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModelCoupled, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites!-Tuple{StandardModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::StandardModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites-Tuple{CoreModel, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModel, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites-Tuple{CoreModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites-Tuple{CoreModelCoupled, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModelCoupled, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites-Tuple{CoreModelCoupled, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModelCoupled, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_metabolites-Tuple{StandardModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::StandardModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction!-Tuple{CoreModel, Int64}","page":"Function reference","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModel, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction!-Tuple{CoreModel, String}","page":"Function reference","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModel, reaction_id::String)\n\nRemove reaction from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction!-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModelCoupled, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction!-Tuple{CoreModelCoupled, String}","page":"Function reference","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModelCoupled, reaction_id::String)\n\nRemove reaction from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction!-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::StandardModel, reaction_id::String)\n\nRemove reaction from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction-Tuple{CoreModel, Int64}","page":"Function reference","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModel, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction-Tuple{CoreModel, String}","page":"Function reference","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModel, reaction_id::String)\n\nRemove reaction from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction-Tuple{CoreModelCoupled, Int64}","page":"Function reference","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModelCoupled, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction-Tuple{CoreModelCoupled, String}","page":"Function reference","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModelCoupled, reaction_id::String)\n\nRemove reaction from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reaction-Tuple{StandardModel, String}","page":"Function reference","title":"COBREXA.remove_reaction","text":"remove_reaction(model::StandardModel, reaction_id::String)\n\nRemove reaction from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModel, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions!-Tuple{CoreModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions!-Tuple{CoreModelCoupled, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModelCoupled, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions!-Tuple{CoreModelCoupled, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModelCoupled, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModelCoupled in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions!-Tuple{StandardModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::StandardModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions-Tuple{CoreModel, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModel, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions-Tuple{CoreModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions-Tuple{CoreModelCoupled, AbstractVector{Int64}}","page":"Function reference","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModelCoupled, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions-Tuple{CoreModelCoupled, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModelCoupled, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModelCoupled and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#COBREXA.remove_reactions-Tuple{StandardModel, AbstractVector{String}}","page":"Function reference","title":"COBREXA.remove_reactions","text":"remove_reactions(model::StandardModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Logging-and-debugging-helpers","page":"Function reference","title":"Logging and debugging helpers","text":"","category":"section"},{"location":"functions/","page":"Function reference","title":"Function reference","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"logging\", file), readdir(\"../src/base/logging\"))","category":"page"},{"location":"functions/#COBREXA.log_io","page":"Function reference","title":"COBREXA.log_io","text":"log_io(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of messages and warnings from model input/output.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.log_models","page":"Function reference","title":"COBREXA.log_models","text":"log_models(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of model-related messages.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.log_perf","page":"Function reference","title":"COBREXA.log_perf","text":"log_perf(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of performance-related tracing information.\n\n\n\n\n\n","category":"function"},{"location":"functions/#COBREXA.@_make_logging_tag-Tuple{Symbol, String}","page":"Function reference","title":"COBREXA.@_make_logging_tag","text":"macro _make_logging_group(sym::Symbol, doc::String)\n\nThis creates a group of functions that allow masking out topic-related logging actions. A call that goes as follows:\n\n@_make_logging_tag XYZ\n\ncreates the following tools:\n\nglobal variable _XYZ_log_enabled defaulted to false\nfunction log_XYZ that can be called to turn the logging on/off\na masking macro @_XYZ_log that can be prepended to commands that should only happen if the logging of tag XYZ is enabled.\n\nThe masking macro is then used as follows:\n\n@_XYZ_log @info \"This is the extra verbose information you wanted!\" a b c\n\nThe user can direct logging with these:\n\nlog_XYZ()\nlog_XYZ(false)\n\ndoc should be a name of the stuff that is being printed if the corresponding log_XYZ() is enabled – it is used to create a friendly documentation for the logging switch. In this case it could say \"X, Y and Z-related messages\".\n\n\n\n\n\n","category":"macro"},{"location":"advanced/#COBREXA-Advanced-tutorials","page":"Advanced tutorials","title":"COBREXA Advanced tutorials","text":"","category":"section"},{"location":"advanced/","page":"Advanced tutorials","title":"Advanced tutorials","text":"Pages = joinpath.(\"advanced\", filter(x -> endswith(x, \".md\"), readdir(\"advanced\")))\nDepth = 2","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/4_basic_core_coupled_usage.jl\"","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Basic-usage-of-CoreModel-and-CoreModelCoupled","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"In this tutorial we will introduce COBREXA's CoreModel and CoreModelCoupled. We will use E. coli's toy model to start with.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Loading-a-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Loading a CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"model = load_model(CoreModel, \"e_coli_core.xml\") # we specifically want to load a CoreModel from the model file","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Basic-analysis-on-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic analysis on CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"As before, for optimization based analysis we need to load an optimizer. Here we will use Tulip.jl to optimize the linear programs of this tutorial. Refer to the constraint-based analysis basics tutorial if you are confused by any functions in this section.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"All the normal analysis functions work on CoreModel, due to it also having the same generic accessor interface as all the other model types.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"using Tulip\n\ndict_sol = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"),\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n        change_constraint(\"R_EX_o2_e\", 0, 0),\n    ],\n)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Structure-of-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Structure of CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"CoreModel is a special COBREXA type that is optimized for large scale analysis of large models. It stores data in a sparse format where possible.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"fieldnames(CoreModel)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"model.S","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#CoreModelCoupled-adds-coupling-constraints-to-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"CoreModelCoupled adds coupling constraints to CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"CoreModelCoupled extends CoreModel by adding coupling constraints.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"fieldnames(CoreModelCoupled)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"In short, coupling constraints can be used to ensure that fluxes scale with the growth rate (μ) of a model. This reduces the impact of biologically infeasible cycles from occurring. Here we will model coupling constraints by assuming that they have the form: -γ ≤ vᵢ/μ  ≤ γ, where γ is the ratio between each individual flux (vᵢ) in the model and the growth rate.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"gamma = 40 # arbitrary\n\nnr = n_reactions(model) # number of reactions\nbiomass_index = first(indexin([\"R_BIOMASS_Ecoli_core_w_GAM\"], reactions(model)))\n\nusing LinearAlgebra, SparseArrays\n\nCf = sparse(1.0I, nr, nr)\nCf[:, biomass_index] .= -gamma\nCb = sparse(1.0I, nr, nr)\nCb[:, biomass_index] .= gamma\nC = [Cf; Cb] # coupling constraint matrix\n\nclb = spzeros(2 * nr)\nclb[1:nr] .= -1000.0\ncub = spzeros(2 * nr)\ncub[nr+1:end] .= 1000\n\ncmodel = CoreModelCoupled(model, C, clb, cub)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"d = flux_balance_analysis_dict(model, Tulip.Optimizer)\nd[\"R_BIOMASS_Ecoli_core_w_GAM\"]","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"dc = flux_balance_analysis_dict(cmodel, Tulip.Optimizer)\ndc[\"R_BIOMASS_Ecoli_core_w_GAM\"]","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/4_modifying/#Modifying-and-saving-the-models","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Making a small modification to the model and reanalyzing them is often a useful way to explore how the constraints work together, and to inspect the degrees of freedom in the model.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With COBREXA.jl, you have two main choices of making model modifications:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"you can manually change the model structures (i.e. permanently change the data in of your model variable)\nyou can use special arguments of analysis functions that allow you to make the modifications in a declarative way and \"on the fly\", without having to manually interact with the model","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"tip: Notebook available\nThe available notebooks demonstrate model export and serialization and various model modifications (1, 2, 3).","category":"page"},{"location":"tutorials/4_modifying/#Manual-modifications","page":"Modifying and saving the models","title":"Manual modifications","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Certain model types, including CoreModel and StandardModel, are built from mutable structs that you are free to modify as you want.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"CoreModel consists of sparse matrices and vectors that describe the model precisely. For example, modifying a bound of the reaction is as simple as writing to the .xl or .xu (lower and upper bound for x) vectors in the structure:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"using COBREXA\nm = load_model(CoreModel, \"e_coli_core.xml\")\nm.xl[3] = 0.0","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"The available field names can be listed using e.g. fieldnames(CoreModel), or more conveniently by employing the completion in the shell:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"julia> m.   # press [Tab]\nS    b     c     mets  rxns  xl    xu","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With CoreModel, you may need to find the proper metabolites by identifier. For that, you may examine the reactions and metabolites of the model, e.g. using","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"indexin([\"M_nadh_c\", \"M_co2_e\"], metabolites(m))","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...which will return the numeric indexes of NADH and CO₂ metabolites. These can be used to, e.g., change the \"balance\" of the metabolites in the model:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m.b[64] = -1      # model will be losing 1 flux unit of CO₂","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or to modify existing reaction (here with index 5) directly in stoichiometry matrix:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m.S[5,8] = -1\nm.S[5,64] = 1","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"While this works well if you are used to working with matrix-like representations of the model, it is not really convenient if you want to change the reactions and models in an easy way. StandardModel is structured in a much more user-friendly way, which makes the manual modifications easier.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"In particular, StandardModel consists of dictionaries of Reaction, Metabolite and Gene objects that may be modified and indexed directly using their names. That way, the above modifications may be written in a cleaner, semantic and declarative fashion, as follows:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = load_model(StandardModel, \"e_coli_core.xml\")\nm.reactions[\"R_TPI\"].lb = 0.0                         # change lower bound of the reaction to 0\nm.reactions[\"R_GLNS\"].metabolites[\"M_nadh_c\"] = -1.0  # update stoichiometry\nm.reactions[\"R_GLNS\"].metabolites[\"M_co2_e\"] = 1.0\n...","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"There are other functions that may be used to change the StandardModel in a more systematic way. See the documentation of add_reaction!, add_metabolite!, add_gene!, remove_reaction!, remove_metabolite!, [ remove_gene!, and the Model reconstruction reference for more examples.","category":"page"},{"location":"tutorials/4_modifying/#Analysis-modifiers","page":"Modifying and saving the models","title":"Analysis modifiers","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Some analysis functions, including flux_balance_analysis and flux_variability_analysis, accept a special argument modifications, which is a list of descriptions of small changes that should be applied to the model before modification.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"These include e.g.:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"change_objective that sets a new optimization objective\nchange_optimizer that chooses a different JuMP.jl optimizer for the analysis\nchange_optimizer_attribute that can set various optimizer parameters\nchange_constraint that changes the flux bounds of a reaction\nknockout that disables reactions that depend on genes","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"This way, you can easily check out the model state when maximizing the rate of \"TALA\" (transadenolase A) reaction:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = load_model(StandardModel, \"e_coli_core.xml\")\nflux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[change_objective(\"R_TALA\")])","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or knock out a gene combination that disables the transadenolase A completely (see m.reactions[\"R_TALA\"].grr):","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"flux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[knockout([\"G_b0008\", \"G_b2464\"])])","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or do both at once– knock out some other genes, and try to maximize the transadenolase A reaction rate:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"flux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[\n    knockout([\"G_s0001\"]),\n    change_objective(\"R_TALA\"),\n  ])","category":"page"},{"location":"tutorials/4_modifying/#Exporting-the-modified-models-in-native-formats","page":"Modifying and saving the models","title":"Exporting the modified models in native formats","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Manually modified models can be exported in standard formats so that they can be examined in other environments, or just made accessible for publication.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"COBREXA.jl supports export of MATLAB-like and JSON models. Simply use save_model:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"save_model(m, \"myModel.json\")\nsave_model(m, \"myModel.mat\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"The function automatically guesses the appropriate model format to write into the file from the file extension. If required, you can choose the model format manually by using save_json_model and save_mat_model.","category":"page"},{"location":"tutorials/4_modifying/#Using-Serialization-for-quick-and-efficient-model-storage","page":"Modifying and saving the models","title":"Using Serialization for quick & efficient model storage","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"If you save the model \"just for yourself\", such as for the use in an immediately following analysis, it may be inconvenient (and unnecessarily inefficient) to encode and decode the models to and from the external format. Moreover, certain model types (such as CoreModelCoupled) cannot be fully represented in all model formats, thus increasing the chance for accidental data loss.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Instead of that, we recommend using the Serialization package. It provides a straightforward way to save any Julia data structure to the disk, using a very efficient data format that can be written to and read from the disk very quickly.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With any model in m, you can write it to disk as follows:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"using Serialization\nopen(f -> serialize(f, m), \"myModel\", \"w\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...and read it back with:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = deserialize(\"myModel\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"One great advantage of Serialization is speed – models with millions of reactions are usually loaded and saved with minimal overhead in less than a second.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"warning: Limits of `Serialization`\nSerialized models are great for quickly exchanging data objects between analysis steps. The avoided need for re-encoding can save you a great deal of analysis time that can be used for better purposes. Despite that, do not rely on the stability of the serialized format – it often changes between Julia versions, and the data stored in one version may not open easily after an upgrade. In short, use serialized data within one workflow, and use standard and stable external formats for publishing and storing the data beyond the scope of a single analysis workflow.","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/7_community_model.jl\"","category":"page"},{"location":"notebooks/7_community_model/#Building-and-analysing-a-small-community-model","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Here we will use COBREXA to build and analyze a small community model consisting of three E. coli mutants using the CoreModel. We will use an objective function that enforces equal growth rates.","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"We will first construct a community of only two mutants to illustrate the effect of the community biomass objective function. Then we will add a third member that has a lethal knockout. Due to the bounds on the exchange reactions these three models are incapable of sharing resources - hence the maximum growth rate will be zero. By changing the bounds we can allow resource sharing, \"saving\" the community.","category":"page"},{"location":"notebooks/7_community_model/#Load-the-base-model","page":"Building and analysing a small community model","title":"Load the base model","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n\nusing COBREXA\nusing Tulip","category":"page"},{"location":"notebooks/7_community_model/#Load-the-models-and-inspect-fba-solutions","page":"Building and analysing a small community model","title":"Load the models and inspect fba solutions","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"base_model = load_model(CoreModel, \"e_coli_core.json\") # base from from which the knockouts will be constructed\n\ncytbd_knockout_model = remove_reaction(base_model, \"CYTBD\") # knockout the CYTBD (cytochrome oxidase) reaction\nsol = flux_balance_analysis_dict(cytbd_knockout_model, Tulip.Optimizer)\nsol[\"BIOMASS_Ecoli_core_w_GAM\"] # Cytochrome oxidase knockout μ (growth rate)","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"atps4r_knockout_model = remove_reaction(base_model, \"ATPS4r\") # knockout the ATP synthase reaction\nsol = flux_balance_analysis_dict(atps4r_knockout_model, Tulip.Optimizer)\nsol[\"BIOMASS_Ecoli_core_w_GAM\"] # ATP synthase knockout μ","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"eno_knockout_model = remove_reaction(base_model, \"ENO\") # knockout the enolase reaction\nsol = flux_balance_analysis_dict(eno_knockout_model, Tulip.Optimizer)\nsol[\"BIOMASS_Ecoli_core_w_GAM\"] # Enolase knockout μ, cannot grow by itself","category":"page"},{"location":"notebooks/7_community_model/#Build-a-community-model-of-the-cytochrome-oxidase-knockout-and-the-ATP-synthase-knockout-models","page":"Building and analysing a small community model","title":"Build a community model of the cytochrome oxidase knockout and the ATP synthase knockout models","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"ex_rxn_mets = Dict(\n    ex_rxn => first(keys(reaction_stoichiometry(base_model, ex_rxn))) for\n    ex_rxn in filter(looks_like_exchange_reaction, reactions(base_model))\n) # identify exchange reactions heuristically","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"model_names = [\"cytbd_ko\", \"atps4r_ko\"]\ncommunity_model = join_with_exchanges(\n    [cytbd_knockout_model, atps4r_knockout_model],\n    ex_rxn_mets;\n    biomass_ids = [\"BIOMASS_Ecoli_core_w_GAM\", \"BIOMASS_Ecoli_core_w_GAM\"],\n    model_names = model_names,\n)","category":"page"},{"location":"notebooks/7_community_model/#Set-exchange-reaction-bounds-of-community-model-based-on-the-bounds-of-the-individual-models","page":"Building and analysing a small community model","title":"Set exchange reaction bounds of community model based on the bounds of the individual models","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"env_ex_rxn_idxs = indexin(keys(ex_rxn_mets), reactions(community_model)) # identify the global (environmental exchange reactions)\ncytbd_ex_rxn_idxs = indexin(keys(ex_rxn_mets), reactions(cytbd_knockout_model)) # identify the indices of the corresponding exchange reactions in the original models\natps4r_ex_rxn_idxs = indexin(keys(ex_rxn_mets), reactions(atps4r_knockout_model))","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"In case some exchange reactions are not present in both models, set environmental exchange bound to the sum of the individual exchange bounds","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"for (env_ex, m2_ex, m1_ex) in zip(env_ex_rxn_idxs, cytbd_ex_rxn_idxs, atps4r_ex_rxn_idxs)\n    m2lb = isnothing(m2_ex) ? 0.0 : atps4r_knockout_model.xl[m2_ex]\n    m2ub = isnothing(m2_ex) ? 0.0 : atps4r_knockout_model.xu[m2_ex]\n    m1lb = isnothing(m1_ex) ? 0.0 : cytbd_knockout_model.xl[m1_ex]\n    m1ub = isnothing(m1_ex) ? 0.0 : cytbd_knockout_model.xu[m1_ex]\n    change_bounds!(community_model, [env_ex]; lower = [m1lb + m2lb], upper = [m1ub + m2ub])\nend","category":"page"},{"location":"notebooks/7_community_model/#Add-objective-function-to-community-model","page":"Building and analysing a small community model","title":"Add objective function to community model`","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"biomass_ids = model_names .* \"_BIOMASS_Ecoli_core_w_GAM\"\nadd_objective!(\n    community_model,\n    biomass_ids;\n    objective_column_index = first(\n        indexin([\"community_biomass\"], reactions(community_model)),\n    ),\n)","category":"page"},{"location":"notebooks/7_community_model/#Perform-community-FBA","page":"Building and analysing a small community model","title":"Perform community FBA","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"d = flux_balance_analysis_dict(\n    community_model,\n    Tulip.Optimizer;\n    modifications = [change_optimizer_attribute(\"IPM_IterationsLimit\", 1000)],\n)\nd[\"community_biomass\"] # community μ","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Notice, the growth rate is limited to the slowest organism as per the objective function","category":"page"},{"location":"notebooks/7_community_model/#Add-the-enolase-knockout-to-the-community-model","page":"Building and analysing a small community model","title":"Add the enolase knockout to the community model","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"community_model = add_model_with_exchanges(\n    community_model,\n    eno_knockout_model,\n    ex_rxn_mets;\n    model_name = \"eno_ko\",\n    biomass_id = \"BIOMASS_Ecoli_core_w_GAM\",\n)\n\npush!(model_names, \"eno_ko\")\nbiomass_ids = model_names .* \"_BIOMASS_Ecoli_core_w_GAM\"\nadd_objective!(\n    community_model,\n    biomass_ids;\n    objective_column_index = first(\n        indexin([\"community_biomass\"], reactions(community_model)),\n    ),\n)\n\nd = flux_balance_analysis_dict(\n    community_model,\n    Tulip.Optimizer;\n    modifications = [change_optimizer_attribute(\"IPM_IterationsLimit\", 1000)],\n)\nprintln(\"Community μ = \", d[\"community_biomass\"])","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Notice that the high communal growth rate is 0, due to the enolase knockout. The reason for this behaviour: enolase is a central reaction in glycolysis - without it the organism cannot access the lower glycolysis pathways or the TCA cycle, hence the model predicts no growth for the knockout, and hence no growth for the system since they all have to have the same growth rate.","category":"page"},{"location":"notebooks/7_community_model/#Allow-the-mutants-to-rescue-each-other-by-sharing-pyruvate","page":"Building and analysing a small community model","title":"Allow the mutants to rescue each other by sharing pyruvate","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"pyr_exs = model_names .* \"_EX_pyr_e\"\nchange_bounds!(community_model, pyr_exs; lower = fill(-1000.0, 3), upper = fill(1000.0, 3))\n\nd = flux_balance_analysis_dict(\n    community_model,\n    Tulip.Optimizer;\n    modifications = [change_optimizer_attribute(\"IPM_IterationsLimit\", 1000)],\n)\nd[\"community_biomass\"] # community μ","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Notice that the growth rate is now above 0! Nutrient sharing saved the day!","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/6_screening.jl\"","category":"page"},{"location":"notebooks/6_screening/#Exploring-model-variants-with-screen","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This notebooks demonstrates a simple use of screen to explore large number of model variants. On the toy E. Coli model, we try to map the impact of knocking out single reactions and 2-reaction combinations.","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"First, let's download the data and load the packages and the model","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n\nusing COBREXA, Tulip\n\nmodel = load_model(StandardModel, \"e_coli_core.json\")","category":"page"},{"location":"notebooks/6_screening/#Preparing-the-functions","page":"Exploring model variants with screen","title":"Preparing the functions","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"While we could use the with_changed_bound to limit the reaction rates, but we will make a slightly more precise, usage-tailored modification. This is a straightforward modification of the with_changed_bound that does not set bounds \"outside\" of the original bounds:","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"with_limited_rate(reaction_id::String, limit) =\n    model::StandardModel -> begin\n        m = copy(model)\n        m.reactions = copy(model.reactions)\n        r = m.reactions[reaction_id] = copy(model.reactions[reaction_id])\n        if -limit > r.lb\n            r.lb = -limit\n        end\n        if limit < r.ub\n            r.ub = limit\n        end\n        m\n    end","category":"page"},{"location":"notebooks/6_screening/#Knocking-out-single-reactions","page":"Exploring model variants with screen","title":"Knocking out single reactions","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This can be applied to see how much biomass can the model produce with certain reactions limited to almost zero:","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"get_biomass(x) = isnothing(x) ? 0 : x[\"BIOMASS_Ecoli_core_w_GAM\"]\n\nproductions = screen_variants(\n    model,\n    [[with_limited_rate(rxn, 0.1)] for rxn in reactions(model)],\n    model -> get_biomass(flux_balance_analysis_dict(model, Tulip.Optimizer)),\n)","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This can be nicely plotted to give a more comprehensive overview of which reactions are critical or not:","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"using CairoMakie\n\ndisp_rxns = rand(1:95, 20) # only display 20 random fluxes to save space\nbarplot(\n    productions[disp_rxns],\n    direction = :x,\n    axis = (\n        yticks = (1:20, reactions(model)[disp_rxns]),\n        xlabel = \"Flux [mmol/gDW/h]\",\n        ylabel = \"Reaction ID\",\n    ),\n)","category":"page"},{"location":"notebooks/6_screening/#Knocking-out-reaction-combinations","page":"Exploring model variants with screen","title":"Knocking out reaction combinations","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"It is very easy to prepare matrices of biomass productions from all possible two-reaction knockouts. To make it more interesting, we will restrict one of the reactions of the pair a bit less, to see more possible outcomes.","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"We do not process all reactions here to make the notebook rendering efficient, but you can easily remove the restriction, and speed the process up using parallel execution, by specifying workers argument (see documentation of screen for details)","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"rxns = reactions(model)\n\nproductions = screen_variants(\n    model,\n    [\n        [with_limited_rate(rxn1, 3), with_limited_rate(rxn2, 0.1)] for rxn1 in rxns,\n        rxn2 in rxns\n    ],\n    model -> get_biomass(flux_balance_analysis_dict(model, Tulip.Optimizer)),\n)\n\nf = Figure()\nax = Axis(\n    f[1, 1],\n    ylabel = \"Reaction KO\",\n    xlabel = \"Reaction KO\",\n    yticks = (1:20, reactions(model)[disp_rxns]),\n    xticks = (1:20, reactions(model)[disp_rxns]),\n    xticklabelrotation = -pi / 4,\n)\nhm = heatmap!(ax, productions[disp_rxns, disp_rxns])\nColorbar(f[1, 2], hm, label = \"Flux [mmol/gDW/h]\")\nf","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howToContribute/#Contributing-to-COBREXA.jl","page":"How to contribute","title":"Contributing to COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":":+1::tada: Thanks for taking the time to contribute to COBREXA.jl! :tada::+1:","category":"page"},{"location":"howToContribute/#How-to-report-a-bug-or-suggest-an-enhancement","page":"How to contribute","title":"How to report a bug or suggest an enhancement","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Please use the GitHub issue tracker to report any problems with the software, and discuss any potential questions about COBREXA use.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Before creating bug reports, please check the open issues, you might find out that the issue is already reported and known.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"General guidelines for reporting issues:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If creating a bug report, include a complete description of how we can reproduce the bug, including e.g. links to datasets and any external scripts used. Ideally, try to create a code snippet that causes the problem on a fresh installation of COBREXA.jl (often called the \"minimal crashing example\")\nIf possible, use the supplied issue templates and fill in all fields.\nIf your issue is already described in an issue that is \"closed\", do not reopen it. Instead, open a new issue and include a link to the original issue. (The fact that the original issue might have been mistakenly closed may be an issue on its own.)\nEnhancement proposals should refer a viable way for implementing the enhancement. If there are multiple possibilities for implementation, we will welcome a discussion about which one is optimal for COBREXA.jl.","category":"page"},{"location":"howToContribute/#How-to-test-a-development-version-of-the-package?","page":"How to contribute","title":"How to test a development version of the package?","text":"","category":"section"},{"location":"howToContribute/#Step-1:-Load-COBREXA.jl-from-the-source-from-the-git-repository","page":"How to contribute","title":"Step 1: Load COBREXA.jl from the source from the git repository","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"There are two ways that you can retrieve a local copy of the development repo: you can either clone the repository manually, or use Julia package manager to get a development version for you.","category":"page"},{"location":"howToContribute/#Option-1:-Using-Julia-package-manager","page":"How to contribute","title":"Option 1: Using Julia package manager","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When you are used to using the Julia package manager for developing or contributing to packages, you can type:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This will install the COBREXA package locally and check it out for development. You can check the location of the package with:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status\n    Status `~/.julia/environments/v1.4/Project.toml`\n  [a03a9c34] COBREXA v0.0.5 [`~/.julia/dev/COBREXA`]","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The default location of the package is ~/.julia/dev/COBREXA.","category":"page"},{"location":"howToContribute/#Option-2:-Cloning-with-git-manually","page":"How to contribute","title":"Option 2: Cloning with git manually","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You can use git to get the sources as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git clone git@github.com:LCSB-BioCore/COBREXA.jl.git","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the cloning process finishes, you shold see the package cloned in a new directory COBREXA.jl. To install this version to your Julia, change to the directory first, and start Julia:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd COBREXA.jl\n$ julia","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With Julia, you can install the development version of the package from the directory as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> add .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(press ] to get into the packaging environment)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This adds the COBREXA.jl package and all its dependencies. You can verify that the installation worked by typing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If you are planning to develop the package, it is often easier to install the package in development mode, with dev command:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"That causes the package to always load with whatever code changes that you added to the source directory.","category":"page"},{"location":"howToContribute/#Finally:-load-COBREXA.jl","page":"How to contribute","title":"Finally: load COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With both of above options, you should get COBREXA.jl installed, which means that the following command should, without errors, load the package and make COBREXA.jl functions available for testing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"julia> using COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You may now freely modify the code and test the result.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Remember that if you want to work in the environment of the package, you need to activate it. That causes, among other, that the additional dependencies specified with packaging add command will be written automaticaly to Project.toml file of your local COBREXA.jl clone, not to your global environment. Activation is simple: when in the directory of the package, just type the command into the packaging shell:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> activate","category":"page"},{"location":"howToContribute/#Step-2:-Publish-your-changes","page":"How to contribute","title":"Step 2: Publish your changes","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You are expected to make a fork of the main COBREXA.jl repository, and open a pull request from that one to the master branch of the main repository. For creating the fork, just hit the \"Fork\" button on GitHub.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After that, change the directory to your repository and adjust the remotes:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd ~/.julia/dev/COBREXA             # or any other directory, as needed\n$ git remote rename origin upstream   # renames the origin (the main COBREXA.jl repo) to upstream\n$ git remote add origin git@github.com:yourUsername/COBREXA.jl.git  # adds the link to your clone as new origin\n$ git fetch origin                    # fetches the refs from your repo","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"In the above code, change yourUsername is your GitHub username.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the renaming is done, start a new branch at upstream/master. In the code snippet, substitute yn for your initials (Your Name here) and give the new feature a better name than somefeature:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git checkout -b yn-somefeature origin/master","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Commit any changes and features that you like to the new branch. When the commits look complete to you, push the branch to your repository fork:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git push -u origin yn-somefeature","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This makes your changes visible in your repository. After that, you can navigate to GitHub's pull request page, where you should immediately see a big green button that helps you to create a pull request for this branch. Read the section below for precise details and guidelines on submitting the pull requests.","category":"page"},{"location":"howToContribute/#How-to-submit-a-pull-request-(PR)-with-your-modification/enhancement?","page":"How to contribute","title":"How to submit a pull request (PR) with your modification/enhancement?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Make a fork of the repository, commit the modifications in a separate branch and push the branch to your fork.\nMake a pull request where you describe the motivation and expected outcome for the users. Specifically, consider any possible incompatibilities, and the necessity to increment the version number after your changes are applied. Label your pull request with a semantic emoji in the title to indicate what it addresses.\nAfter submitting the pull request, verify that all status checks (tests, documentation) are passing. Make sure any new contribution is properly documented and tested (you may want to check with coverage tools, using test --coverage from the Julia packaging shell)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After you submitted a pull request, a label might be assigned that allows us to track and manage issues and pull requests.","category":"page"},{"location":"howToContribute/#Code-culture-and-style-recommendations","page":"How to contribute","title":"Code culture and style recommendations","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Follow basic rules for software maintainability and extensibility:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Do not reimplement functionality that is available in other packages, unless the reimplementation is either trivial and short, or there is a grave need to do so because the other implementations are deficient in some manner.\nTry to keep the function names and interfaces consistent with ecosystem standards and the other functions in the package. Consistency reduces the amount of surprise on the user side, thus lowers the need to reach for documentation, and in turn makes the software much easier and faster to use.\nCode less. Shorter code is almost always better unless demonstrated otherwise, e.g. with a benchmark. Avoid repetitive boilerplate (there should be ways to generate it, if needed).\nKeep the functionality \"open\" and composable. In particular, avoid all unnecessarily opaque and leaky abstractions (common in object-oriented programming).\nAvoid producing lots of \"informative\" text side-output by default, unless that is what the user asked for.\nAdhere to the code formatting rules defined by JuliaFormatter. We usually have a bot running that checks all PRs and reports whether the code is properly formatted.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Follow the common rules for making easily mergable and reviewable PRs:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Create one PR for each logical \"feature\" you want to merge. If your change is more complex and contains multiple \"stages\", open multiple PRs.\nKeep the test coverage reasonably high.\nIf you commit many small, partial changes in a PR, you may help us save energy by prefixing your commit names with [skip ci], which deactivates the CI trigger on that commit. With each skipped CI, you save a few watt-hours of energy. Testing just the \"final\" commit of the pull-request branch is sufficient.","category":"page"},{"location":"howToContribute/#For-developers:-What-is-the-expected-branch-management/workflow?","page":"How to contribute","title":"For developers: What is the expected branch management/workflow?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The workflow is based on GitLab flow, i.e., a master branch with feature branches being merged into the master branch. Depending on your access rights, you may open the feature branch in this repository, on in your fork.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The guidelines can be summarized as such:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"when making a contribution, create one new branch and open one new PR for each new independent feature or bugfix\ndo not push to another branch unless it is your own\ntry to get a review before merging unless the change is trivial and non-impacting\nconsider prefixing your branch names with your initials, so that one can easily see who owns which branch (e.g. ad-somefeature would be committed by Arthur Dent)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/2_finding_balance.jl\"","category":"page"},{"location":"notebooks/2_finding_balance/#Finding-balance-and-variability-of-constraint-based-models","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Here we use flux_balance_analysis, flux_variability_analysis, and parsimonious_flux_balance_analysis of COBREXA.jl functions to analyze a toy model of E. coli.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"If it is not already present, download the model.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"tip: Tip: use `?` to get quick help about functions\nWhen you are unsure about how a function works, write ?   function_name to see the function reference documentation.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"notebooks/2_finding_balance/#Optimization-solvers-in-COBREXA","page":"Finding balance and variability of constraint-based models","title":"Optimization solvers in COBREXA","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"To actually perform any optimization based analysis we need to load an optimizer. Any JuMP.jl-supported optimizers will work. Here, we will use Tulip.jl to optimize linear programs and OSQP.jl to optimize quadratic programs.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"note: Note: OSQP can be sensitive\nWe recommend reading the docs of OSQP before using it, since   it may give inconsistent results depending on what settings   you use. Commercial solvers like Gurobi, Mosek, CPLEX, etc.   require less user engagement.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"using Tulip, OSQP","category":"page"},{"location":"notebooks/2_finding_balance/#Flux-balance-analysis-(FBA)","page":"Finding balance and variability of constraint-based models","title":"Flux balance analysis (FBA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Most analysis functions come in several variants that produce different types of output. All of them usually require a model and JuMP.jl-compatible optimizer to work in the model.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"In the case of FBA, you may choose from these variants (here using the Tulip optimizer):","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"vec_soln = flux_balance_analysis_vec(model, Tulip.Optimizer)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"notebooks/2_finding_balance/#Modifications","page":"Finding balance and variability of constraint-based models","title":"Modifications","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Often it is desirable to add a slight modififaction to the problem before performing analysis, to see e.g. differences of the model behavior caused by the change introduced.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"COBREXA.jl supports several modifications by default, which include changing objective sense, optimizer attributes, flux constraints, optimization objective, reaction and gene knockouts, and others.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [ # modifications are applied in order\n        # this changes the objective to maximize the biomass production\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"),\n\n        # this fixes a specific rate of the glucose exchange\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n\n        # this knocks out two genes, i.e. constrains their associated reactions to zero.\n        knockout([\"b0978\", \"b0734\"]), ## the gene IDs are cytochrome oxidase (CYTBD)\n\n        # ignore the optimizer specified above and change it to Tulip\n        change_optimizer(Tulip.Optimizer),\n\n        # set a custom attribute of the Tulip optimizer (see Tulip docs for more possibilities)\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 110),\n\n        # explicitly tell the optimizer to maximize the new objective\n        change_sense(MAX_SENSE),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"This solution can be display using flux_summary. Note, this pretty printing only works on flux solutions that are represented as dictionaries.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"flux_summary(dict_soln)","category":"page"},{"location":"notebooks/2_finding_balance/#Flux-variability-analysis-(FVA)","page":"Finding balance and variability of constraint-based models","title":"Flux variability analysis (FVA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"The default FVA in flux_variability_analysis returns maximized and minimized reaction fluxes in a matrix. Here we use the dictionary variant in fluxvariabilityanalysis_dict, to show how to easily access specific fluxes from its results.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_mins, fva_maxs = flux_variability_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.99), # the objective function is allowed to vary by ~1% from the FBA optimum\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"R_EX_glc__D_e\", -10, -10),\n        change_constraint(\"R_EX_o2_e\", 0.0, 0.0),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_maxs[\"R_EX_ac_e\"][\"R_EX_ac_e\"] # get the maximal acetate exchange flux","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Another option is to display this information using flux_variability_summary. This pretty printing only works on flux variability analysis results where dictionary keys indicate which flux is optimized and the associated value is a flux dictionary.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"flux_variability_summary((fva_mins, fva_maxs))","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"More sophisticated variants of flux_variability_analysis can be used to extract specific pieces of information from the solved optimization problems. Here the objective value of the minimized flux and the associated biomass growth rate is returned instead of every flux.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"biomass_idx = first(indexin([\"R_BIOMASS_Ecoli_core_w_GAM\"], reactions(model))) # index of biomass function\nvs = flux_variability_analysis(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.50), # biomass can vary up to 50% less than optimum\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"R_EX_glc__D_e\", -10, -10),\n        change_constraint(\"R_EX_o2_e\", 0.0, 0.0),\n    ],\n    ret = m ->\n        (COBREXA.JuMP.objective_value(m), COBREXA.JuMP.value(m[:x][biomass_idx])), # m is the model and m[:x] extracts the fluxes from the model\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_mins = Dict(rxn => flux for (rxn, flux) in zip(reactions(model), vs[:, 1]))","category":"page"},{"location":"notebooks/2_finding_balance/#Parsimonious-flux-balance-analysis-(pFBA)","page":"Finding balance and variability of constraint-based models","title":"Parsimonious flux balance analysis (pFBA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Parsimonious flux balance analysis (here in parsimonious_flux_balance_analysis finds a unique flux solution that minimizes the squared sum of fluxes of the system subject, while maintaining the same objective value as the flux balance analysis solution. Since we are optimizing a quadratic objective, we also need to switch to a quadratic optimizer. In this case, OSQP will work. We demonstrate it on the dictionary-returning variant of pFBA, parsimonious_flux_balance_analysis_dict:","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = parsimonious_flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [\n        silence, # silence the optimizer (OSQP is very verbose by default)\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"The function also has the expectable second variant that returns a vector of solutions, in parsimonious_flux_balance_analysis_vec. Here, we utilize it to show how to use different optimizers for finding the optimum and for solving the quadratic problem. That may be preferable if the optimizer qualities differ for the differing tasks. pFBA allows you to specify qp_modifications that are applied after the original optimum is found, and before the quadratic part of the problem solving begins.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"vec_soln = parsimonious_flux_balance_analysis_vec(\n    model,\n    Tulip.Optimizer; # start with Tulip\n    modifications = [\n        change_constraint(\"R_EX_glc__D_e\", -12, -12),\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500), # we may change Tulip-specific attributes here\n    ],\n    qp_modifications = [\n        change_optimizer(OSQP.Optimizer), # now switch to OSQP (Tulip wouldn't be able to finish the computation)\n        silence, # and make it quiet.\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/1_loading_converting_saving.jl\"","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Loading,-converting,-and-saving-models","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"COBREXA can load models stored in .mat, .json, and .xml formats (with the latter denoting SBML formatted models).","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"We will primarily use the E. Coli \"core\" model to demonstrate the utilities found in COBREXA. First, let's download the model in several formats.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"# Downloads the model files if they don't already exist\n!isfile(\"e_coli_core.mat\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.mat\", \"e_coli_core.mat\");\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\");\nnothing #hide","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Now, load the package:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using COBREXA","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"tip: Save bandwidth!\nThe published models usually do not change very often. It is therefore pretty useful to save them to a central location and load them from there. That saves your time, and does not unnecessarily consume the connectivity resources of the model repository.","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Loading-models","page":"Loading, converting, and saving models","title":"Loading models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Load the models using the load_model function. Each model is able to \"pretty-print\" itself, hiding the inner complexity.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"mat_model = load_model(\"e_coli_core.mat\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"json_model = load_model(\"e_coli_core.json\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"sbml_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"note: Note: `load_model` infers the output type from the file extension\nNotice how each model was read into memory as a model type corresponding   to its file type, i.e. the file ending with .json loaded as a   JSONModel, the file ending with .mat loaded as MATModel, and the   file ending with .xml loaded as an SBMLModel.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"You can directly inspect the model objects, although only with a specific way for each specific type.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"JSON models contain their corresponding JSON:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"json_model.json","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"SBML models contain a complicated structure from SBML.jl package:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"typeof(sbml_model.sbml)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"MAT models contain MATLAB data:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"mat_model.mat","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Using-the-generic-interface-to-access-model-details","page":"Loading, converting, and saving models","title":"Using the generic interface to access model details","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"To prevent the complexities of object representation, COBREXA.jl uses a set of generic interface functions that extract various important information from all supported model types. This approach ensures that the analysis functions can work on any data.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"For example, you can check the reactions and metabolites contained in SBML and JSON models using the same accessor:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"reactions(json_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"reactions(sbml_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"issetequal(reactions(json_model), reactions(mat_model)) # do models contain the same reactions?","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"All accessors are defined in a single file in COBREXA source code; you may therefore get a list of all accessors as follows:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using InteractiveUtils\n\nfor method in filter(\n    x -> endswith(string(x.file), \"MetabolicModel.jl\"),\n    InteractiveUtils.methodswith(MetabolicModel, COBREXA),\n)\n    println(method.name)\nend","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Converting-between-model-types","page":"Loading, converting, and saving models","title":"Converting between model types","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"It is possible to convert model types to-and-fro. To do this, use the convert function, which is overloaded from Julia's Base.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"danger: Data loss may occur when converting between models\nThe conversion of models only uses the data accessible through the generic accessors. Other data may get lost.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m = convert(MATModel, json_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m will now contain the MATLAB-style matrix representation of the model:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Matrix(m.mat[\"S\"])","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"The loading and conversion can be combined using a shortcut:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m = load_model(MATModel, \"e_coli_core.json\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Saving-and-exporting-models","page":"Loading, converting, and saving models","title":"Saving and exporting models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"COBREXA.jl supports exporting the models in JSON and MAT format, using save_model.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"save_model(m, \"converted_model.json\")\nsave_model(m, \"converted_model.mat\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"If you need a non-standard suffix, use the type-specific saving functions:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"save_json_model(m, \"file.without.a.good.suffix\")\nsave_mat_model(m, \"another.file.matlab\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"If you are saving the models only for future processing in Julia environment, it is often wasteful to encode the models to external formats and decode them back. Instead, you can use the \"native\" Julia data format, accessible with package Serialization.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This way, you can use serialize to save even the StandardModel that has no file format associated:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using Serialization\n\nsm = convert(StandardModel, m)\n\nopen(f -> serialize(f, sm), \"myModel.stdmodel\", \"w\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"The models can then be loaded back using deserialize:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"sm2 = deserialize(\"myModel.stdmodel\")\nissetequal(metabolites(sm), metabolites(sm2))","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This form of loading operation is usually pretty quick:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"t = @elapsed deserialize(\"myModel.stdmodel\")\n@info \"Deserialization took $t seconds\"","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Notably, large and complicated models with thousands of reactions and annotations can take seconds to decode properly. Serialization allows you to almost completely remove this overhead, and scales well to tens of millions of reactions.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/3_basic_stdmodel_usage.jl\"","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Basic-usage-of-StandardModel","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"In this tutorial we will use COBREXA's StandardModel and functions that specifically operate on it. As usual we will use the toy model of E. coli for demonstration.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Loading-a-model","page":"Basic usage of StandardModel","title":"Loading a model","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model = load_model(StandardModel, \"e_coli_core.json\") # we specifically want to load a StandardModel from the model file","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"note: Note: Loading `StandardModel`s implicitly uses `convert`\nWhen using load_model(StandardModel, file_location) the model at   file_location is first loaded into its inferred format and is then   converted to a StandardModel using the generic accessor interface.   Thus, data loss may occur. Always check your model to ensure that   nothing important has been lost.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Basic-analysis","page":"Basic usage of StandardModel","title":"Basic analysis","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"As before, for optimization based analysis we need to load an optimizer. Here we will use Tulip.jl to solve the linear programs of this tutorial. Refer to the basic constraint-based analysis tutorial for more informaiton.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"All the normal analysis functions work on StandardModel, due to it also having the same generic accessor interface as all the other model types.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"using Tulip\n\nfluxes = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [\n        change_objective(\"BIOMASS_Ecoli_core_w_GAM\"),\n        change_constraint(\"EX_glc__D_e\", -12, -12),\n        change_constraint(\"EX_o2_e\", 0, 0),\n    ],\n)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"This is not very exciting yet, since every other model type can also do this. However, deeper inspection of flux results is possible when using StandardModel.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Inspecting-the-flux-solution:-atom_fluxes","page":"Basic usage of StandardModel","title":"Inspecting the flux solution: atom_fluxes","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"It is sometimes interesting to keep track of the atoms entering and leaving the system through boundary reactions. This can be inspected by calling atom_fluxes. That gives you the flux of individual atoms getting consumed and produced by all reactions, based on fluxes. We erase the reaction that consumes the atoms for creating biomass, to see how much mass the \"rest\" of the reaction produces for it:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fluxes_without_biomass = copy(fluxes);\ndelete!(fluxes_without_biomass, \"BIOMASS_Ecoli_core_w_GAM\");\natom_fluxes(model, fluxes_without_biomass)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Inspecting-the-flux-solution:-metabolite_fluxes","page":"Basic usage of StandardModel","title":"Inspecting the flux solution: metabolite_fluxes","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another useful flux result analysis function is metabolite_fluxes. This function gives an overview of reactions consuming and producing each metabolite.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"consuming, producing = metabolite_fluxes(model, fluxes)\n\nconsuming[\"atp_c\"] # reactions consuming `atp_c`","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Internals-of-StandardModel","page":"Basic usage of StandardModel","title":"Internals of StandardModel","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another benefit of StandardModel is that it supports a richer internal infrastructure that can be used to manipulate internal model attributes in a systematic way. Specifically, the genes, reactions, and metabolites with of a model each have a type. This is particularly useful when modifying or even constructing a model from scratch.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Genes,-Reactions,-and-Metabolites","page":"Basic usage of StandardModel","title":"Genes, Reactions, and Metabolites","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel is composed of ordered dictionaries of Genes, Metabolites and Reactions. Ordered dictionaries are used because the order of the reactions and metabolites are important for constructing a stoichiometric matrix since the rows and columns should correspond to the order of the metabolites and reactions returned by calling the accessors metabolites and reactions.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Each StandardModel is composed of the following fields:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(StandardModel) # fields of a StandardModel","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The :genes field of a StandardModel contains an ordered dictionary of gene ids mapped to Genes.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model.genes # the keys of this dictionary are the same as genes(model)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The Gene type is a struct that can be used to store information about genes in a StandardModel. Each Gene is composed of the following fields:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(Gene)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"tip: Tip: Use <tab> complete to explore the structure of types\nUse <tab> to quickly explore the fields of a struct. For example,   Gene.<tab> will list all the fields shown above.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The keys used in the ordered dictionaries in model.genes are the ids returned using the generic accessor genes. Genes have pretty printing, as demonstrated below for a random gene drawn from the model:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_gene_id = genes(model)[rand(1:n_genes(model))]\nmodel.genes[random_gene_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The same idea holds for both metabolites (stored as Metabolites) and reactions (stored as Reactions). This is demonstrated below.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_metabolite_id = metabolites(model)[rand(1:n_metabolites(model))]\nmodel.metabolites[random_metabolite_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_reaction_id = reactions(model)[rand(1:n_reactions(model))]\nmodel.reactions[random_reaction_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel can be used to build your own metabolic model or modify an existing one. One of the main use cases for StandardModel is that it can be used to merge multiple models or parts of multiple models together. Since the internals are uniform inside each StandardModel, attributes of other model types are squashed into the required format (using the generic accessors). This ensures that the internals of all StandardModels are the same - allowing easy systematic evaluation.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"warning: Warning: Combining models with different namespaces is tricky\nCombining models that use different namespaces requires care.   For example, in some models the water exchange reaction is called   EX_h2o_e, while in others it is called R_EX_h2o_s. This needs to   manually addressed (for now) to prevent duplicate, e.g. reactions,   from being added.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-annotation_index","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: annotation_index","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Often when models are automatically reconstructed duplicate genes, reactions or metabolites end up in a model. COBREXA exports annotation_index to check for cases where the id of a struct may be different, but the annotations the same (possibly suggesting a duplication). annotation_index builds a dictionary mapping annotation features to the ids of whatever struct you are inspecting. This makes it easy to find structs that share certain annotation features.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations = annotation_index(model.reactions)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations[\"ec-code\"]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The annotation_index function can also be used on Reactions and Genes in the same way.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-check_duplicate_reaction","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: check_duplicate_reaction","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another useful function is check_duplicate_reaction, which checks for reactions that have duplicate (or similar) reaction equations.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"pgm_duplicate = Reaction()\npgm_duplicate.id = \"pgm2\" # Phosphoglycerate mutase\npgm_duplicate.metabolites = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1)\npgm_duplicate","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"check_duplicate_reaction(pgm_duplicate, model.reactions; only_metabolites = false) # can also just check if only the metabolites are the same but different stoichiometry is used","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-reaction_mass_balanced","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: reaction_mass_balanced","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Finally, reaction_mass_balanced can be used to check if a reaction is mass balanced based on the formulas of the reaction equation.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_dict = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1, \"h2o_c\" => 1)\nreaction_mass_balanced(model, rxn_dict)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Now to determine which atoms are unbalanced, you can use reaction_atom_balance","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"reaction_atom_balance(model, rxn_dict)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Note, since pgm_duplicate is not in the model, we cannot use the other variants of this function because they find the reaction equation stored inside the model.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<br>\n<div align=\"center\">\n    <img class=\"docs-light-only\" src=\"assets/header.svg?maxAge=0\" width=\"80%\">\n    <img class=\"docs-dark-only\" src=\"assets/header-dark.svg?maxAge=0\" width=\"80%\">\n</div>\n<br>","category":"page"},{"location":"#Constraint-Based-Reconstruction-and-EXascale-Analysis","page":"Home","title":"Constraint-Based Reconstruction and EXascale Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository Tests Coverage How to contribute?\n(Image: GitHub) (Image: CI) (Image: codecov) (Image: contrib)","category":"page"},{"location":"","page":"Home","title":"Home","text":"COBREXA is a toolkit for working with large constraint-based metabolic models, and a running very large number of analysis tasks on these models in parallel. Its main purpose is to make the methods of Constraint-based Reconstruction and Analysis (COBRA) scale to problem sizes that require the use of huge computer clusters and HPC environments, which allows them to be realistically applied to pre-exascale-sized models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package, you will find the usual COBRA-like functions that interface to underlying linear programming solvers. We use JuMP.jl as the unified interface for many solvers; you can plug in whichever compatible solver you want, including the popular Tulip.jl, GLPK.jl, OSQP.jl, and Gurobi.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n<img style=\"width:300px;margin:10px;border-offset:15px;border: 1px solid #eee;border-radius: 50%;padding: 10px;-webkit-border-radius: 50%;-moz-border-radius: 50%;\" src=\"https://git-r3lab.uni.lu/lcsb-biocore/COBREXA.jl/-/jobs/artifacts/master/raw/output.gif?job=generator:gource\" alt=\"history\"><br>\nDevelopment history of COBREXA.jl.\n</div>","category":"page"},{"location":"#Quick-start-guide","page":"Home","title":"Quick start guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install COBREXA from Julia repositories. Start julia, press ] to switch to the Packaging environment, and type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add COBREXA","category":"page"},{"location":"","page":"Home","title":"Home","text":"You also need to install your favorite solver supported by JuMP.jl, typing e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add Tulip","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the packages are installed, switch back to the \"normal\" julia shell by pressing Backspace (the prompt should change color back to green). After that, you can download a SBML model from the internet and perform a flux balance analysis as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using COBREXA   # loads the package\nusing Tulip     # loads the optimization solver\n\n# download the model\ndownload(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\n# open the SBML file and load the contents\nmodel = load_model(\"e_coli_core.xml\")\n\n# run a FBA\nfluxes = flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The variable fluxes will now contain a dictionary of the computed optimal flux of each reaction in the model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dict{String,Float64} with 95 entries:\n  \"R_EX_fum_e\"    => 0.0\n  \"R_ACONTb\"      => 6.00725\n  \"R_TPI\"         => 7.47738\n  \"R_SUCOAS\"      => -5.06438\n  \"R_GLNS\"        => 0.223462\n  \"R_EX_pi_e\"     => -3.2149\n  \"R_PPC\"         => 2.50431\n  \"R_O2t\"         => 21.7995\n  \"R_G6PDH2r\"     => 4.95999\n  \"R_TALA\"        => 1.49698\n  ⋮               => ⋮","category":"page"},{"location":"#Basic-and-quick-start-tutorials","page":"Home","title":"Basic and quick-start tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed tutorial content is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"tutorials\", filter(x -> endswith(x, \".md\"), readdir(\"tutorials\")))\nDepth = 1","category":"page"},{"location":"#Advanced-tutorials","page":"Home","title":"Advanced tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed listing of advanced tutorials is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"advanced\", filter(x -> endswith(x, \".md\"), readdir(\"advanced\")))\nDepth = 1","category":"page"},{"location":"#Example-notebooks-and-workflows","page":"Home","title":"Example notebooks and workflows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed notebook content is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"notebooks\", filter(x -> endswith(x, \".md\"), readdir(\"notebooks\")))\nDepth = 1","category":"page"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"#Contribution-guide","page":"Home","title":"Contribution guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you wish to contribute code, patches or improvements to COBREXA.jl, please read the basic contribution guidelines and hints..","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"COBREXA.jl is developed at the Luxembourg Centre for Systems Biomedicine of the University of Luxembourg (uni.lu/lcsb), cooperating with the Institute for Quantitative and Theoretical Biology at the Heinrich Heine University in Düsseldorf (qtb.hhu.de).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The development was supported by European Union's Horizon 2020 Programme under PerMedCoE project (permedcoe.eu) agreement no. 951773.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/cobrexa.svg\" alt=\"COBREXA logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/unilu.svg\" alt=\"Uni.lu logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/lcsb.svg\" alt=\"LCSB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/hhu.svg\" alt=\"HHU logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/qtb.svg\" alt=\"QTB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/permedcoe.svg\" alt=\"PerMedCoE logo\" height=\"64px\" style=\"height:64px; width:auto\">","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"EditURL = \"https://github.com/LCSB-BioCore/COBREXA.jl/blob/master/docs/src/notebooks/8_custom_model.jl\"","category":"page"},{"location":"notebooks/8_custom_model/#Using-a-custom-model-data-structure","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"","category":"section"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"This notebooks shows how to utilize the generic accessors and modification functions in COBREXA.jl to run the analysis on any custom model type. We will create a simple dictionary-style structure that describes the model, allow COBREXA to run a FVA on it, and create a simple reaction-removing modification.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"First, let's define a very simple stoichiometry-only structure for the model:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"using COBREXA\n\nmutable struct MyReaction\n    max_rate::Float64 # maximum absolute conversion rate\n    stoi::Dict{String,Float64} # stoichimetry of the reaction\n\n    MyReaction() = new(0.0, Dict{String,Float64}())\nend\n\nmutable struct MyModel <: MetabolicModel\n    optimization_target::String # the \"objective\" reaction name\n    reactions::Dict{String,MyReaction} # dictionary of reactions\n\n    MyModel() = new(\"\", Dict{String,MyReaction}())\n    MyModel(o, r) = new(o, r)\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"With this, we can start defining the accessors:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"COBREXA.n_reactions(m::MyModel) = length(m.reactions)\nCOBREXA.reactions(m::MyModel) = sort(collect(keys(m.reactions)))","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Metabolites are defined only very implicitly, so let's just make a function that collects all names. n_metabolites can be left at the default definition that just measures the output of metabolites.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"function COBREXA.metabolites(m::MyModel)\n    mets = Set{String}()\n    for (_, r) in m.reactions\n        for (m, _) in r.stoi\n            push!(mets, m)\n        end\n    end\n    return sort(collect(mets))\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Now, the extraction of the linear model. Remember the order of element in the vectors must match the order in the output of reactions and metabolites.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"using SparseArrays\n\nfunction COBREXA.bounds(m::MyModel)\n    max_rates = [m.reactions[r].max_rate for r in reactions(m)]\n    (sparse(-max_rates), sparse(max_rates))\nend\n\nfunction COBREXA.objective(m::MyModel)\n    if m.optimization_target in keys(m.reactions)\n        c = spzeros(n_reactions(m))\n        c[first(indexin([m.optimization_target], reactions(m)))] = 1.0\n        c\n    else\n        throw(\n            DomainError(\n                m.optimization_target,\n                \"The target reaction for flux optimization not found\",\n            ),\n        )\n    end\nend\n\nfunction COBREXA.stoichiometry(m::MyModel)\n    sparse([\n        get(m.reactions[rxn].stoi, met, 0.0) for met in metabolites(m), rxn in reactions(m)\n    ])\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Now the model is complete! We can generate a random one and see how it performs","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"import Random\nRandom.seed!(123)\n\nrxn_names = [\"Reaction $i\" for i = 'A':'Z'];\nmetabolite_names = [\"Metabolite $i\" for i = 1:20];\n\nm = MyModel();\nfor i in rxn_names\n    m.reactions[i] = MyReaction()\nend\n\nfor i = 1:50\n    rxn = rand(rxn_names)\n    met = rand(metabolite_names)\n    m.reactions[rxn].stoi[met] = rand([-3, -2, -1, 1, 2, 3])\n    m.reactions[rxn].max_rate = rand()\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Let's see what the model looks like now:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"m","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"We can run most of the standard function on the model data right away:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"using Tulip\nm.optimization_target = \"Reaction A\"\nflux_balance_analysis_dict(m, Tulip.Optimizer)","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"To be able to use the model conveniently in functions such as screen, you usually want to be able to easily specify the modifications. In this example, we enable use of with_removed_reactions by overloading the internal remove_reactions for this specific model type:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"We need to make an as-shallow-as-possible copy of the model that allows us to remove the reactions without breaking the original model.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"function COBREXA.remove_reactions(m::MyModel, rxns::AbstractVector{String})\n    m = MyModel(m.optimization_target, copy(m.reactions))\n    delete!.(Ref(m.reactions), rxns)\n    return m\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"The screening is ready now!","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"reactions_to_remove = (\"Reaction $i\" for i = 'B':'Z')\n\nreactions_to_remove .=> screen_variants(\n    m,\n    [[with_removed_reactions([r])] for r in reactions_to_remove],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"Reaction A\"],\n)","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"This page was generated using Literate.jl.","category":"page"}]
}
