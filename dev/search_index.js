var documenterSearchIndex = {"docs":
[{"location":"tutorials/1_loading/#Loading-and-converting-model-data","page":"Loading and converting model data","title":"Loading and converting model data","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"COBREXA.jl supports several constraint-based model formats that can be loaded with built-in functions. You can load SBML models that are compatible with libsbml, JSON models (such as the ones from CobraPy), and MATLAB-style models (such as those from COBRA Toolbox).","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"These formats are commonly available from many model repositories, such as from BIGG, as seen e.g. on the BIGG entry for the core E. Coli entry. Here, we show how to load the basic formats and work with such models.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"tip: Notebook available!\nExample code for this tutorial is available here.","category":"page"},{"location":"tutorials/1_loading/#Loading-models-from-files","page":"Loading and converting model data","title":"Loading models from files","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"For most purposes, you should be able to open and load any model with load_model, which detects the file type from the extension (.xml, .json and .mat), and calls the appropriate loading function. After loading the COBREXA.jl library with using COBREXA and you may load the downloaded model data into Julia as follows:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"my_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"You should see some information about the loaded model, possibly looking like this:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Metabolic model of type JSONModel\n\n  [9 ,  1]  =  1.0\n  [51,  1]  =  1.0\n  ⋮\n  [57, 95]  =  1.0\n  [59, 95]  =  -1.0\nNumber of reactions: 95\nNumber of metabolites: 72","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"If the file type can not be guessed from the file extension, use any of the specific loader functions:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"load_sbml_model for SBML\nload_json_model for JSON\nload_mat_model for MATLAB models","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"All formats may store slightly different information. By default, COBREXA attempts not to discard any information unless a conversion to a more strict format is required. For example, the JSONModel (which is returned by load_json_model) still holds the original JSON structure that you can freely access for any specific purposes:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"jm = load_json_model(\"e_coli_core.json\")\njm.json[\"reactions\"][1]","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"That should print out the first reaction in the model in a JSON-style scheme, in our case the process catalyzed by phosphofructokinase:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Dict{String,Any} with 9 entries:\n  \"name\"               => \"Phosphofructokinase\"\n  \"metabolites\"        => Dict{String,Any}(\"adp_c\"=>1.0,\"atp_c\"=>-1.0,\"f6p_c\"=>…\n  \"lower_bound\"        => 0.0\n  \"id\"                 => \"PFK\"\n  \"notes\"              => Dict{String,Any}(\"original_bigg_ids\"=>Any[\"PFK\"])\n  \"gene_reaction_rule\" => \"b3916 or b1723\"\n  \"upper_bound\"        => 1000.0\n  \"subsystem\"          => \"Glycolysis/Gluconeogenesis\"\n  \"annotation\"         => Dict{String,Any}(\"ec-code\"=>Any[\"2.7.1.11\"],\"metanetx…","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"MATModel and SBMLModel (returned by the respective loading functions) contain similar \"full\" model information – you can access the whole MATLAB and SBML data and build on them without any restrictions.","category":"page"},{"location":"tutorials/1_loading/#Converting-to-other-model-types","page":"Loading and converting model data","title":"Converting to other model types","text":"","category":"section"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Despite JSON and SBML are great for storing and exchanging the models, the data representation is not very suitable for analyzing the model and processing it mathematically.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"COBREXA.jl contains several model types that are much better suited  for supporting the analysis tasks. You can use the following:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"CoreModel, which represents the \"core\" of the optimization problem and the corresponding linear programming problem – a sparse representation of the stoichiometric matrix, flux bounds vectors, objective vector, etc.\nStandardModel (a \"standard\" for COBREXA.jl), which represents a highly flexible, object-like, dictionary-based representation of a model that contains individual Reactions, Metabolites, Genes, and other things.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"note: Conversion limitations and possible data loss\nBecause of the specifics of the format of each model structure, the conversion is not always able to preserve all information from the source data. You may need to check if any complicated and less-standard annotations are still present. If you require them, and either use a more complicated model, or collect them manually.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"A loaded model can be converted to any other model type using the standard Julia conversion:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"cm = convert(CoreModel, jm)","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"You can also use a shortcut in load_model to convert the model to the desired format in one command:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"cm = load_model(CoreModel, \"e_coli_core.xml\")","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"With CoreModel, the information is easily accessible in matrix form. For example, cm.S now contains the sparse stoichiometric matrix, which you can convert to a dense matrix and manipulate it in Julia as any other matrix:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"Matrix(cm.S)","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"...should show you the (relatively empty) stoichiometry of the model.","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"StandardModel is more suitable for fine-grained access to individual items of the model, perhaps closer to the SBML-style models. For example, you can view and set reaction bounds as follows:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"sm = load_model(StandardModel, \"e_coli_core.json\")\nsm.reactions[\"PGI\"].ub","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"...this prints the upper bound of the reaction (in this case, 1000.0); you can change it the usual way:","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"sm.reactions[\"PGI\"].ub = 500","category":"page"},{"location":"tutorials/1_loading/","page":"Loading and converting model data","title":"Loading and converting model data","text":"This change will naturally project to future analysis results.","category":"page"},{"location":"tutorials/#COBREXA-Tutorials","page":"All tutorials","title":"COBREXA Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"All tutorials","title":"All tutorials","text":"Pages = joinpath.(\"tutorials\", filter(x -> endswith(x, \".md\"), readdir(\"tutorials\")))\nDepth = 2","category":"page"},{"location":"advanced/2_custom_model/#Working-with-custom-models","page":"Working with custom models","title":"Working with custom models","text":"","category":"section"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"It may happen that the intuitive representation of your data does not really match what is supported by a given COBRA package. COBREXA.jl attempts to avoid this problem by providing a flexible framework for containing any data structure that can, somehow, represent the constraint-based model.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The task of having such a polymorphic model definition can be split into 2 separate concerns:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"How to allow the analysis functions to gather the required information from any user-specified model data structure?\nHow to make the reconstruction functions (i.e., reaction or gene deletions) work properly on any data structure?","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"To solve the first concern, COBREXA.jl specifies a set of generic accessors that work over the abstract type MetabolicModel. To use your data structure in a model, you just make it a subtype of MetabolicModel and overload the required accessors. The accessors are functions that extract some relevant information, such as stoichiometry and bounds, returning a fixed simple data type that can be further used by COBREXA.  You may see a complete list of accessors here.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"A good solution to the second concern is a slightly more involved, as writing generic data modifiers is notoriously hard. Still, there is support for easily making small changes to the model using the modifications system, with functions such as with_added_reactions and with_changed_bound.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"tip: Notebook available\nA better example of using a custom model structure is available in a separate notebook.","category":"page"},{"location":"advanced/2_custom_model/#Writing-the-generic-accessors","page":"Working with custom models","title":"Writing the generic accessors","text":"","category":"section"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"Let's write a data structure that represents a very small model that contains N metabolites that are converted in a circle through N linear, coupled reactions. (E.g., for N=3, we would have a conversion of metabolites A, B and C ordered as A → B → C → A.) This may be useful for testing purposes; we will use it for a simple demonstration.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The whole model can thus be specified with a single integer N that represents the length of the reaction cycle:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"struct CircularModel <: MetabolicModel\n    size::Int\nend","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"First, define the reactions and metabolites:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"COBREXA.n_reactions(m::CircularModel) = m.size\nCOBREXA.n_metabolites(m::CircularModel) = m.size\n\nCOBREXA.reactions(m::CircularModel) = [\"rxn$i\" for i in 1:n_reactions(m)]\nCOBREXA.metabolites(m::CircularModel) = [\"met$i\" for i in 1:n_metabolites(m)]","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"It is useful to re-use the already defined functions, as that improves the code maintainability.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"We can continue with the actual linear model properties:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"function COBREXA.objective(m::CircularModel)\n    c = spzeros(n_reactions(m))\n    c[1] = 1 #optimize the first reaction\n    return c\nend\n\nCOBREXA.bounds(m::CircularModel) = (\n    zeros(n_reactions(m)), # lower bounds\n    ones(n_reactions(m)), # upper bounds\n)\n\nfunction COBREXA.stoichiometry(m::CircularModel)\n    nr = n_reactions(m)\n    stoi(i,j) =\n        i == j ? 1.0 :\n        (i % nr + 1) == j  ? -1.0 :\n        0.0\n\n    sparse([stoi(i,j) for i in 1:nr, j in 1:nr])\nend","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"You may check that the result now works just as with CoreModel and StandardModel:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"julia> m = CircularModel(5)\nMetabolic model of type CircularModel\n\n  1.0  -1.0    ⋅     ⋅     ⋅\n   ⋅    1.0  -1.0    ⋅     ⋅\n   ⋅     ⋅    1.0  -1.0    ⋅\n   ⋅     ⋅     ⋅    1.0  -1.0\n -1.0    ⋅     ⋅     ⋅    1.0\nNumber of reactions: 5\nNumber of metabolites: 5\n","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"This interface is sufficient to run most of the basic analyses, especially the flux balance finding ones:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"julia> flux_balance_analysis_dict(m, Tulip.Optimizer)\nDict{String, Float64} with 5 entries:\n  \"rxn5\" => 1.0\n  \"rxn2\" => 1.0\n  \"rxn1\" => 1.0\n  \"rxn3\" => 1.0\n  \"rxn4\" => 1.0\n","category":"page"},{"location":"advanced/2_custom_model/#Writing-generic-model-modifications","page":"Working with custom models","title":"Writing generic model modifications","text":"","category":"section"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The custom model structure can also be made compatible with many of the existing variant-generating functions and analysis modifiers.","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"The functions prepared for use as \"variants\" in screen, usually prefixed by with_, have their generic variants that only call simpler, overloadable functions for each specific model. This choice is based on the overloading dispatch system of Julia. For example,with_removed_metabolites is implemented very generically by reducing the problem to some specific remove_metabolites functions selected by the dispatch, as follows:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"with_removed_metabolites(args...; kwargs...) =\n    m -> remove_metabolites(m, args...; kwargs...)","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"To be able to use with_removed_metabolites in your model, we can just overload the actual inner function. For the simple circular model, the modification might as well look like this:","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"COBREXA.remove_metabolites(m::CircularModel, n::Int) =\n    return CircularModel(m.size - n)","category":"page"},{"location":"advanced/2_custom_model/","page":"Working with custom models","title":"Working with custom models","text":"danger: Functions that generate model variants must be pure\nNotice that the function is \"pure\", i.e., does not make any in-place modifications to the original model structure. That property is required for screen and other functions to properly and predictably apply the modifications to the model. To expose potential in-place modifications to your codebase, you should instead overload the \"bang\" counterpart of remove metabolites, called remove_metabolites!.","category":"page"},{"location":"tutorials/2_analysis/#Basic-analysis-of-constraint-based-models","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"COBREXA.jl supports several common analysis methods that are often used for exploring the biological models. The currently supported methods include","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Flux balance analysis (FBA), in function flux_balance_analysis\nFlux variability analysis (FVA), in flux_variability_analysis\nFlux sampling by linearized hit-and-run algorithm, in affine_hit_and_run\nParsimonious flux balance analysis (pFBA), in parsimonious_flux_balance_analysis","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Other analysis methods are either in development and testing, or may be specified or customized by the user. Implementing new analyses is generally feasible; you may want to watch the COBREXA.jl repository for newly incoming analysis methods.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"COBREXA.jl additionally exports several helper functions that may help you in running custom analysis methods:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"you can convert all types of MetabolicModels to JuMP.jl models using make_optimization_model, then you may explore and analyze the models independently of COBREXA.jl using the tools provided by JuMP.jl\nthere is a system of analysis modifications that allows you to easily specify various adjustments to the existing analysis methods","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"tip: Notebook available!\nExamples of running the analysis functions are available here.","category":"page"},{"location":"tutorials/2_analysis/#Optimization-problem-solvers","page":"Basic analysis of constraint-based models","title":"Optimization problem solvers","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For solving most analysis tasks, you need an optimization problem solver that is compatible with JuMP.jl. You may refer to the official list of supported solvers, but we generally recommend to use either of these:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Tulip (pure Julia implementation) for linear problems\nGLPK (based on a C library) for linear and mixed-integer problems\nGurobi (based on an external library, but requires a license that is free for academic use) for linear, mixed-integer and quadratic problems","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"All solvers can be installed using the Julia package manger.","category":"page"},{"location":"tutorials/2_analysis/#Flux-balance-analysis","page":"Basic analysis of constraint-based models","title":"Flux balance analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"The above methods generally accept 2 arguments: the model, and the optimizer.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"In particular, having installed e.g. GLPK from the above optimizers, you can run FBA on your favorite E. Coli core model as follows:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"using COBREXA\nm = load_model(CoreModel, \"e_coli_core.xml\")\n\nusing GLPK\nopt_model = flux_balance_analysis(m, GLPK.Optimizer)","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"After a short while (the solver machinery usually needs to get precompiled before the first use), you should get opt_model, which is now an optimized JuMP.jl model. It may print out information like this:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"A JuMP Model\nMaximization problem with:\nVariables: 95\nObjective function type: JuMP.GenericAffExpr{Float64,JuMP.VariableRef}\n`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 73 constraints\n`JuMP.GenericAffExpr{Float64,JuMP.VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 192 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: GLPK\nNames registered in the model: lbs, mb, ubs, x","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"From that, you can extract the required information with the JuMP interface, loaded with using JuMP. With that,","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"objective_value(opt_model) prints roughly 0.87,\nvalue.(opt_model[:x]) prints the vector of individual reaction fluxes.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For convenience, you can get the results nicely formatted without manually getting them out of the optimized models:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"flux_balance_analysis_vec works like flux_balance_analysis, but returns the vector of fluxes directly (in the same order as in reactions(m))\nflux_balance_analysis_dict returns a dictionary with the fluxes, keyed by reaction identifier","category":"page"},{"location":"tutorials/2_analysis/#Flux-variability-analysis","page":"Basic analysis of constraint-based models","title":"Flux variability analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"FVA is implemented in flux_variability_analysis, which returns the usual matrix of minimal and maximal feasible fluxes for each reaction in the model.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"The result of calling flux_variability_analysis(m, GLPK.Optimizer) may look like this (possibly showing minor numeric errors in the GLPK optimizer):","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×2 Array{Float64,2}:\n   0.0            0.0\n   6.00725        6.00725\n   ⋮\n   3.64414e-13    3.17348e-13\n   3.2149         3.2149","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You can relax the optimality requirement of the reactions by specifying a wider objective bound, getting a wider range of reaction fluxes, e.g. using gamma_bounds (for COBRA-like γ-bound) and objective_bounds (for a multiplicative bound around the original optimal objective).","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"As a result, flux_variability_analysis(m, GLPK.Optimizer; bounds=gamma_bounds(0.8)) will return a much less constrained system:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×2 Array{Float64,2}:\n   0.0            0.0\n   0.754299      10.1285\n   ⋮\n  -4.42865        0.0\n   2.57192        3.2149","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You may additionally restrict the analysis to a list of reactions (passing the list as the second argument, see documentation of flux_variability_analysis), or retrieve a dictionary of the resulting fluxes with flux_variability_analysis_dict.","category":"page"},{"location":"tutorials/2_analysis/#Parsimonious-flux-balance-analysis","page":"Basic analysis of constraint-based models","title":"Parsimonious flux balance analysis","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Parsimonious flux balance analysis (pFBA) requires a solver that can handle quadratic problems. Some examples include, e.g. OSQP, Gurobi, Mosek, etc.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"Otherwise, the function behaves just like flux_balance_analysis:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"parsimonious_flux_balance_analysis(m, OSQP.Optimizer) will return a JuMP.jl model optimized to a slightly more realistic (parsimonious) optimum than plain FBA,\nparsimonious_flux_balance_analysis_vec will return the fluxes in a vector,\nparsimonious_flux_balance_analysis_dict will return a reaction-keyed dictionary.","category":"page"},{"location":"tutorials/2_analysis/#Flux-sampling","page":"Basic analysis of constraint-based models","title":"Flux sampling","text":"","category":"section"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"For the affine_hit_and_run, you need a previously optimized and constrained model from another analysis function, such as flux_balance_analysis, or created by make_optimization_model. You may need to carefully choose the number of iterations and sample sizes to match your model; see the documentation of affine_hit_and_run for details.","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"As an example, you can run the sampling for 100 thousand iterations with:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"affine_hit_and_run(100_000, make_optimization_model(m, GLPK.Optimizer))","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"You should receive a matching flux sample with the (default) 1000 samples in a matrix that may look like this one:","category":"page"},{"location":"tutorials/2_analysis/","page":"Basic analysis of constraint-based models","title":"Basic analysis of constraint-based models","text":"95×1000 Array{Float64,2}:\n   0.0           0.0         …   0.0\n   7.82669       9.38895         3.30653\n   7.13016       4.36813         9.64434\n  -0.290925     -9.3037         -0.0908829\n  24.1294       17.4794          0.0511032\n   ⋮                         ⋱\n -16.243       -37.4763         -5.57301\n   0.0           0.0             0.0\n  -0.310819     -1.20057e-7     -2.13126\n   5.71597e-5    0.00990677      0.692399","category":"page"},{"location":"notebooks/#Notebooks-and-example-workflows","page":"All notebooks","title":"Notebooks and example workflows","text":"","category":"section"},{"location":"notebooks/","page":"All notebooks","title":"All notebooks","text":"Pages = joinpath.(\"notebooks\", filter(x -> endswith(x, \".md\"), readdir(\"notebooks\")))\nDepth = 2","category":"page"},{"location":"functions/analysis/#Analysis-functions","page":"Analysis functions","title":"Analysis functions","text":"","category":"section"},{"location":"functions/analysis/#Common-analysis-functions","page":"Analysis functions","title":"Common analysis functions","text":"","category":"section"},{"location":"functions/analysis/","page":"Analysis functions","title":"Analysis functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", file), readdir(\"../src/analysis\"))","category":"page"},{"location":"functions/analysis/#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{Int64}}","page":"Analysis functions","title":"COBREXA.envelope_lattice","text":"envelope_lattice(\n    model::MetabolicModel,\n    ridxs::Vector{Int};\n    samples = 10,\n    ranges = collect(zip(bounds(model)...))[ridxs],\n    reaction_samples = fill(samples, length(ridxs)),\n)\n\nCreate a lattice (list of \"tick\" vectors) for reactions at indexes ridxs in a model. Arguments samples, ranges, and reaction_samples may be optionally specified to customize the lattice creation process.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.envelope_lattice-Tuple{MetabolicModel, Vector{String}}","page":"Analysis functions","title":"COBREXA.envelope_lattice","text":"envelope_lattice(model::MetabolicModel, rids::Vector{String}; kwargs...)\n\nVersion of envelope_lattice that works on string reaction IDs instead of integer indexes.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Analysis functions","title":"COBREXA.objective_envelope","text":"objective_envelope(\n    model::MetabolicModel,\n    ridxs::Vector{Int},\n    optimizer;\n    modifications = [],\n    lattice_args = (),\n    lattice = envelope_lattice(model, ridxs; lattice_args...),\n    analysis = screen_optimize_objective,\n    kwargs...,\n)\n\nCompute an array of objective values for the model for rates of reactions specified ridxs fixed to a regular range of values between their respective lower and upper bounds.\n\nThis can be used to compute a \"production envelope\" of a metabolite; but generalizes to any specifiable objective and to multiple dimensions of the examined space. For example, to retrieve a production envelope of any metabolite, set the objective coefficient vector of the model to a vector that contains a single 1 for the exchange reaction that \"outputs\" this metabolite, and run objective_envelope with the exchange reaction of the \"parameter\" metabolite specified in ridxs.\n\nReturns a named tuple that contains lattice with reference values of the metabolites, and an N-dimensional array values with the computed objective values, where N is the number of specified reactions.  Because of the increasing dimensionality, the computation gets very voluminous with increasing length of ridxs. The lattice for computing the optima can be supplied in the argument; by default it is created by envelope_lattice called on the model and reaction indexes. Additional arguments for the call to envelope_lattice can be optionally specified in lattice_args.\n\nkwargs are internally forwarded to screen_optmodel_modifications. modifications are appended to the list of modifications after the lattice bounds are set. By default, this returns the objective values for all points in the lattice; alternate outputs can be implemented via the analysis argument.\n\nExample\n\njulia> m = load_model(\"test/downloaded/e_coli_core.xml\");\n\njulia> envelope = objective_envelope(m, [\"R_EX_gln__L_e\", \"R_EX_fum_e\"],\n                                     Tulip.Optimizer;\n                                     lattice_args=(samples=6,));\n\njulia> envelope.lattice   # the reaction rates for which the optima were computed\n2-element Vector{Vector{Float64}}:\n [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]\n [0.0, 200.0, 400.0, 600.0, 800.0, 1000.0]\n\njulia> envelope.values   # the computed flux objective values for each reaction rate combination\n6×6 Matrix{Float64}:\n  0.873922   9.25815  17.4538  19.56   20.4121  20.4121\n 13.0354    17.508    19.9369  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n 16.6666    18.6097   20.2847  21.894  22.6825  22.6825\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.objective_envelope-Tuple{MetabolicModel, Vector{String}, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.objective_envelope","text":"objective_envelope(model::MetabolicModel, rids::Vector{String}, args...; kwargs...)\n\nVersion of objective_envelope that works on string reaction IDs instead of integer indexes.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_balance_analysis-Union{Tuple{M}, Tuple{M, Any}} where M<:MetabolicModel","page":"Analysis functions","title":"COBREXA.flux_balance_analysis","text":"flux_balance_analysis(\n    model::M,\n    optimizer;\n    modifications = [],\n) where {M<:MetabolicModel}\n\nRun flux balance analysis (FBA) on the model optionally specifying modifications to the problem.  Basically, FBA solves this optimization problem:\n\nmax cᵀx\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n\nSee \"Orth, J., Thiele, I. & Palsson, B. What is flux balance analysis?. Nat Biotechnol 28, 245-248 (2010). https://doi.org/10.1038/nbt.1614\" for more information.\n\nThe optimizer must be set to a JuMP-compatible optimizer, such as GLPK.Optimizer or Tulip.Optimizer\n\nOptionally, you may specify one or more modifications to be applied to the model before the analysis, such as change_optimizer_attribute, change_objective, and change_sense.\n\nReturns an optimized JuMP model.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nsolution = flux_balance_analysis(model, GLPK.optimizer)\nvalue.(solution[:x])  # extract flux steady state from the optimizer\n\nbiomass_reaction_id = findfirst(model.reactions, \"BIOMASS_Ecoli_core_w_GAM\")\n\nmodified_solution = flux_balance_analysis(model, GLPK.optimizer;\n    modifications=[change_objective(biomass_reaction_id)])\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.flux_balance_analysis_dict","text":"flux_balance_analysis_dict(model::MetabolicModel, args...)::Maybe{Dict{String, Float64}}\n\nA variant of FBA that returns a dictionary assigning fluxes to reactions, if the solution is found. Arguments are passed to flux_balance_analysis.\n\nThis function is kept for backwards compatibility, use flux_dict instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.flux_balance_analysis_vec","text":"flux_balance_analysis_vec(model::MetabolicModel, args...)::Maybe{Vector{Float64}}\n\nA variant of FBA that returns a vector of fluxes in the same order as reactions of the model, if the solution is found.\n\nArguments are passed to flux_balance_analysis.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._max_variability_flux-NTuple{4, Any}","page":"Analysis functions","title":"COBREXA._max_variability_flux","text":"_max_variability_flux(opt_model, flux, sense, ret)\n\nInternal helper for maximizing reactions in optimization model.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(\n    model::MetabolicModel,\n    optimizer;\n    kwargs...\n)\n\nA simpler version of flux_variability_analysis that maximizes and minimizes all declared fluxes in the model. Arguments are forwarded.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, SparseArrays.SparseMatrixCSC{Float64, Int64}, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(\n    model::MetabolicModel,\n    fluxes::Vector{Int},\n    optimizer;\n    modifications = [],\n    workers = [myid()],\n    optimal_objective_value = nothing,\n    bounds = z -> (z, Inf),\n    ret = objective_value,\n)::Matrix{Float64}\n\nFlux variability analysis solves a pair of optimization problems in model for each flux f described in fluxes:\n\nmin,max fᵀxᵢ\ns.t. S x = b\n    xₗ ≤ x ≤ xᵤ\n     cᵀx ≥ bounds(Z₀)[1]\n     cᵀx ≤ bounds(Z₀)[2]\n\nwhere Z₀:= cᵀx₀ is the objective value of an optimal solution of the associated FBA problem (see flux_balance_analysis for a related analysis, also for explanation of the modifications argument).\n\nThe bounds is a user-supplied function that specifies the objective bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in FBA. It can return -Inf and Inf in first and second pair to remove the limit. Use gamma_bounds and objective_bounds for simple bounds.\n\noptimizer must be set to a JuMP-compatible optimizer. The computation of the individual optimization problems is transparently distributed to workers (see Distributed.workers()).  The value of Z₀ can be optionally supplied in argument optimal_objective_value, which prevents this function from calling the non-parallelizable FBA. Separating the single-threaded FBA and multithreaded variability computation can be used to improve resource allocation efficiency in many common use-cases.\n\nret is a function used to extract results from optimized JuMP models of the individual fluxes. By default, it calls and returns the value of JuMP.objective_value. More information can be extracted e.g. by setting it to a function that returns a more elaborate data structure; such as m -> (JuMP.objective_value(m), JuMP.value.(m[:x])).\n\nReturns a matrix of extracted ret values for minima and maxima, of total size (size(fluxes,2),2). The optimizer result status is checked with is_solved; nothing is returned if the optimization failed for any reason.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nflux_variability_analysis(model, [1, 2, 3, 42], GLPK.optimizer)\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis","text":"flux_variability_analysis(model::MetabolicModel, flux_indexes::Vector{Int}, optimizer; kwargs...)\n\nAn overload of flux_variability_analysis that explores the fluxes specified by integer indexes\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.flux_variability_analysis_dict-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.flux_variability_analysis_dict","text":"flux_variability_analysis_dict(\n    model::MetabolicModel,\n    optimizer;\n    kwargs...\n)\n\nA variant of flux_variability_analysis that returns the individual maximized and minimized fluxes as two dictionaries (of dictionaries). All keyword arguments except ret are passed through.\n\nExample\n\nmins, maxs = flux_variability_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.99),\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"EX_glc__D_e\"; lb = -10, ub = -10),\n        change_constraint(\"EX_o2_e\"; lb = 0, ub = 0),\n    ],\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.reaction_variability_analysis","text":"reaction_variability_analysis( model::MetabolicModel, optimizer; kwargs...)\n\nShortcut for reaction_variability_analysis that examines all reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.reaction_variability_analysis-Tuple{MetabolicModel, Vector{Int64}, Any}","page":"Analysis functions","title":"COBREXA.reaction_variability_analysis","text":"reaction_variability_analysis(model::MetabolicModel, reaction_indexes::Vector{Int}, optimizer; kwargs...)\n\nA variant for flux_variability_analysis that examines actual reactions (selected by their indexes in reactions argument) instead of whole fluxes. This may be useful for models where the sets of reactions and fluxes differ.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.make_gecko_model-Tuple{MetabolicModel}","page":"Analysis functions","title":"COBREXA.make_gecko_model","text":"make_gecko_model(\n    model::MetabolicModel;\n    reaction_isozymes::Union{Function,Dict{String,Vector{Isozyme}}}\n    gene_product_bounds::Union{Function,Dict{String,Tuple{Float64,Float64}}},\n    gene_product_molar_mass::Union{Function,Dict{String,Float64}},\n    gene_product_mass_group::Union{Function,Dict{String,String}} = _ -> \"uncategorized\",\n    gene_product_mass_group_bound::Union{Function,Dict{String,Float64}},\n)\n\nWrap a model into a GeckoModel, following the structure given by GECKO algorithm (see GeckoModel documentation for details).\n\nArguments\n\nreaction_isozymes is a function that returns a vector of Isozymes for each reaction, or empty vector if the reaction is not enzymatic.\ngene_product_bounds is a function that returns lower and upper bound for concentration for a given gene product (specified by the same string gene ID as in reaction_isozymes), as Tuple{Float64,Float64}.\ngene_product_molar_mass is a function that returns a numeric molar mass of a given gene product specified by string gene ID.\ngene_product_mass_group is a function that returns a string group identifier for a given gene product, again specified by string gene ID. By default, all gene products belong to group \"uncategorized\" which is the behavior of original GECKO.\ngene_product_mass_group_bound is a function that returns the maximum mass for a given mass group.\n\nAlternatively, all function arguments may be also supplied as dictionaries that provide the same data lookup.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._mmdf_add_df_bound-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA._mmdf_add_df_bound","text":"Helper function to add a new constraint on the driving force.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._mmdf_concen_objective-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA._mmdf_concen_objective","text":"Helper function to change the objective to optimizing some concentration.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._mmdf_dgr_objective-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA._mmdf_dgr_objective","text":"Helper function to change the objective to optimizing some dG.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.max_min_driving_force-Tuple{MetabolicModel, Dict{String, Float64}, Any}","page":"Analysis functions","title":"COBREXA.max_min_driving_force","text":"max_min_driving_force(\n    model::MetabolicModel,\n    reaction_standard_gibbs_free_energies::Dict{String,Float64},\n    optimizer;\n    flux_solution::Dict{String,Float64} = Dict{String,Float64}(),\n    proton_ids::Vector{String} = [\"h_c\", \"h_e\"],\n    water_ids::Vector{String} = [\"h2o_c\", \"h2o_e\"],\n    constant_concentrations::Dict{String,Float64} = Dict{String,Float64}(),\n    concentration_ratios::Dict{Tuple{String,String},Float64} = Dict{\n        Tuple{String,String},\n        Float64,\n    }(),\n    concentration_lb = 1e-9,\n    concentration_ub = 100e-3,\n    T = _constants.T,\n    R = _constants.R,\n    small_flux_tol = 1e-6,\n    modifications = [],\n    ignore_reaction_ids = [],\n)\n\nPerform a max-min driving force analysis on the model, as defined by Noor, et al., \"Pathway thermodynamics highlights kinetic obstacles in central metabolism.\", PLoS computational biology, 2014.\n\nThe function uses the supplied optimizer and reaction_standard_gibbs_free_energies. Optionally, flux_solution can be used to set the directions of each reaction in model (all reactions are assumed to proceed forward and are active by default). The supplied flux_solution should be free of internal cycles i.e. thermodynamically consistent. This optional input is important if a reaction in model normally runs in reverse (negative flux). Note, reactions in flux_solution that are smaller than small_flux_tol are also ignored in the analysis function (for numerical stability).\n\nThe max-min driving force algorithm returns the Gibbs free energy of the reactions, the concentrations of metabolites and the actual maximum minimum driving force. The optimization problem solved is:\n\nmax min -ΔᵣG\ns.t. ΔᵣG = ΔrG⁰ + R T S' ln(C)\n     ΔᵣG ≤ 0\n     ln(Cₗ) ≤ ln(C) ≤ ln(Cᵤ)\n\nwhere ΔrG are the Gibbs energies dissipated by the reactions, R is the gas constant, T is the temperature, S is the stoichiometry of the model, and C is the vector of metabolite concentrations (and their respective lower and upper bounds).\n\nIn case no feasible solution exists, nothing is returned.\n\nReactions specified in ignore_reaction_ids are internally ignored when calculating the max-min driving force. This should include water and proton importers.\n\nSince biochemical thermodynamics are assumed, the proton_ids and water_ids need to be specified so that they can be ignored in the calculations. Effectively this assumes an aqueous environment at constant pH is used.\n\nconstant_concentrations is used to fix the concentrations of certain metabolites (such as CO₂). concentration_ratios is used to specify additional constraints on metabolite pair concentrations (typically, this is done with various cofactors such as the ATP/ADP ratio. For example, you can fix the concentration of ATP to be always 5× higher than of ADP by specifying Dict((\"ATP\",\"ADP\") => 5.0)\n\nconcentration_lb and concentration_ub set the Cₗ and Cᵤ in the optimization problems.\n\nT and R can be specified in the corresponding units; defaults are K and kJ/K/mol.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.max_min_driving_force_variability-Tuple{MetabolicModel, Dict{String, Float64}, Any}","page":"Analysis functions","title":"COBREXA.max_min_driving_force_variability","text":"max_min_driving_force_variability(\n    model::MetabolicModel,\n    reaction_standard_gibbs_free_energies::Dict{String,Float64},\n    optimizer;\n    workers =[myid()],\n    optimal_objective_value = nothing,\n    bounds = z -> (z, Inf),\n    flux_solution::Dict{String,Float64} = Dict{String,Float64}(),\n    proton_ids::Vector{String} = [\"h_c\", \"h_e\"],\n    water_ids::Vector{String} = [\"h2o_c\", \"h2o_e\"],\n    constant_concentrations::Dict{String,Float64} = Dict{String,Float64}(),\n    concentration_ratios::Dict{Tuple{String,String},Float64} = Dict{\n        Tuple{String,String},\n        Float64,\n    }(),\n    concentration_lb = 1e-9,\n    concentration_ub = 100e-3,\n    T = _constants.T,\n    R = _constants.R,\n    small_flux_tol = 1e-6,\n    modifications = [],\n    ignore_reaction_ids = [],\n)\n\nPerform a variant of flux variability analysis on a max min driving force type problem. Arguments are forwarded to max_min_driving_force. Calls screen internally and possibly distributes computation across workers. If optimal_objective_value = nothing, the function first performs regular max min driving force analysis to find the max min driving force of the model and sets this to optimal_objective_value. Then iteratively maximizes and minimizes the driving force across each reaction, and then the concentrations while staying close to the original max min driving force as specified in bounds.\n\nThe bounds is a user-supplied function that specifies the max min driving force bounds for the variability optimizations, by default it restricts the flux objective value to the precise optimum reached in the normal max min driving force analysis. It can return -Inf and Inf in first and second pair to remove the limit. Use gamma_bounds and objective_bounds for simple bounds.\n\nReturns a matrix of solutions to max_min_driving_force additionally constrained as described above, where the rows are in the order of the reactions and then the metabolites of the model. For the reaction rows the first column is the maximum dG of that reaction, and the second column is the minimum dG of that reaction subject to the above constraints. For the metabolite rows, the first column is the maximum concentration, and the second column is the minimum concentration subject to the constraints above.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment-Tuple{Dict{String, Float64}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment","text":"minimize_metabolic_adjustment(flux_ref_dict::Dict{String, Float64})\n\nOverload of minimize_metabolic_adjustment that works with a dictionary of fluxes.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment-Tuple{Vector{Float64}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment","text":"minimize_metabolic_adjustment(flux_ref::Vector{Float64})\n\nAn optimization model modification that implements the MOMA in minimize_metabolic_adjustment_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment_analysis-Tuple{MetabolicModel, Union{Dict{String, Float64}, Vector{Float64}}, Any}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment_analysis","text":"minimize_metabolic_adjustment_analysis(\n    model::MetabolicModel,\n    flux_ref::Union{Dict{String,Float64}, Vector{Float64}},\n    optimizer;\n    modifications = [],\n    kwargs...\n)\n\nRun minimization of metabolic adjustment (MOMA) on model with respect to flux_ref, which is a vector of fluxes in the order of reactions(model). MOMA finds the shortest Euclidian distance between flux_ref and model with modifications:\n\nmin Σᵢ (xᵢ - flux_refᵢ)²\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n\nBecause the problem has a quadratic objective, a QP solver is required. See \"Daniel, Vitkup & Church, Analysis of Optimality in Natural and Perturbed Metabolic Networks, Proceedings of the National Academy of Sciences, 2002\" for more details.\n\nAdditional arguments are passed to flux_balance_analysis.\n\nReturns an optimized model that contains the resultant nearest flux.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\nflux_ref = flux_balance_analysis_vec(model, Gurobi.Optimizer)\noptmodel = minimize_metabolic_adjustment(\n    model,\n    flux_ref,\n    Gurobi.Optimizer;\n    modifications = [change_constraint(\"PFL\"; lb=0, ub=0)], # find flux of mutant that is closest to the wild type (reference) model\n    )\nvalue.(solution[:x])  # extract the flux from the optimizer\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment_analysis_dict","text":"minimize_metabolic_adjustment_analysis_dict(model::MetabolicModel, args...; kwargs...)\n\nPerform minimization of metabolic adjustment (MOMA) and return a dictionary mapping the reaction IDs to fluxes. Arguments are forwarded to minimize_metabolic_adjustment internally.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.minimize_metabolic_adjustment_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.minimize_metabolic_adjustment_analysis_vec","text":"minimize_metabolic_adjustment_analysis_vec(model::MetabolicModel, args...; kwargs...)\n\nPerform minimization of metabolic adjustment (MOMA) and return a vector of fluxes in the same order as the reactions in model. Arguments are forwarded to minimize_metabolic_adjustment internally.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.parsimonious_flux_balance_analysis-Tuple{MetabolicModel, Any}","page":"Analysis functions","title":"COBREXA.parsimonious_flux_balance_analysis","text":"parsimonious_flux_balance_analysis(\n    model::MetabolicModel,\n    optimizer;\n    modifications = [],\n    qp_modifications = [],\n    relax_bounds=[1.0, 0.999999, 0.99999, 0.9999, 0.999, 0.99],\n)\n\nRun parsimonious flux balance analysis (pFBA) on the model. In short, pFBA runs two consecutive optimization problems. The first is traditional FBA:\n\nmax cᵀx = μ\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n\nAnd the second is a quadratic optimization problem:\n\nmin Σᵢ xᵢ²\ns.t. S x = b\n     xₗ ≤ x ≤ xᵤ\n     μ = μ⁰\n\nWhere the optimal solution of the FBA problem, μ⁰, has been added as an additional constraint. See \"Lewis, Nathan E, Hixson, Kim K, Conrad, Tom M, Lerman, Joshua A, Charusanti, Pep, Polpitiya, Ashoka D, Adkins, Joshua N, Schramm, Gunnar, Purvine, Samuel O, Lopez-Ferrer, Daniel, Weitz, Karl K, Eils, Roland, König, Rainer, Smith, Richard D, Palsson, Bernhard Ø, (2010) Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6. 390. doi: accession:10.1038/msb.2010.47\" for more details.\n\npFBA gets the model optimum by standard FBA (using flux_balance_analysis with optimizer and modifications), then finds a minimal total flux through the model that still satisfies the (slightly relaxed) optimum. This is done using a quadratic problem optimizer. If the original optimizer does not support quadratic optimization, it can be changed using the callback in qp_modifications, which are applied after the FBA. See the documentation of flux_balance_analysis for usage examples of modifications.\n\nThhe optimum relaxation sequence can be specified in relax parameter, it defaults to multiplicative range of [1.0, 0.999999, ..., 0.99] of the original bound.\n\nReturns an optimized model that contains the pFBA solution; or nothing if the optimization failed.\n\nExample\n\nmodel = load_model(\"e_coli_core.json\")\noptmodel = parsimonious_flux_balance_analysis(model, biomass, Gurobi.Optimizer)\nvalue.(solution[:x])  # extract the flux from the optimizer\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.parsimonious_flux_balance_analysis_dict-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.parsimonious_flux_balance_analysis_dict","text":"parsimonious_flux_balance_analysis_dict(model::MetabolicModel, args...; kwargs...)\n\nPerform parsimonious flux balance analysis on model using optimizer. Returns a dictionary mapping the reaction IDs to fluxes. Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\nThis function is kept for backwards compatibility, use flux_dict instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.parsimonious_flux_balance_analysis_vec-Tuple{MetabolicModel, Vararg{Any}}","page":"Analysis functions","title":"COBREXA.parsimonious_flux_balance_analysis_vec","text":"parsimonious_flux_balance_analysis_vec(model::MetabolicModel, args...; kwargs...)\n\nPerform parsimonious flux balance analysis on model using optimizer. Returns a vector of fluxes in the same order as the reactions in model. Arguments are forwarded to parsimonious_flux_balance_analysis internally.\n\nThis function is kept for backwards compatibility, use flux_vector instead.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_args-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA._screen_args","text":"_screen_args(argtuple, kwargtuple, modsname)\n\nInternal helper to check the presence and shape of modification and argument arrays in screen and pals.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_impl-Union{Tuple{MetabolicModel}, Tuple{N}, Tuple{A}, Tuple{V}} where {V<:(AbstractVector), A, N}","page":"Analysis functions","title":"COBREXA._screen_impl","text":"_screen_impl(\n    model::MetabolicModel;\n    variants::Array{V,N},\n    analysis,\n    args::Array{A,N},\n    workers = [myid()],\n)::Array where {V<:AbstractVector,A,N}\n\nThe actual implementation of screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_optmodel_item-Tuple{Any}","page":"Analysis functions","title":"COBREXA._screen_optmodel_item","text":"_screen_optmodel_item((mods, args))\n\nInternal helper for screen_optmodel_modifications that computes one item of the screening task.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_optmodel_modifications_impl-Union{Tuple{N}, Tuple{A}, Tuple{VF}, Tuple{V}, Tuple{MetabolicModel, Any}} where {V<:(AbstractVector), VF<:(AbstractVector), A, N}","page":"Analysis functions","title":"COBREXA._screen_optmodel_modifications_impl","text":"_screen_optmodel_modifications_impl(\n    model::MetabolicModel,\n    optimizer;\n    common_modifications::VF = [],\n    modifications::Array{V,N},\n    args::Array{A,N},\n    analysis::Function,\n    workers = [myid()],\n)::Array where {V<:AbstractVector,VF<:AbstractVector,A,N}\n\nThe actual implementation of screen_optmodel_modifications.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._screen_optmodel_prepare-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA._screen_optmodel_prepare","text":"_screen_optmodel_prepare(model, optimizer, common_modifications)\n\nInternal helper for screen_optmodel_modifications that creates the model and applies the modifications.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen-Tuple","page":"Analysis functions","title":"COBREXA.screen","text":"screen(\n    model::MetabolicModel;\n    variants::Array{V,N}, # defaults to an array of identities\n    analysis,\n    args::Array{A,N}, # defaults to an array of empty argument lists\n    workers = [myid()],\n)::Array where {V<:AbstractVector,A,N}\n\nTake an array of model-modifying function vectors in variants, and execute the function analysis on all variants of the model specified by variants. The computation is distributed over worker IDs in workers. If args are supplied (as an array of the same size as the variants), they are forwarded as arguments to the corresponding analysis function calls.\n\nThe array of variants must contain vectors of single-parameter functions, these are applied to model in order. The functions must not modify the model, but rather return a modified copy. The copy should be made as shallow as possible, to increase memory efficiency of the process. Variant generators that modify the argument model in-place will cause unpredictable results. Refer to the definition of screen_variant for details.\n\nThe function analysis will receive a single argument (the modified model), together with arguments from args expanded by .... Supply an array of tuples or vectors to pass in multiple arguments to each function. If the argument values should be left intact (not expanded to multiple arguments), they must be wrapped in single-item tuple or vector.\n\nThe modification and analysis functions are transferred to workers as-is; all packages required to run them (e.g. the optimization solvers) must be loaded there. Typically, you want to use the macro @everywhere using MyFavoriteSolver from Distributed package for loading the solvers.\n\nReturn value\n\nThe results of running analysis are collected in to the resulting array, in a way that preserves the shape of the variants, similarly as with pmap.\n\nThe results of analysis function must be serializable, preferably made only from pure Julia structures, because they may be transferred over the network between the computation nodes. For that reason, functions that return whole JuMP models that contain pointers to allocated C structures (such as flux_balance_analysis used with GLPK or Gurobi otimizers) will generally not work in this context.\n\nNote: this function is a thin argument-handling wrapper around _screen_impl.\n\nExample\n\nfunction reverse_reaction(i::Int)\n    (model::CoreModel) -> begin\n        mod = copy(model)\n        mod.S[:,i] .*= -1   # this is unrealistic but sufficient for demonstration\n        mod\n    end\nend\n\nm = load_model(CoreModel, \"e_coli_core.xml\")\n\nscreen(m,\n    variants = [\n        [reverse_reaction(5)],\n        [reverse_reaction(3), reverse_reaction(6)]\n    ],\n    analysis = mod -> mod.S[:,3])  # observe the changes in S\n\nscreen(m,\n    variants = [\n        [reverse_reaction(5)],\n        [reverse_reaction(3), reverse_reaction(6)]\n    ],\n    analysis = mod -> flux_balance_analysis_vec(mod, GLPK.Optimizer))\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen_optimize_objective-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA.screen_optimize_objective","text":"screen_optimize_objective(_, optmodel)::Maybe{Float64}\n\nA variant of optimize_objective directly usable in screen_optmodel_modifications.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen_optmodel_modifications-Tuple","page":"Analysis functions","title":"COBREXA.screen_optmodel_modifications","text":"screen_optmodel_modifications(\n    model::MetabolicModel,\n    optimizer;\n    common_modifications::VF = [],\n    modifications::Array{V,N}, # defaults to an array with no modifications\n    args::Array{A,N}, # defaults to an array of empty argument lists\n    analysis::Function,\n    workers = [myid()],\n)::Array where {V<:AbstractVector,VF<:AbstractVector,A,N}\n\nScreen multiple modifications of the same optimization model.\n\nThis function is potentially more efficient than screen because it avoids making variants of the model structure and remaking of the optimization model. On the other hand, modification functions need to keep the optimization model in a recoverable state (one that leaves the model usable for the next modification), which limits the possible spectrum of modifications applied.\n\nInternally, model is distributed to workers and transformed into the optimization model using make_optimization_model. common_modifications are applied to the models at that point. Next, vectors of functions in modifications are consecutively applied, and the result of analysis function called on model are collected to an array of the same extent as modifications. Calls of analysis are optionally supplied with extra arguments from args expanded with ..., just like in screen.\n\nBoth the modification functions (in vectors) and the analysis function here have 2 base parameters (as opposed to 1 with screen): first is the model (carried through as-is), second is the prepared JuMP optimization model that may be modified and acted upon. As an example, you can use modification change_constraint and analysis screen_optimize_objective.\n\nNote: This function is a thin argument-handling wrapper around _screen_optmodel_modifications_impl.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.screen_variant","page":"Analysis functions","title":"COBREXA.screen_variant","text":"screen_variant(model::MetabolicModel, variant::Vector, analysis, args = ())\n\nHelper function for screen that applies all single-argument functions in variant to the model (in order from \"first\" to \"last\"), and executes analysis on the result.\n\nCan be used to test model variants locally.\n\n\n\n\n\n","category":"function"},{"location":"functions/analysis/#COBREXA.screen_variants-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA.screen_variants","text":"screen_variants(model, variants, analysis; workers=[myid()])\n\nA shortcut for screen that only works with model variants.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.make_smoment_model-Tuple{MetabolicModel}","page":"Analysis functions","title":"COBREXA.make_smoment_model","text":"make_smoment_model(\n    model::MetabolicModel;\n    reaction_isozyme::Union{Function,Dict{String,Isozyme}},\n    gene_product_molar_mass::Union{Function,Dict{String,Float64}},\n    total_enzyme_capacity::Float64,\n)\n\nConstruct a model with a structure given by sMOMENT algorithm; returns a SMomentModel (see the documentation for details).\n\nArguments\n\nreaction_isozyme parameter is a function that returns a single Isozyme for each reaction, or nothing if the reaction is not enzymatic. If the reaction has multiple isozymes, use smoment_isozyme_speed to select the fastest one, as recommended by the sMOMENT paper.\ngene_product_molar_mass parameter is a function that returns a molar mass of each gene product as specified by sMOMENT.\ntotal_enzyme_capacity is the maximum \"enzyme capacity\" in the model.\n\nAlternatively, all function arguments also accept dictionaries that are used to provide the same data lookup.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#Sampling","page":"Analysis functions","title":"Sampling","text":"","category":"section"},{"location":"functions/analysis/","page":"Analysis functions","title":"Analysis functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"sampling\", file), readdir(\"../src/analysis/sampling\"))","category":"page"},{"location":"functions/analysis/#COBREXA._affine_hit_and_run_chain-NTuple{8, Any}","page":"Analysis functions","title":"COBREXA._affine_hit_and_run_chain","text":"_affine_hit_and_run_chain(warmup, lbs, ubs, iters, seed)\n\nInternal helper function for computing a single affine hit-and-run chain.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.affine_hit_and_run-Tuple{MetabolicModel, Matrix{Float64}}","page":"Analysis functions","title":"COBREXA.affine_hit_and_run","text":"function affine_hit_and_run(\n    m::MetabolicModel,\n    warmup_points::Matrix{Float64};\n    sample_iters = 100 .* (1:5),\n    workers = [myid()],\n    chains = length(workers),\n    seed = rand(Int),\n)\n\nRun a hit-and-run style sampling that starts from warmup_points and uses their affine combinations for generating the run directions to sample the space delimited by lbs and ubs.  The reaction rate vectors in warmup_points should be organized in columns, i.e. warmup_points[:,1] is the first set of reaction rates.\n\nThere are total chains of hit-and-run runs, each on a batch of size(warmup_points, 2) points. The runs are scheduled on workers, for good load balancing chains should be ideally much greater than length(workers).\n\nEach run continues for maximum(sample_iters) iterations; the numbers in sample_iters represent the iterations at which the whole \"current\" batch of points is collected for output. For example, sample_iters=[1,4,5] causes the process run for 5 iterations, returning the sample batch that was produced by 1st, 4th and last (5th) iteration.\n\nReturns a matrix of sampled reaction rates (in columns), with all collected samples horizontally concatenated. The total number of samples (columns) will be size(warmup_points,2) * chains * length(sample_iters).\n\nExample\n\nusing COBREXA\nusing Tulip\n\nmodel = load_model(StandardModel, model_path)\n\nwarmup, lbs, ubs = warmup_from_variability(model, Tulip.Optimizer, 100)\nsamples = affine_hit_and_run(warmup, lbs, ubs, sample_iters = 1:3)\n\n# convert the result to flux (for models where the distinction matters):\nfluxes = reaction_flux(model)' * samples\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._maximize_warmup_reaction-Tuple{Any, Any, Any}","page":"Analysis functions","title":"COBREXA._maximize_warmup_reaction","text":"_maximize_warmup_reaction(opt_model, rid, ret)\n\nA helper function for finding warmup points from reaction variability.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.warmup_from_variability","page":"Analysis functions","title":"COBREXA.warmup_from_variability","text":"warmup_from_variability(\n    model::MetabolicModel,\n    optimizer,\n    n_points::Int;\n    kwargs...\n)\n\nGenerates FVA-like warmup points for samplers, by selecting random points by minimizing and maximizing reactions. Can not return more than 2 times the number of reactions in the model.\n\n\n\n\n\n","category":"function"},{"location":"functions/analysis/#COBREXA.warmup_from_variability-2","page":"Analysis functions","title":"COBREXA.warmup_from_variability","text":"function warmup_from_variability(\n    model::MetabolicModel,\n    optimizer,\n    min_reactions::Vector{Int}=1:n_reactions(model),\n    max_reactions::Vector{Int}=1:n_reactions(model);\n    modifications = [],\n    workers::Vector{Int} = [myid()],\n)::Matrix{Float64}\n\nGenerate FVA-like warmup points for samplers, by minimizing and maximizing the specified reactions. The result is returned as a matrix, each point occupies as single column in the result.\n\n!!! warning Limited effect of modifications in warmup_from_variability     Modifications of the optimization model applied in modifications     parameter that change the semantics of the model have an effect on the     warmup points, but do not automatically carry to the subsequent sampling.     Users are expected to manually transplant any semantic changes to the     actual sampling functions, such as affine_hit_and_run.\n\n\n\n\n\n","category":"function"},{"location":"functions/analysis/#Analysis-modifiers","page":"Analysis functions","title":"Analysis modifiers","text":"","category":"section"},{"location":"functions/analysis/","page":"Analysis functions","title":"Analysis functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"analysis\", \"modifications\", file), readdir(\"../src/analysis/modifications\"))","category":"page"},{"location":"functions/analysis/#COBREXA.add_crowding_constraints-Tuple{Dict{Int64, Float64}}","page":"Analysis functions","title":"COBREXA.add_crowding_constraints","text":"add_crowding_constraints(weights::Dict{Int64, Float64})\n\nAdds a molecular crowding constraint to the optimization problem: ∑ wᵢ × vᵢ ≤ 1 where wᵢ is a weight and vᵢ is a flux index in the model's reactions specified in weights as vᵢ => wᵢ pairs.\n\nSee Beg, Qasim K., et al. \"Intracellular crowding defines the mode and sequence of substrate uptake by Escherichia coli and constrains its metabolic activity.\" Proceedings of the National Academy of Sciences 104.31 (2007) for more details.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.add_crowding_constraints-Tuple{Dict{String, Float64}}","page":"Analysis functions","title":"COBREXA.add_crowding_constraints","text":"add_crowding_constraints(weights::Dict{String, Float64})\n\nVariant of add_crowding_constraints that takes a dictinary of reactions ids instead of reaction indices mapped to weights.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_constraint-Tuple{String}","page":"Analysis functions","title":"COBREXA.change_constraint","text":"change_constraint(id::String; lb=nothing, ub=nothing)\n\nChange the lower and upper bounds (lb and ub respectively) of reaction id if supplied.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_objective-Tuple{Union{String, Vector{String}}}","page":"Analysis functions","title":"COBREXA.change_objective","text":"change_objective(new_objective::Union{String,Vector{String}}; weights=[], sense=MAX_SENSE)\n\nModification that changes the objective function used in a constraint based analysis function.  new_objective can be a single reaction identifier, or an array of reactions identifiers.\n\nOptionally, the objective can be weighted by a vector of weights, and a optimization sense can be set to either MAX_SENSE or MIN_SENSE.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.constrain_objective_value-Tuple{Any}","page":"Analysis functions","title":"COBREXA.constrain_objective_value","text":"constrain_objective_value(tolerance)\n\nLimit the objective value to tolerance-times the current objective value, as with objective_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA._do_knockout-Tuple{MetabolicModel, Any, Vector{String}}","page":"Analysis functions","title":"COBREXA._do_knockout","text":"_do_knockout(model::MetabolicModel, opt_model)\n\nInternal helper for knockouts on generic MetabolicModels. This can be overloaded so that the knockouts may work differently (more efficiently) with other models.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.knockout-Tuple{String}","page":"Analysis functions","title":"COBREXA.knockout","text":"knockout(gene_id::String)\n\nA helper variant of knockout for a single gene.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.knockout-Tuple{Vector{String}}","page":"Analysis functions","title":"COBREXA.knockout","text":"knockout(gene_ids::Vector{String})\n\nA modification that zeroes the bounds of all reactions that would be knocked out by the combination of specified genes (effectively disabling the reactions).\n\nA slightly counter-intuitive behavior may occur if knocking out multiple genes: Because this only changes the reaction bounds, multiple gene knockouts must be specified in a single call to knockout, because the modifications have no way to remember which genes are already knocked out and which not.\n\nIn turn, having a reaction that can be catalyzed either by Gene1 or by Gene2, specifying modifications = [knockout([\"Gene1\", \"Gene2\"])] does indeed disable the reaction, but modifications = [knockout(\"Gene1\"), knockout(\"Gene2\")] does not disable the reaction (although reactions that depend either only on Gene1 or only on Gene2 are disabled).\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.add_loopless_constraints-Tuple{}","page":"Analysis functions","title":"COBREXA.add_loopless_constraints","text":"add_loopless_constraints(;\n    max_flux_bound = _constants.default_reaction_bound,\n    strict_inequality_tolerance = _constants.loopless_strict_inequality_tolerance,\n)\n\nAdd quasi-thermodynamic constraints to the model to ensure that no thermodynamically infeasible internal cycles can occur. Adds the following constraints to the problem:\n\n-max_flux_bound × (1 - yᵢ) ≤ xᵢ ≤ max_flux_bound × yᵢ\n-max_flux_bound × yᵢ + strict_inequality_tolerance × (1 - yᵢ) ≤ Gᵢ\nGᵢ ≤ -strict_inequality_tolerance × yᵢ + max_flux_bound × (1 - yᵢ)\nNᵢₙₜ' × G = 0\nyᵢ ∈ {0, 1}\nGᵢ ∈ ℝ\ni ∈ internal reactions\nNᵢₙₜ is the nullspace of the internal stoichiometric matrix\n\nNote, this modification introduces binary variables, so an optimization solver capable of handing mixed integer problems needs to be used. The arguments max_flux_bound and strict_inequality_tolerance implement the \"big-M\" method of indicator constraints.\n\nFor more details about the algorithm, see Schellenberger, Lewis, and, Palsson. \"Elimination of thermodynamically infeasible loops in steady-state metabolic models.\", Biophysical journal, 2011.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.add_moment_constraints-Tuple{Dict{String, Float64}, Float64}","page":"Analysis functions","title":"COBREXA.add_moment_constraints","text":"add_moment_constraints(\n    ksas::Dict{String,Float64},\n    protein_mass_fraction::Float64\n)\n\nA modification that adds enzyme capacity constraints to the problem using a modified version of the MOMENT algorithm. Requires specific activities, ksas [mmol product/g enzyme/h], for each reaction. Proteins are identified by their associated gene IDs. Adds a variable vector y to the problem corresponding to the protein concentration [g enzyme/gDW cell] of each gene product in the order of genes(model). The total protein concentration [g protein/gDW cell] is constrained to be less than or equal to the protein_mass_fraction. Reaction flux constraints are changed to the MOMENT constraints (see below) for all reactions that have a gene reaction rule, otherwise the flux bounds are left unaltered.\n\nSee Adadi, Roi, et al. \"Prediction of microbial growth rate versus biomass yield by a metabolic network with kinetic parameters.\" PLoS computational biology (2012) for more details of the original algorithm.\n\nHere, a streamlined version of the algorithm is implemented to ensure that the correct units are used. Specifically, this implementation uses specific activities instead of kcats. Thus, for a reaction that can only proceed forward and is catalyzed by protein a, the flux x[i] is bounded by x[i] <= ksas[i] * y[a]. If isozymes a or b catalyse the reaction, then x[i] <= ksas[i] * (y[a] + y[b]). If a reaction is catalyzed by subunits a and b then x[i] <= ksas[i] * min(y[a], y[b]). These rules are applied recursively in the model like in the original algorithm. The enzyme capacity constraint is then implemented by sum(y) ≤ protein_mass_fraction. The major benefit of using ksas instead of kcats is that active site number and unit issues are prevented.\n\nExample\n\nflux_balance_analysis(\n    ...,\n    modifications = [ add_moment_constraints(my_kcats, 0.6) ],\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_optimizer-Tuple{Any}","page":"Analysis functions","title":"COBREXA.change_optimizer","text":"change_optimizer(optimizer)\n\nChange the JuMP optimizer used to run the optimization.\n\nThis may be used to try different approaches for reaching the optimum, and in problems that may require different optimizers for different parts, such as the parsimonious_flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_optimizer_attribute-Tuple{Any, Any}","page":"Analysis functions","title":"COBREXA.change_optimizer_attribute","text":"change_optimizer_attribute(attribute_key, value)\n\nChange a JuMP optimizer attribute. The attributes are optimizer-specific, refer to the JuMP documentation and the documentation of the specific optimizer for usable keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.change_sense-Tuple{Any}","page":"Analysis functions","title":"COBREXA.change_sense","text":"change_sense(objective_sense)\n\nChange the objective sense of optimization. Possible arguments are MOI.MAX_SENSE and MOI.MIN_SENSE.\n\nIf you want to change the objective and sense at the same time, use change_objective instead to do both at once.\n\n\n\n\n\n","category":"method"},{"location":"functions/analysis/#COBREXA.silence","page":"Analysis functions","title":"COBREXA.silence","text":"silence\n\nModification that disable all output from the JuMP optimizer (shortcut for set_silent from JuMP).\n\n\n\n\n\n","category":"function"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/5_basic_stdmodel_construction.jl\"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Model-construction-and-modification","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"COBREXA can load models stored in .mat, .json, and .xml formats; and convert these into StandardModels. However, it is also possible to construct models from scratch, and modify existing models. This will be demonstrated here.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Model-construction","page":"Model construction and modification","title":"Model construction","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"In COBREXA, model construction is primarily supported through StandardModels. To begin, create an empty StandardModel.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"using COBREXA\n\nmodel = StandardModel(\"FirstModel\") # assign model id = \"FirstModel\"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"Next, genes, metabolites and reactions need to be added to the model.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-genes-to-the-model","page":"Model construction and modification","title":"Add genes to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"gene_list = [Gene(string(\"g\", num)) for num = 1:8]","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"warning: Warning: Don't accidentally overwrite the generic accessors\nIt may be tempting to call a variable genes, metabolites, or   reactions. However, these names conflict with generic accessors   functions and will create problems downstream.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"add_genes!(model, gene_list)","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-metabolites-to-the-model","page":"Model construction and modification","title":"Add metabolites to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"metabolite_list = [Metabolite(string(\"m\", num)) for num = 1:4]\n\nmetabolite_list[1].formula = \"C6H12O6\" # can edit metabolites, etc. directly\n\nadd_metabolites!(model, metabolite_list)","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Add-reactions-to-the-model","page":"Model construction and modification","title":"Add reactions to the model","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"There are two ways to create and add reactions to a model. These are using functions, or macros.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"r_m1 = Reaction(\"EX_m1\", Dict(\"m1\" => -1.0), :bidirectional) # exchange reaction: m1 <-> (is the same as m1 ↔ nothing)\nr1 = Reaction(\"r1\", Dict(\"m1\" => -1.0, \"m2\" => 1.0), :forward)\nr1.grr = [[\"g1\", \"g2\"], [\"g3\"]] # add some gene reaction rules\nr2 = Reaction(\"r2\", Dict(\"m2\" => -1.0, \"m1\" => 1.0), :reverse)\nr3 = Reaction(\"r3\", Dict(\"m2\" => -1.0, \"m3\" => 1.0), :bidirectional)\n\nadd_reactions!(model, [r1, r2, r3, r_m1]) # function approach\n\nm1 = metabolite_list[1]\nm2 = metabolite_list[2]\nm3 = metabolite_list[3]\nm4 = metabolite_list[4]\n\n@add_reactions! model begin # macro approach\n    \"r4\", m2 → m4, 0, 1000\n    \"r_m3\", m3 ↔ nothing, -1000, 1000\n    \"r_m4\", m4 → nothing\n    \"r5\", m4 → m2\nend\n\nmodel.reactions[\"r4\"].grr = [[\"g5\"], [\"g6\", \"g7\"], [\"g8\"]]","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"note: Note: Writing unicode arrows\nThe reaction arrows can be easily written by using the LaTeX completions built into Julia shell (and many Julia-compatible editors). You can type:→ as \\rightarrow (press Tab to complete)\n← as \\leftarrow\n↔ as \\leftrightarrow","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"The constructed model can now be inspected.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"model","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/#Modifying-existing-models","page":"Model construction and modification","title":"Modifying existing models","text":"","category":"section"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"It is also possible to modify a model by deleting certain genes. This is simply achieved by calling remove_genes!.","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"remove_genes!(model, [\"g1\", \"g2\"]; knockout_reactions = false)\nmodel","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"","category":"page"},{"location":"notebooks/5_basic_stdmodel_construction/","page":"Model construction and modification","title":"Model construction and modification","text":"This page was generated using Literate.jl.","category":"page"},{"location":"advanced/1_variants/#Exploring-many-model-variants","page":"Exploring many model variants","title":"Exploring many model variants","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"A major goal of COBREXA.jl is to make exploring of many model variants easy and fast.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"One main concept that can be utilized for doing that is implemented in the function screen, which takes your model, a list of model variants that you want to explore by some specified analysis, and schedules the analysis of the model variants parallely on the available distributed workers.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"In its most basic form, the \"screening\" may use the slightly simplified variant of screen that is called screen_variants, which works as follows:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"m = load_model(StandardModel, \"e_coli_core.json\")\n\nscreen_variants(\n    m,    # the model for screening\n    [\n        [],    # a variant with no modifications\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0)],  # disable CO2 transport\n        [with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable O2 transport\n        [with_changed_bound(\"CO2t\", lb = 0, ub = 0), with_changed_bound(\"O2t\", lb = 0, ub = 0)],  # disable both transports\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The call specifies a model (the m that we have loaded) that is being tested, then a vector of model variants to be created and tested, and then the analysis that is being run on each variant – in this case, we find an optimal steady state of each of the variants, and check out the biomass production rate at that state. In this particular case, we are checking what will be the effect of disabling combinations of CO2 transport and O2 transport in the cells. For that, we get the following result:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"4-element Vector{Float64}:\n 0.8739215022678488\n 0.46166961413944896\n 0.21166294973372135\n 0.21114065173865518","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The numbers are the biomass production rates for the specified variants. We can see that disabling O2 transport really does not help the organism much.","category":"page"},{"location":"advanced/1_variants/#Variant-specification","page":"Exploring many model variants","title":"Variant specification","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"In the above example, we have specified 4 variants, thus the analysis returned 4 different results that correspond with the specifications. Let us have a look at the precise format of the specification and result.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Importantly, the variants argument is of type Array{Vector{Any}}, meaning that it can be an array of any dimensionality that contains vectors. Each of the vectors specifies precisely one variant, possibly with more modifications applied to the model in sequence.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"For example:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"[] specifies no modifications at all\n[with_changed_bound(\"CO2t\", lb=0, ub=10)] limits the CO2 transport\n[with_changed_bound(\"CO2t\", lb=0, ub=2), with_changed_bound(\"O2t\", lb=0, ub=100)] severely limits the CO2 transport and slightly restricts the transport of O2","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"note: Variants are single-parameter model-transforming functions\nBecause the variants are just generators of single parameter functions that take the model and return its modified version, you can also use identity to specify a variant that does nothing – [identity] is perfectly same as []","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The shape of the variants array is important too, because it is precisely retained in the result (just as with pmap). If you pass in a matrix of variants, you will receive a matrix of analysis results of the same size. That can be exploited for easily exploring many combinations of possible model properties. Let's try exploring a \"cube\" of possible restricted reactions:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"using IterTools # for cartesian products\n\nres = screen_variants(m,\n    [\n        # for each variant we restricts 2 reactions\n        [with_changed_bound(r1, lb=-3, ub=3), with_changed_bound(r2, lb=-1, ub=1)]\n\n        # the reaction pair will be chosen from a cartesian product\n        for (r1,r2) in product(\n            [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"], # of this set of transport reactions\n            [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"], # and this set of exchanges\n        )\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"As a result, we will receive a full matrix of the biomass productions:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"4×4 Matrix{Float64}:\n 0.407666  0.454097  0.240106  0.183392\n 0.407666  0.485204  0.24766   0.183392\n 0.314923  0.319654  0.24766   0.183392\n 0.407666  0.485204  0.24766   0.183392","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Notably, this shows that O2 transport and NH4 exchange may be serious bottlenecks for biomass production.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"For clarity, you may always annotate the result by zipping it with the specification structure you have used and collecting the data:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"collect(zip(\n    product(\n        [\"H2Ot\", \"CO2t\", \"O2t\", \"NH4t\"],\n        [\"EX_h2o_e\", \"EX_co2_e\", \"EX_o2_e\", \"EX_nh4_e\"],\n    ),\n    res,\n))","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"...which gives the following annotated result:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"4×4 Matrix{Tuple{Tuple{String, String}, Float64}}:\n ((\"H2Ot\", \"EX_h2o_e\"), 0.407666)  ((\"H2Ot\", \"EX_co2_e\"), 0.454097)  ((\"H2Ot\", \"EX_o2_e\"), 0.240106)  ((\"H2Ot\", \"EX_nh4_e\"), 0.183392)\n ((\"CO2t\", \"EX_h2o_e\"), 0.407666)  ((\"CO2t\", \"EX_co2_e\"), 0.485204)  ((\"CO2t\", \"EX_o2_e\"), 0.24766)   ((\"CO2t\", \"EX_nh4_e\"), 0.183392)\n ((\"O2t\", \"EX_h2o_e\"), 0.314923)   ((\"O2t\", \"EX_co2_e\"), 0.319654)   ((\"O2t\", \"EX_o2_e\"), 0.24766)    ((\"O2t\", \"EX_nh4_e\"), 0.183392)\n ((\"NH4t\", \"EX_h2o_e\"), 0.407666)  ((\"NH4t\", \"EX_co2_e\"), 0.485204)  ((\"NH4t\", \"EX_o2_e\"), 0.24766)   ((\"NH4t\", \"EX_nh4_e\"), 0.183392)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"This may be easily used for e.g. scrutinizing all possible reaction pairs, to find the ones that are redundant and not.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"tip: Notebook available\nA notebook is available that demonstrates the screening on a larger scale.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"There are many other variant \"specifications\" to choose from. You may use with_added_reactions, with_removed_reactions, with_removed_metabolites, and others. Function reference contains a complete list; as a convention, names of the specifications all start with with_.","category":"page"},{"location":"advanced/1_variants/#Writing-custom-variant-functions","page":"Exploring many model variants","title":"Writing custom variant functions","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"It is actually very easy to create custom specifications that do any modification that you can implement, to be later used with screen_variants and screen.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Generally, the \"specifications\" are supposed to return a function that creates a modified copy of the model. The copy of the model may be shallow, but the functions should always prevent modifying the original model structure – screen is keeping a single copy of the original model at each worker to prevent unnecessary bulk data transport, and if that is changed in-place, all following analyses of the model will work on inconsistent data, usually returning wrong results (even randomly changing ones, because of the asynchronous nature of screen execution).","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Despite of that, writing a modification is easy. The simplest modification that \"does nothing\" (isomorphic to standard identity) can be formatted as follows:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"with_no_change = model -> model","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The modifications may change the model, provided it is copied properly. The following modification will remove a reaction called \"O2t\", effectively removing the possibility to transport oxygen. We require a specific type of model where this change is easy to perform (generally, not all variants may be feasible on all model types).","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"with_disabled_oxygen_transport = (model::StandardModel) -> begin\n\n    # make \"as shallow as possible\" copy of the `model`.\n    # Utilizing `deepcopy` is also possible, but inefficient.\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n\n    # remove the O2 transport from the model copy\n    delete!(new_model.reactions, \"O2t\")\n\n    return new_model #return the newly created variant\nend","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Finally, the whole definition may be parametrized as a normal function. The following variant removes any user-selected reaction:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"with_disabled_reaction(reaction_id) = (model::StandardModel) -> begin\n    new_model = copy(model)\n    new_model.reactions = copy(model.reactions)\n    delete!(new_model.reactions, reaction_id) # use the parameter from the specification\n    return new_model\nend","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"In turn, these variants can be used in screen_variants just as we used with_changed_bound above:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"screen_variants(\n    m,    # the model for screening\n    [\n        [with_no_change],\n        [with_disabled_oxygen_transport],\n        [with_disabled_reaction(\"NH4t\")],\n    ],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"That should get you the results for all new variants of the model:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"3-element Vector{Float64}:\n 0.8739215022674809\n 0.21166294865468896\n 1.2907224478973395e-15","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"warning: Custom variants with distributed processing\nIf using distributed evaluation, remember the variant-generating functions need to be defined on all used workers (generating the variants in parallel on the workers allows COBREXA to run the screening process very efficiently, without unnecessary sending of bulk model data). Prefixing the definition with @everywhere is usually sufficient for that purpose.","category":"page"},{"location":"advanced/1_variants/#Passing-extra-arguments-to-the-analysis-function","page":"Exploring many model variants","title":"Passing extra arguments to the analysis function","text":"","category":"section"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Some analysis functions may take additional arguments, which you might want to vary for the analysis. modifications argument of flux_balance_analysis_dict is one example of such argument, allowing you to specify details of the optimization procedure.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"screen function allows you to do precisely that – apart from variants, you may also specify an array of args of the same shape as variants, the entries of which will get passed together with the generated model variants to your specified analysis function. If either of the arguments is missing (or set to nothing), it is defaulted to \"no modifications\" or \"no arguments\".","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"The arguments must be tuples; you may need to make 1-tuples from your data (e.g. using (value,)) if you want to pass just a single argument.","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"Let's try to use that functionality for trying to find a sufficient amount of iterations needed for Tulip solver to find a feasible solution:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"screen(m,\n    args = [(i,) for i in 5:15],  # the iteration counts, packed in 1-tuples\n    analysis = (m,a) -> # `args` elements get passed as the extra parameter here\n        flux_balance_analysis_vec(m,\n            Tulip.Optimizer;\n            modifications=[change_optimizer_attribute(\"IPM_IterationsLimit\", a)],\n        ),\n)","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"From the result, we can see that Tulip would need at least 14 iterations to find a feasible region:","category":"page"},{"location":"advanced/1_variants/","page":"Exploring many model variants","title":"Exploring many model variants","text":"11-element Vector{Union{Nothing, Vector{Float64}}}:\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n nothing\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]\n [7.47738193404817, 1.8840414375838503e-8, 4.860861010127701, -16.023526104614593, … ]","category":"page"},{"location":"tutorials/3_hpc/#Distributed-processing-and-HPC-environments","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Distributed processing in Julia is represented mainly by the package Distributed.jl.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"COBREXA.jl is able to utilize this existing system to almost transparently run the large parallelizable analyses on multiple CPU cores and multiple computers connected through the network. Ultimately, the approach scales to thousands of computing nodes in large HPC facilities.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Here, we give a short overview of how to work in the distributed environment and utilize the resources for COBREXA.jl analyses.","category":"page"},{"location":"tutorials/3_hpc/#Starting-the-distributed-workers","page":"Distributed processing and HPC environments","title":"Starting the distributed workers","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"COBREXA.jl follows the structure imposed by the Distributed package: You operate a main (usually called \"master\") computation node, connect to multiple other computers and start worker Julia processes there, and distribute the workload across this cluster.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To start, you need to load the package and add a few processes. This starts 5 processes locally:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using Distributed\naddprocs(5)","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"note: `Distributed.jl` installation\nDistributed.jl usually comes pre-installed with Julia distribution, but you may still need to \"enable\" it by typing ] add Distributed.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"You may check that the workers are really there, using workers(). In this case, it should give you a vector of worker IDs, very likely equal to [2,3,4,5,6].","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"If you have compute resources available via a network, you may connect these as well, provided you have a secure shell (ssh) access to them. You will likely want to establish a key-based authentication (refer to ssh documentation) to make the connection easier.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With shell, check that you can ssh to a remote node and run Julia there:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"user@pc> ssh server\n...\nuser@server> julia\n...\njulia> _","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"top: Running shell commands from Julia\nIf you don't want to quit your Julia session to try out the ssh connection from the shell, press ; in the Julia prompt on the beginning of the line. The interpreter will execute your next line as a shell command.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"If this works for you, you can add some workers that run on the server from your Julia shell running on your pc. For example, the following starts 20 workers on the remote server and 10 workers on your friend's computer called joe_pc:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"addprocs([('server', 20), ('joe_pc', 10)])","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With this, you can schedule various computation on the workers; see the Julia manual of Distributed for basic details. You may try various convenience packages, such as DistributedArrays.jl and DistributedData.jl, to process any data in a distributed fashion.","category":"page"},{"location":"tutorials/3_hpc/#Running-a-distributed-analysis","page":"Distributed processing and HPC environments","title":"Running a distributed analysis","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"While not all COBREXA functions may be parallelized naturally, these that do will accept a special workers argument that specifies a list of worker IDs where the computation should be distributed. For the value, you can specify your desired worker IDs manually (e.g. [2,3,4]), or simply use workers().","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"For example, flux_variability_analysis can naturally parallelize the computation of all reactions's minima and maxima to finish the computation faster. To enable the parallelization, you first need to make sure that all workers have loaded both the COBREXA package and the optimizer:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using COBREXA, GLPK, Distributed\naddprocs(10)                       # add any kind and number of processes here\n@everywhere using COBREXA, GLPK    # loads the necessary packages on all workers","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"When the package is loaded and precompiled everywhere, you may load your model and run the FVA with the workers parameter:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"model = load_model(\"e_coli_core.xml\")\nresult = flux_variability_analysis(model, GLPK.Optimizer; workers=workers())","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"With the extra computing capacity from N workers available, the FVA should be computed roughly N-times faster.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"note: Distribution and parallelization overhead\nCommunication of the workers with your Julia shell is not free. If the task that you are parallelizing is small and the model structure is very large, the distributed computation will actually spend most computation time just distributing the large model to the workers, and almost no time in executing the small parallel task. In such case, the performance will not improve by adding additional resources. You may want to check that the computation task is sufficiently large before investing the extra resources into the distributed execution. Amdahl's and Gustafson's laws can give you a better overview of the consequences of this overhead.","category":"page"},{"location":"tutorials/3_hpc/#Interacting-with-HPC-schedulers","page":"Distributed processing and HPC environments","title":"Interacting with HPC schedulers","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Many researchers have access to institutional HPC facilities that allow time-sharing of the capacity of a large computer cluster between many researchers. Julia and COBREXA.jl work well within this environment; but your programs require some additional customization to be able to find and utilize the resources available from the HPC.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"In our case, this reduces to a relatively complex task: You need to find out how many resources were allocated for your task, and you need to add the remote workers precisely at places that were allocated for your. Fortunately, the package ClusterManagers.jl can do precisely that.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"For simplicily, we will assume that your HPC is scheduled by Slurm.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Adding of the workers from Slurm is done as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"you import the ClusterManagers package\nyou find how many processes to spawn from the environment from SLURM_NTASKS environment variable\nyou use the function addprocs_slurm to precisely connect to your allocated computational resources","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"The Julia script that does a parallel analysis may then start as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"using COBREXA, Distributed, ClusterManagers\n\navailable_workers = parse(Int, ENV[\"SLURM_NTASKS\"])\n\naddprocs_slurm(available_workers)\n\n...\nresult = flux_variability_analysis(...; workers=workers())\n...","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"After adding the Slurm workers, you may continue as if the workers were added using normal addprocs, and (for example) run the flux_variability_analysis as shown above.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"tip: What about the other HPC schedulers?\nClusterManagers.jl supports many other common HPC scheduling systems, including LFS, Sun Grid, SGE, PBS, and Scyld, in a way almost identical to Slurm. See the package documentation for details.","category":"page"},{"location":"tutorials/3_hpc/#Wrapping-your-script-in-a-Slurm-job","page":"Distributed processing and HPC environments","title":"Wrapping your script in a Slurm job","text":"","category":"section"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To be able to submit your script for later processing using the sbatch Slurm command, you need to wrap it in a small \"batch\" script that tells Slurm how many resources the process needs.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Assuming you have a Julia computation script written down in myJob.jl and saved on your HPC cluster's access node, the corresponding Slurm batch script (let's call it myJob.sbatch) may look as follows:","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"#!/bin/bash -l\n#SBATCH -n 100           # the job will require 100 individual workers\n#SBATCH -c 1             # each worker will sit on a single CPU\n#SBATCH -t 30            # the whole job will take less than 30 minutes\n#SBATCH -J myJob         # the name of the job\n\nmodule load lang/Julia   # this is usually required to make Julia available to your job\n\njulia myJob.jl","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"To run the computation, simply run sbatch myJob.sbatch on the access node. The job will be scheduled and eventually executed. You may watch sacct and squeue in the meantime, to see the progress.","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"Remember that you need to explicitly save the result of your Julia script computation to files, to be able to retrieve them later. Standard outputs of the jobs are often mangled and discarded. If you still want to collect the standard output, you may change the last line of the batch script to","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"julia myJob.jl > myJob.log","category":"page"},{"location":"tutorials/3_hpc/","page":"Distributed processing and HPC environments","title":"Distributed processing and HPC environments","text":"and collect the output from the log later. This is convenient especially if logging various computation details using the @info and similar macros.","category":"page"},{"location":"functions/#Types-and-functions","page":"Contents","title":"Types and functions","text":"","category":"section"},{"location":"functions/","page":"Contents","title":"Contents","text":"Pages = joinpath.(\"functions\", filter(x -> endswith(x, \".md\"), readdir(\"functions\")))\nDepth = 2","category":"page"},{"location":"functions/reconstruction/#Model-construction-functions","page":"Model construction functions","title":"Model construction functions","text":"","category":"section"},{"location":"functions/reconstruction/#Functions-for-changing-the-models","page":"Model construction functions","title":"Functions for changing the models","text":"","category":"section"},{"location":"functions/reconstruction/","page":"Model construction functions","title":"Model construction functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"reconstruction\", file), readdir(\"../src/reconstruction\"))","category":"page"},{"location":"functions/reconstruction/#COBREXA.add_reaction!-Tuple{CoreModel, Reaction}","page":"Model construction functions","title":"COBREXA.add_reaction!","text":"add_reaction!(model::CoreModel, rxn::Reaction)\n\nAdd rxn to model. The model must already contain the metabolites used by rxn in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions!-Tuple{CoreModel, Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.add_reactions!","text":"add_reactions!(model::CoreModel, rxns::Vector{Reaction})\n\nAdd rxns to model efficiently. The model must already contain the metabolites used by rxns in the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractMatrix{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{String}, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    Sp::MatType,\n    b::VecType,\n    c::VecType,\n    xl::VecType,\n    xu::VecType,\n    rxns::StringVecType,\n    mets::StringVecType;\n    check_consistency = false,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractMatrix{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    Sp::MatType,\n    b::VecType,\n    c::VecType,\n    xl::VecType,\n    xu::VecType;\n    check_consistency = false,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractVector{Float64}, AbstractVector{Float64}, AbstractFloat, AbstractFloat, AbstractFloat, String, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    s::VecType,\n    b::VecType,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat,\n    rxn::String,\n    mets::K;\n    check_consistency = false,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, AbstractVector{Float64}, AbstractVector{Float64}, AbstractFloat, AbstractFloat, AbstractFloat}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModel,\n    s::VecType,\n    b::VecType,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat;\n    check_consistency = false,\n)\n\nAdd reaction(s) to a CoreModel model m.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModel, CoreModel}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m1::CoreModel, m2::CoreModel; check_consistency = false)\n\nAdd all reactions from m2 to m1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModel,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModel,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModel,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModel,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::CoreModel, rxn_idx::Int)\n\nChange objective function of a CoreModel to a single 1 at reaction index rxn_idx.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(model::CoreModel, rxn_id::String)\n\nChange objective function of a CoreModel to a single 1 at the given reaction ID.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, Vector{Int64}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(\n    model::CoreModel,\n    rxn_idxs::Vector{Int};\n    weights = ones(length(rxn_idxs)),\n)\n\nChange the objective to reactions at given indexes, optionally specifying their weights in the same order. By default, all set weights are 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreModel, Vector{String}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(\n    model::CoreModel,\n    rxn_ids::Vector{String};\n    weights = ones(length(rxn_ids)),\n)\n\nChange objective of given reaction IDs, optionally specifying objective weights in the same order as rxn_ids. By default, all set weights are 1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModel, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreModel, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModel, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreModel, metabolite_id::String)\n\nRemove metabolite from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModel, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModel, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModel, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreModel, reaction_id::String)\n\nRemove reaction from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreModel, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModel, reaction_idx::Int)\n\nRemove reaction from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreModel, reaction_id::String)\n\nRemove reaction from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModel, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreModel, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModel, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.verify_consistency-Union{Tuple{K}, Tuple{B}, Tuple{V}, Tuple{M}, Tuple{CoreModel, M, V, V, B, B, K, K, Any, Any}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, B<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.verify_consistency","text":"verify_consistency(\n    m::CoreModel,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::B,\n    xu::B,\n    names::K,\n    mets::K,\n    new_reactions,\n    new_metabolites,\n) where {M<:MatType,V<:VecType,B<:VecTypeK<:StringVecType}\n\nCheck the consistency of given reactions with existing reactions in m.\n\nTODO: work in progress, doesn't return consistency status.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints!-Tuple{CoreCoupling, AbstractVector{Float64}, AbstractFloat, AbstractFloat}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints!","text":"add_coupling_constraints!(\n    m::CoreCoupling,\n    c::VecType,\n    cl::AbstractFloat,\n    cu::AbstractFloat,\n)\n\nOverload for adding a single coupling constraint.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints!-Union{Tuple{V}, Tuple{CoreCoupling, AbstractMatrix{Float64}, V, V}} where V<:AbstractVector{Float64}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints!","text":"add_coupling_constraints!(\n    m::CoreCoupling,\n    C::MatType,\n    cl::V,\n    cu::V,\n) where {V<:VecType}\n\nIn-place add a single coupling constraint in form\n\n    cₗ ≤ C x ≤ cᵤ\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints-Tuple{CoreCoupling, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints","text":"add_coupling_constraints(m::CoreCoupling, args...)\n\nAdd constraints of the following form to CoreCoupling and return the modified model.\n\nThe arguments are same as for in-place add_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_coupling_constraints-Tuple{CoreModel, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.add_coupling_constraints","text":"add_coupling_constraints(m::CoreModel, args...)\n\nAdd coupling constraints to a plain CoreModel (returns a CoreModelCoupled).\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{CoreModelCoupled, CoreModel}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(m1::CoreModelCoupled, m2::CoreModel; check_consistency = false)\n\nAdd all reactions from m2 to m1.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V2}, Tuple{V1}, Tuple{CoreModelCoupled, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat, String, K}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    s::V1,\n    b::V2,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat,\n    rxn::String,\n    mets::K;\n    check_consistency = false,\n) where {V1<:VecType,V2<:VecType,K<:StringVecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{K}, Tuple{V}, Tuple{M}, Tuple{CoreModelCoupled, M, V, V, V, V, K, K}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}, K<:AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::V,\n    xu::V,\n    rxns::K,\n    mets::K;\n    check_consistency = false,\n) where {M<:MatType,V<:VecType,K<:StringVecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{V2}, Tuple{V1}, Tuple{CoreModelCoupled, V1, V2, AbstractFloat, AbstractFloat, AbstractFloat}} where {V1<:AbstractVector{Float64}, V2<:AbstractVector{Float64}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    s::V1,\n    b::V2,\n    c::AbstractFloat,\n    xl::AbstractFloat,\n    xu::AbstractFloat;\n    check_consistency = false,\n) where {V1<:VecType,V2<:VecType}\n\nAdd reaction(s) to a CoreModelCoupled model m.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Union{Tuple{V}, Tuple{M}, Tuple{CoreModelCoupled, M, V, V, V, V}} where {M<:AbstractMatrix{Float64}, V<:AbstractVector{Float64}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(\n    m::CoreModelCoupled,\n    Sp::M,\n    b::V,\n    c::V,\n    xl::V,\n    xu::V;\n    check_consistency = false,\n) where {M<:MatType,V<:VecType}\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreCoupling,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::CoreCoupling,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreCoupling,\n    rxn_idx::Int;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, 123, lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::CoreCoupling,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreCoupling,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::CoreCoupling,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreCoupling,\n    rxn_idxs::AbstractVector{Int64};\n    lower = (nothing for _ = rxn_idxs),\n    upper = (nothing for _ = rxn_idxs),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [123, 234], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::CoreCoupling,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_coupling_bounds!-Union{Tuple{V}, Tuple{CoreCoupling, Vector{Int64}}} where V<:AbstractVector{Float64}","page":"Model construction functions","title":"COBREXA.change_coupling_bounds!","text":"change_coupling_bounds!(\n    model::CoreCoupling,\n    constraints::Vector{Int};\n    cl::V = Float64[],\n    cu::V = Float64[],\n) where {V<:VecType}\n\nChange the lower and/or upper bounds (cl and cu) for the given list of coupling constraints.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{CoreCoupling, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(\n    model::CoreCoupling,\n    args...;\n    kwargs...,\n)\n\nForwards arguments to change_objective! of the internal model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_coupling_constraints!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_coupling_constraints!","text":"remove_coupling_constraints!(m::CoreCoupling, constraint::Int)\n\nRemoves a single coupling constraints from a CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_coupling_constraints!-Tuple{CoreCoupling, Vector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_coupling_constraints!","text":"remove_coupling_constraints!(m::CoreCoupling, constraints::Vector{Int})\n\nRemoves a set of coupling constraints from a CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_coupling_constraints-Tuple{CoreCoupling, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_coupling_constraints","text":"remove_coupling_constraints(m::CoreCoupling, args...)\n\nRemove coupling constraints from the linear model, and return the modified model. Arguments are the same as for in-place version remove_coupling_constraints!.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreCoupling, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::CoreCoupling, metabolite_id::String)\n\nRemove metabolite from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreCoupling, metabolite_idx::Int)\n\nRemove metabolite from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::CoreCoupling, metabolite_id::String)\n\nRemove metabolite from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreCoupling, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::CoreCoupling, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreCoupling, metabolite_idxs::AbstractVector{Int64})\n\nRemove metabolites from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::CoreCoupling, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreCoupling, reaction_idx::Int)\n\nRemove reaction from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::CoreCoupling, reaction_id::String)\n\nRemove reaction from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreCoupling, Int64}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreCoupling, reaction_idx::Int)\n\nRemove reaction from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{CoreCoupling, String}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::CoreCoupling, reaction_id::String)\n\nRemove reaction from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreCoupling, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::CoreCoupling, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreCoupling in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreCoupling, AbstractVector{Int64}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreCoupling, reaction_idxs::AbstractVector{Int64})\n\nRemove reactions from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{CoreCoupling, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::CoreCoupling, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type CoreCoupling and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA._Stoichiometry","page":"Model construction functions","title":"COBREXA._Stoichiometry","text":"A small helper type for constructing reactions inline\n\n\n\n\n\n","category":"type"},{"location":"functions/reconstruction/#Base.:+-Tuple{Union{Metabolite, COBREXA._Stoichiometry}, Union{Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"Base.:+","text":"metabolite1 + metabolite2\n\nAdd 2 groups of Metabolites together to form reactions inline. Use with +, *, → and similar operators.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.:←-Tuple{Union{Nothing, Metabolite, COBREXA._Stoichiometry}, Union{Nothing, Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"COBREXA.:←","text":"substrates ← products\n\nMake a reverse-only Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.:→-Tuple{Union{Nothing, Metabolite, COBREXA._Stoichiometry}, Union{Nothing, Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"COBREXA.:→","text":"substrates → products\n\nMake a forward-only Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.:↔-Tuple{Union{Nothing, Metabolite, COBREXA._Stoichiometry}, Union{Nothing, Metabolite, COBREXA._Stoichiometry}}","page":"Model construction functions","title":"COBREXA.:↔","text":"substrates ↔ products\n\nMake a bidirectional (reversible) Reaction from substrates and products.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.add_reactions","text":"add_reactions(model::Serialized, ...)\n\nCalls add_reactions of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(model::Serialized, ...)\n\nCalls change_bound of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(model::Serialized, ...)\n\nCalls change_bounds of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::Serialized, ...)\n\nCalls remove_metabolite of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::Serialized, ...)\n\nCalls remove_metabolites of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::Serialized, ...)\n\nCalls remove_reaction of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{Serialized, Vararg{Any}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::Serialized, ...)\n\nCalls remove_reactions of the internal serialized model type. Returns the modified un-serialized model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.unwrap_serialized-Tuple{Serialized}","page":"Model construction functions","title":"COBREXA.unwrap_serialized","text":"unwrap_serialized(model::Serialized)\n\nReturns the model stored in the serialized structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_gene!-Tuple{StandardModel, Gene}","page":"Model construction functions","title":"COBREXA.add_gene!","text":"add_gene!(model::StandardModel, genes::Gene)\n\nAdd gene to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_genes!-Tuple{StandardModel, Vector{Gene}}","page":"Model construction functions","title":"COBREXA.add_genes!","text":"add_genes!(model::StandardModel, genes::Vector{Gene})\n\nAdd genes to model based on gene id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_metabolite!-Tuple{StandardModel, Metabolite}","page":"Model construction functions","title":"COBREXA.add_metabolite!","text":"add_metabolite!(model::StandardModel, met::Metabolite)\n\nAdd met to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_metabolites!-Tuple{StandardModel, Vector{Metabolite}}","page":"Model construction functions","title":"COBREXA.add_metabolites!","text":"add_metabolites!(model::StandardModel, mets::Vector{Metabolite})\n\nAdd mets to model based on metabolite id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reaction!-Tuple{StandardModel, Reaction}","page":"Model construction functions","title":"COBREXA.add_reaction!","text":"add_reaction!(model::StandardModel, rxn::Reaction)\n\nAdd rxn to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_reactions!-Tuple{StandardModel, Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.add_reactions!","text":"add_reactions!(model::StandardModel, rxns::Vector{Reaction})\n\nAdd rxns to model based on reaction id.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.change_bound!","text":"change_bound!(\n    model::StandardModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model in-place.\n\nExample\n\nnew_model = change_bound!(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bound-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.change_bound","text":"change_bound(\n    model::StandardModel,\n    rxn_id::String;\n    lower = nothing,\n    upper = nothing,\n)\n\nChange the specified reaction flux bound in the model and return the modified model.\n\nExample\n\nchange_bound(model, \"ReactionB\", lower=-21.15, upper=42.3)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds!-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds!","text":"change_bounds!(\n    model::StandardModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model in-place.\n\nExample\n\nnew_model = change_bounds!(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_bounds-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.change_bounds","text":"change_bounds(\n    model::StandardModel,\n    rxn_ids::AbstractVector{String};\n    lower = (nothing for _ = rxn_ids),\n    upper = (nothing for _ = rxn_ids),\n)\n\nChange the specified reaction flux bounds in the model and return the modified model.\n\nExample\n\nchange_bounds(model, [\"ReactionA\", \"ReactionC\"], lower=[-2.1, -50.05], upper=[4.2, 100.1])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.change_objective!-Tuple{StandardModel, Vector{String}}","page":"Model construction functions","title":"COBREXA.change_objective!","text":"change_objective!(\n    model::StandardModel,\n    rxn_ids::Vector{String};\n    weights = ones(length(rxn_ids)),\n)\n\nChange the objective for model to reaction(s) with rxn_ids, optionally specifying their weights. By default, assume equal weights. If no objective exists in model, sets objective.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_gene!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_gene!","text":"remove_gene!(\n    model::StandardModel,\n    id::Vector{String};\n    knockout_reactions::Bool = false,\n)\n\nRemove gene with id from model. If knockout_reactions is true, then also constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_gene!(model, \"g1\")\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_genes!-Tuple{StandardModel, Vector{String}}","page":"Model construction functions","title":"COBREXA.remove_genes!","text":"remove_genes!(\n    model::StandardModel,\n    ids::Vector{String};\n    knockout_reactions::Bool = false,\n)\n\nRemove all genes with ids from model. If knockout_reactions is true, then also constrain reactions that require the genes to function to carry zero flux.\n\nExample\n\nremove_genes!(model, [\"g1\", \"g2\"])\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite!","text":"remove_metabolite!(model::StandardModel, metabolite_id::String)\n\nRemove metabolite from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolite-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_metabolite","text":"remove_metabolite(model::StandardModel, metabolite_id::String)\n\nRemove metabolite from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites!-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites!","text":"remove_metabolites!(model::StandardModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_metabolites-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_metabolites","text":"remove_metabolites(model::StandardModel, metabolite_ids::AbstractVector{String})\n\nRemove metabolites from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction!-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction!","text":"remove_reaction!(model::StandardModel, reaction_id::String)\n\nRemove reaction from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reaction-Tuple{StandardModel, String}","page":"Model construction functions","title":"COBREXA.remove_reaction","text":"remove_reaction(model::StandardModel, reaction_id::String)\n\nRemove reaction from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions!-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions!","text":"remove_reactions!(model::StandardModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type StandardModel in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.remove_reactions-Tuple{StandardModel, AbstractVector{String}}","page":"Model construction functions","title":"COBREXA.remove_reactions","text":"remove_reactions(model::StandardModel, reaction_ids::AbstractVector{String})\n\nRemove reactions from the model of type StandardModel and return the modified model.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.@add_reactions!-Tuple{Symbol, Expr}","page":"Model construction functions","title":"COBREXA.@add_reactions!","text":"@add_reactions!(model::Symbol, ex::Expr)\n\nShortcut to add multiple reactions and their lower and upper bounds\n\nCall variants\n\n@add_reactions! model begin\n    reaction_name, reaction\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound\nend\n\n@add_reactions! model begin\n    reaction_name, reaction, lower_bound, upper_bound\nend\n\nExamples\n\n@add_reactions! model begin\n    \"v1\", nothing → A, 0, 500\n    \"v2\", A ↔ B + C, -500\n    \"v3\", B + C → nothing\nend\n\n\n\n\n\n","category":"macro"},{"location":"functions/reconstruction/#COBREXA.add_community_objective!-Tuple{CoreModel, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.add_community_objective!","text":"add_community_objective!(\n    community::CoreModel,\n    objective_mets_weights::Dict{String, Float64};\n    objective_id = \"community_biomass\",\n)\n\nAdd an objective column to the community model with optional id objective_id. Supply a dictionary mapping the string names of the objective metabolites to their weights in objective_mets_weights. Note, the weights are negated inside the function so that positive weights are seen as reagents/substrates, NOT products in the reaction equation.\n\nExample\n\nadd_community_objective!(model, Dict(\"met1\"=>1.0, \"met2\"=>2.0))\n\nSee also: update_community_objective!\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_community_objective!-Tuple{StandardModel, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.add_community_objective!","text":"add_community_objective!(\n    community::StandardModel,\n    objective_mets_weights::Dict{String, Float64};\n    objective_id = \"community_biomass\"\n)\n\nVariant of [add_community_objective!] that takes a StandardModel community model as input.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_model_with_exchanges!-Tuple{StandardModel, MetabolicModel, Dict{String, String}}","page":"Model construction functions","title":"COBREXA.add_model_with_exchanges!","text":"add_model_with_exchanges!(\n    community::StandardModel,\n    model::MetabolicModel,\n    exchange_rxn_mets::Dict{String,String};\n    model_name = \"unknown_species\",\n    biomass_id = nothing,\n)\n\nThe StandardModel variant of add_model_with_exchanges, but is in-place.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_model_with_exchanges-Tuple{CoreModel, MetabolicModel, Dict{String, String}}","page":"Model construction functions","title":"COBREXA.add_model_with_exchanges","text":"add_model_with_exchanges(\n    community::CoreModel,\n    model::MetabolicModel,\n    exchange_rxn_mets::Dict{String,String};\n    model_name = \"unknown_species\",\n    biomass_id = nothing,\n)\n\nAdd model to community, which is a pre-existing community model with exchange reactions and metabolites in the dictionary exchange_rxn_mets. The model_name is appended to each reaction and metabolite, see join_with_exchanges. If biomass_id is specified then a biomass metabolite for model is also added to the resulting model. The column corresponding to the biomass_id reaction then produces this new biomass metabolite with unit coefficient. The exchange reactions and metabolites in exchange_rxn_mets must already exist in community. Always returns a new community model because it is more efficient than resizing all the matrices.\n\nNo in-place variant for CoreModels exists yet.\n\nExample\n\ncommunity = add_model_with_exchanges(community,\n    model,\n    exchange_rxn_mets;\n    model_name=\"species_2\",\n    biomass_id=\"BIOMASS_Ecoli_core_w_GAM\")\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.add_model_with_exchanges-Tuple{StandardModel, MetabolicModel, Dict{String, String}}","page":"Model construction functions","title":"COBREXA.add_model_with_exchanges","text":"add_model_with_exchanges(\n    community::StandardModel,\n    model::MetabolicModel,\n    exchange_rxn_mets::Dict{String,String};\n    model_name = \"unknown_species\",\n    biomass_id = nothing,\n)\n\nThe StandardModel variant of add_model_with_exchanges. Makes a deepcopy of community and calls the inplace variant of this function on that copy.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.join_with_exchanges-Union{Tuple{M}, Tuple{Type{CoreModel}, Vector{M}, Dict{String, String}}} where M<:MetabolicModel","page":"Model construction functions","title":"COBREXA.join_with_exchanges","text":"join_with_exchanges(\n    ::Type{CoreModel},\n    models::Vector{M},\n    exchange_rxn_mets::Dict{String,String};\n    biomass_ids = String[],\n    model_names = String[],\n) where {M<:MetabolicModel}\n\nReturn a CoreModel representing the community model of models joined through their exchange reactions and metabolites in the dictionary exchange_rxn_mets, which maps exchange reactions to their associated metabolite. These exchange reactions and metabolites link model metabolites to environmental metabolites and reactions. Optionally specify model_names to append a specific name to each reaction and metabolite of an organism for easier reference (default is species_i for each model index i in models). Note, the bounds of the environmental variables are all set to zero. Thus, to run a simulation you need to constrain them appropriately. All the other bounds are inherited from the models used to construct the community model.\n\nIf biomass_ids is supplied, then a community model is returned that has an extra reaction added to the end of the stoichiometric matrix (last column) that can be assigned as the objective reaction. It also creates biomass \"metabolites\" that can be used in this objective reaction. In the returned mode, these biomass metabolites are produced by the reaction corresponding to biomass_ids in each model respectively. Note, this reaction is unspecified, further action needs to be taken to specify it, e.g. assign weights to the last column of the stoichiometric matrix in the rows corresponding to the biomass metabolites.\n\nTo further clarify how this join works. Suppose you have 2 organisms with stoichiometric matrices S₁ and S₂ and you want to link them with exchange_rxn_mets = Dict(er₁ => em₁, er₂ => em₂, er₃ => em₃, ...). Then a new community stoichiometric matrix is constructed that looks like this:\n\n            _      er₁  er₂  er₃  ...  b_\n           |S₁                           |\n           |   S₂                        |\n        em₁|                             |\nS   =   em₂|                             |\n        em₃|                             |\n        ...|                             |\n        bm₁|                             |\n        bm₂|_                           _|\n\n\nThe exchange reactions in each model get linked to environmental metabolites, emᵢ, and these get linked to environmental exchanges, erᵢ. These erᵢ behave like normal single organism exchange reactions. When biomass_ids are supplied, each model's biomass reaction produces a pseudo-metabolite (bmᵢ). These can be weighted in column b, called the community_biomass reaction in the community model, if desired. Refer to the tutorial if this is unclear.\n\nExample\n\nm1 = load_model(core_model_path)\nm2 = load_model(CoreModel, core_model_path)\n\n# need to list ALL the exchanges that will form part of the entire model\nexchange_rxn_mets = Dict(k => first(keys(reaction_stoichiometry(m1, ex_rxn)))\n    for filter(looks_like_exchange_reaction, reactions(m1)))\n\nbiomass_ids = [\"BIOMASS_Ecoli_core_w_GAM\", \"BIOMASS_Ecoli_core_w_GAM\"]\n\ncommunity = join_with_exchanges(\n    CoreModel,\n    [m1, m2],\n    exchange_rxn_mets;\n    biomass_ids = biomass_ids,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.join_with_exchanges-Union{Tuple{M}, Tuple{Type{StandardModel}, Vector{M}, Dict{String, String}}} where M<:MetabolicModel","page":"Model construction functions","title":"COBREXA.join_with_exchanges","text":"join_with_exchanges(\n    ::Type{StandardModel},\n    models::Vector{M},\n    exchange_rxn_mets::Dict{String,String};\n    biomass_ids = [],\n    model_names = [],\n)::StandardModel where {M<:MetabolicModel}\n\nA variant of join_with_exchanges that returns a StandardModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.update_community_objective!-Tuple{CoreModel, String, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.update_community_objective!","text":"update_community_objective!(\n    community::CoreModel,\n    objective_id::String,\n    objective_mets_weights::Dict{String, Float64}\n)\n\nUpdate the weights for the objective column with id objective_id in community using objective_mets_weights, which maps metabolite ids to weights. The current weights are reset to 0 before being updated to the supplied weights. Note, the weights are negated inside the function so that the objective metabolites are seen as reagents/substrates, NOT products in the reaction equation.\n\nExample\n\nupdate_community_objective!(model, \"community_biomass\", Dict(\"met1\"=>1.0, \"met2\"=>2.0))\n\nSee also: add_community_objective!\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.update_community_objective!-Tuple{StandardModel, String, Dict{String, Float64}}","page":"Model construction functions","title":"COBREXA.update_community_objective!","text":"update_community_objective!(\n    community::StandardModel,\n    objective_id::String,\n    objective_mets_weights::Dict{String, Float64}\n)\n\nVariant of [update_community_objective!] that takes a StandardModel community model as input.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_gecko-Tuple{}","page":"Model construction functions","title":"COBREXA.with_gecko","text":"with_gecko(; kwargs...)\n\nSpecifies a model variant which adds extra semantics of the Gecko algorithm, giving a GeckoModel. The arguments are forwarded to make_gecko_model. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_smoment-Tuple{}","page":"Model construction functions","title":"COBREXA.with_smoment","text":"with_smoment(; kwargs...)\n\nSpecifies a model variant which adds extra semantics of the sMOMENT algorithm, giving a SMomentModel. The arguments are forwarded to make_smoment_model. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA._universal_stoichiometry-Tuple{Vector{Reaction}, Vector{String}}","page":"Model construction functions","title":"COBREXA._universal_stoichiometry","text":"_universal_stoichiometry(\n    universal_reactions::Vector{Reaction},\n    mids,\n)\n\nA helper function that constructs the stoichiometric matrix of a set of universal_reactions. The order of the metabolites is determined with mids, so that this stoichiometric matrix can be combined with another one.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfill_minimum_reactions-Tuple{MetabolicModel, Vector{Reaction}, Any}","page":"Model construction functions","title":"COBREXA.gapfill_minimum_reactions","text":"function gapfill_minimum_reactions(\n    model::MetabolicModel,\n    universal_reactions::Vector{Reaction},\n    optimizer;\n    objective_bounds = (_constants.tolerance, _constants.default_reaction_bound),\n    maximum_new_reactions = 5,\n    weights = fill(1.0, length(universal_reactions)),\n    modifications = [],\n)\n\nFind a minimal set of reactions from universal_reactions that should be added to model so that the model has a feasible solution with bounds on its objective function given in objective_bounds.  Weights of the added reactions may be specified in weights to prefer adding reactions with lower weights.\n\nInternally, this builds and solves a mixed integer program, following the method of Reed et al. (Reed, Jennifer L., et al. \"Systems approach to refining genome annotation.\" Proceedings of the National Academy of Sciences (2006)).\n\nThe function returns a solved JuMP optimization model, with the boolean reaction inclusion indicators in variable vector y. Use gapfilled_mask or gapfilled_rids to collect the reaction information in Julia datatypes.\n\nTo reduce the uncertainty in the MILP solver (and likely reduce the complexity), you may put a limit on the size of the added reaction set in maximum_new_reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfilled_mask-Tuple{Any}","page":"Model construction functions","title":"COBREXA.gapfilled_mask","text":"gapfilled_mask(opt_model::BitVector)\n\nGet a BitVector of added reactions from the model solved by gapfill_minimum_reactions. The bit indexes correspond to the indexes of universal_reactions given to the gapfilling function. In case the model is not solved, this returns nothing.\n\nExample\n\ngapfill_minimum_reactions(myModel, myReactions, Tulip.Optimizer) |> gapfilled_mask\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfilled_rids-Tuple{Any, Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.gapfilled_rids","text":"gapfilled_rids(opt_model, universal_reactions::Vector{Reaction})::Vector{String}\n\nUtility to extract a short vector of IDs of the reactions added by the gapfilling algorithm. Use with opt_model returned from gapfill_minimum_reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.gapfilled_rids-Tuple{Vector{Reaction}}","page":"Model construction functions","title":"COBREXA.gapfilled_rids","text":"gapfilled_rids(universal_reactions::Vector{Reaction})\n\nOverload of gapfilled_rids that can be piped easily.\n\nExample\n\ngapfill_minimum_reactions(myModel, myReactions, Tulip.Optimizer) |> gapfilled_rids(myReactions)\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#Variant-specifiers","page":"Model construction functions","title":"Variant specifiers","text":"","category":"section"},{"location":"functions/reconstruction/","page":"Model construction functions","title":"Model construction functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"reconstruction\", \"modifications\", file), readdir(\"../src/reconstruction/modifications\"))","category":"page"},{"location":"functions/reconstruction/#COBREXA.with_added_reactions-Tuple","page":"Model construction functions","title":"COBREXA.with_added_reactions","text":"with_added_reactions(args...; kwargs...)\n\nSpecifies a model variant with reactions added. Forwards the arguments to add_reactions. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_changed_bound-Tuple","page":"Model construction functions","title":"COBREXA.with_changed_bound","text":"with_changed_bound(args...; kwargs...)\n\nSpecifies a model variant that has a new bound set. Forwards arguments to change_bound. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_changed_bounds-Tuple","page":"Model construction functions","title":"COBREXA.with_changed_bounds","text":"with_changed_bounds(args...; kwargs...)\n\nSpecifies a model variant that has new bounds set. Forwards arguments to change_bounds. Intended for usage with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_metabolite-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_metabolite","text":"with_removed_metabolite(args...; kwargs...)\n\nSpecifies a model variant without a certain metabolite. Forwards arguments to remove_metabolite. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_metabolites-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_metabolites","text":"with_removed_metabolites(args...; kwargs...)\n\nPlural version of with_removed_metabolite, calls remove_metabolites internally.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_reaction-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_reaction","text":"with_removed_reaction(args...; kwargs...)\n\nSpecifies a model variant without a certain reaction. Forwards arguments to remove_reaction. Intended to be used with screen.\n\n\n\n\n\n","category":"method"},{"location":"functions/reconstruction/#COBREXA.with_removed_reactions-Tuple","page":"Model construction functions","title":"COBREXA.with_removed_reactions","text":"with_removed_reactions(args...; kwargs...)\n\nPlural version of with_removed_reaction, calls remove_reactions internally.\n\n\n\n\n\n","category":"method"},{"location":"advanced/#COBREXA-Advanced-tutorials","page":"All advanced tutorials","title":"COBREXA Advanced tutorials","text":"","category":"section"},{"location":"advanced/","page":"All advanced tutorials","title":"All advanced tutorials","text":"Pages = joinpath.(\"advanced\", filter(x -> endswith(x, \".md\"), readdir(\"advanced\")))\nDepth = 2","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/4_basic_core_coupled_usage.jl\"","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Basic-usage-of-CoreModel-and-CoreModelCoupled","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"In this tutorial we will introduce COBREXA's CoreModel and CoreModelCoupled. We will use E. coli's toy model to start with.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Loading-a-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Loading a CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"model = load_model(CoreModel, \"e_coli_core.xml\") # we specifically want to load a CoreModel from the model file","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Basic-analysis-on-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic analysis on CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"As before, for optimization based analysis we need to load an optimizer. Here we will use Tulip.jl to optimize the linear programs of this tutorial. Refer to the constraint-based analysis basics tutorial if you are confused by any functions in this section.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"All the normal analysis functions work on CoreModel, due to it also having the same generic accessor interface as all the other model types.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"using Tulip\n\ndict_sol = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"),\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12),\n        change_constraint(\"R_EX_o2_e\"; lb = 0, ub = 0),\n    ],\n)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#Structure-of-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Structure of CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"CoreModel is a special COBREXA type that is optimized for large scale analysis of large models. It stores data in a sparse format where possible.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"fieldnames(CoreModel)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"model.S","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/#CoreModelCoupled-adds-coupling-constraints-to-CoreModel","page":"Basic usage of CoreModel and CoreModelCoupled","title":"CoreModelCoupled adds coupling constraints to CoreModel","text":"","category":"section"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"CoreModelCoupled extends CoreModel by adding coupling constraints.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"fieldnames(CoreModelCoupled)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"In short, coupling constraints can be used to ensure that fluxes scale with the growth rate (μ) of a model. This reduces the impact of biologically infeasible cycles from occurring. Here we will model coupling constraints by assuming that they have the form: -γ ≤ vᵢ/μ  ≤ γ, where γ is the ratio between each individual flux (vᵢ) in the model and the growth rate.","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"gamma = 40 # arbitrary\n\nnr = n_reactions(model) # number of reactions\nbiomass_index = first(indexin([\"R_BIOMASS_Ecoli_core_w_GAM\"], reactions(model)))\n\nusing LinearAlgebra, SparseArrays\n\nCf = sparse(1.0I, nr, nr)\nCf[:, biomass_index] .= -gamma\nCb = sparse(1.0I, nr, nr)\nCb[:, biomass_index] .= gamma\nC = [Cf; Cb] # coupling constraint matrix\n\nclb = spzeros(2 * nr)\nclb[1:nr] .= -1000.0\ncub = spzeros(2 * nr)\ncub[nr+1:end] .= 1000\n\ncmodel = CoreModelCoupled(model, C, clb, cub)","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"d = flux_balance_analysis_dict(model, Tulip.Optimizer)\nd[\"R_BIOMASS_Ecoli_core_w_GAM\"]","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"dc = flux_balance_analysis_dict(cmodel, Tulip.Optimizer)\ndc[\"R_BIOMASS_Ecoli_core_w_GAM\"]","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"","category":"page"},{"location":"notebooks/4_basic_core_coupled_usage/","page":"Basic usage of CoreModel and CoreModelCoupled","title":"Basic usage of CoreModel and CoreModelCoupled","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/4_modifying/#Modifying-and-saving-the-models","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Making a small modification to the model and reanalyzing them is often a useful way to explore how the constraints work together, and to inspect the degrees of freedom in the model.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With COBREXA.jl, you have two main choices of making model modifications:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"you can manually change the model structures (i.e. permanently change the data in of your model variable)\nyou can use special arguments of analysis functions that allow you to make the modifications in a declarative way and \"on the fly\", without having to manually interact with the model","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"tip: Notebook available\nThe available notebooks demonstrate model export and serialization and various model modifications (1, 2, 3).","category":"page"},{"location":"tutorials/4_modifying/#Manual-modifications","page":"Modifying and saving the models","title":"Manual modifications","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Certain model types, including CoreModel and StandardModel, are built from mutable structs that you are free to modify as you want.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"CoreModel consists of sparse matrices and vectors that describe the model precisely. For example, modifying a bound of the reaction is as simple as writing to the .xl or .xu (lower and upper bound for x) vectors in the structure:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"using COBREXA\nm = load_model(CoreModel, \"e_coli_core.xml\")\nm.xl[3] = 0.0","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"The available field names can be listed using e.g. fieldnames(CoreModel), or more conveniently by employing the completion in the shell:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"julia> m.   # press [Tab]\nS    b     c     mets  rxns  xl    xu","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With CoreModel, you may need to find the proper metabolites by identifier. For that, you may examine the reactions and metabolites of the model, e.g. using","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"indexin([\"M_nadh_c\", \"M_co2_e\"], metabolites(m))","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...which will return the numeric indexes of NADH and CO₂ metabolites. These can be used to, e.g., change the \"balance\" of the metabolites in the model:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m.b[64] = -1      # model will be losing 1 flux unit of CO₂","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or to modify existing reaction (here with index 5) directly in stoichiometry matrix:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m.S[5,8] = -1\nm.S[5,64] = 1","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"While this works well if you are used to working with matrix-like representations of the model, it is not really convenient if you want to change the reactions and models in an easy way. StandardModel is structured in a much more user-friendly way, which makes the manual modifications easier.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"In particular, StandardModel consists of dictionaries of Reaction, Metabolite and Gene objects that may be modified and indexed directly using their names. That way, the above modifications may be written in a cleaner, semantic and declarative fashion, as follows:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = load_model(StandardModel, \"e_coli_core.xml\")\nm.reactions[\"R_TPI\"].lb = 0.0                         # change lower bound of the reaction to 0\nm.reactions[\"R_GLNS\"].metabolites[\"M_nadh_c\"] = -1.0  # update stoichiometry\nm.reactions[\"R_GLNS\"].metabolites[\"M_co2_e\"] = 1.0\n...","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"There are other functions that may be used to change the StandardModel in a more systematic way. See the documentation of add_reaction!, add_metabolite!, add_gene!, remove_reaction!, remove_metabolite!, [ remove_gene!, and the Model construction functions reference section for more examples.","category":"page"},{"location":"tutorials/4_modifying/#Analysis-modifiers","page":"Modifying and saving the models","title":"Analysis modifiers","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Some analysis functions, including flux_balance_analysis and flux_variability_analysis, accept a special argument modifications, which is a list of descriptions of small changes that should be applied to the model before modification.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"These include:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"change_objective that sets a new optimization objective\nchange_optimizer that chooses a different JuMP.jl optimizer for the analysis\nchange_optimizer_attribute that can set various optimizer parameters\nchange_constraint that changes the flux bounds of a reaction\nknockout that disables reactions that depend on genes\nadd_crowding_constraints that adds crowding constraints to the model\nadd_moment_constraints that adds moment constraints to the model\nadd_loopless_constraints that adds loopless (thermodynamic) constraints to the model","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"This way, you can easily check out the model state when maximizing the rate of \"TALA\" (transadenolase A) reaction:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = load_model(StandardModel, \"e_coli_core.xml\")\nflux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[change_objective(\"R_TALA\")])","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or knock out a gene combination that disables the transadenolase A completely (see m.reactions[\"R_TALA\"].grr):","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"flux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[knockout([\"G_b0008\", \"G_b2464\"])])","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...or do both at once– knock out some other genes, and try to maximize the transadenolase A reaction rate:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"flux_balance_analysis_dict(\n  m, GLPK.Optimizer;\n  modifications=[\n    knockout([\"G_s0001\"]),\n    change_objective(\"R_TALA\"),\n  ])","category":"page"},{"location":"tutorials/4_modifying/#Exporting-the-modified-models-in-native-formats","page":"Modifying and saving the models","title":"Exporting the modified models in native formats","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Manually modified models can be exported in standard formats so that they can be examined in other environments, or just made accessible for publication.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"COBREXA.jl supports export of MATLAB-like and JSON models. Simply use save_model:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"save_model(m, \"myModel.json\")\nsave_model(m, \"myModel.mat\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"The function automatically guesses the appropriate model format to write into the file from the file extension. If required, you can choose the model format manually by using save_json_model and save_mat_model.","category":"page"},{"location":"tutorials/4_modifying/#Using-Serialization-for-quick-and-efficient-model-storage","page":"Modifying and saving the models","title":"Using Serialization for quick & efficient model storage","text":"","category":"section"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"If you save the model \"just for yourself\", such as for the use in an immediately following analysis, it may be inconvenient (and unnecessarily inefficient) to encode and decode the models to and from the external format. Moreover, certain model types (such as CoreModelCoupled) cannot be fully represented in all model formats, thus increasing the chance for accidental data loss.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"Instead of that, we recommend using the Serialization package. It provides a straightforward way to save any Julia data structure to the disk, using a very efficient data format that can be written to and read from the disk very quickly.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"With any model in m, you can write it to disk as follows:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"using Serialization\nopen(f -> serialize(f, m), \"myModel\", \"w\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"...and read it back with:","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"m = deserialize(\"myModel\")","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"One great advantage of Serialization is speed – models with millions of reactions are usually loaded and saved with minimal overhead in less than a second.","category":"page"},{"location":"tutorials/4_modifying/","page":"Modifying and saving the models","title":"Modifying and saving the models","text":"warning: Limits of `Serialization`\nSerialized models are great for quickly exchanging data objects between analysis steps. The avoided need for re-encoding can save you a great deal of analysis time that can be used for better purposes. Despite that, do not rely on the stability of the serialized format – it often changes between Julia versions, and the data stored in one version may not open easily after an upgrade. In short, use serialized data within one workflow, and use standard and stable external formats for publishing and storing the data beyond the scope of a single analysis workflow.","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/7_community_model.jl\"","category":"page"},{"location":"notebooks/7_community_model/#Building-and-analysing-a-small-community-model","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Here we will use COBREXA to build and analyze a small community model consisting of three E. coli mutants using the CoreModel. We will use an objective function that enforces equal growth rates.","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"We will first construct a community of only two mutants to illustrate the effect of the community biomass objective function. Then we will add a third member that has a lethal knockout. Due to the bounds on the exchange reactions these three models are incapable of sharing resources - hence the maximum growth rate will be zero. By changing the bounds we can allow resource sharing, \"saving\" the community.","category":"page"},{"location":"notebooks/7_community_model/#Load-the-base-model","page":"Building and analysing a small community model","title":"Load the base model","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n\nusing COBREXA\nusing Tulip","category":"page"},{"location":"notebooks/7_community_model/#Load-the-models-and-inspect-fba-solutions","page":"Building and analysing a small community model","title":"Load the models and inspect fba solutions","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"base_model = load_model(CoreModel, \"e_coli_core.json\") # base from from which the knockouts will be constructed\n\ncytbd_knockout_model = remove_reaction(base_model, \"CYTBD\") # knockout the CYTBD (cytochrome oxidase) reaction\nsol = flux_balance_analysis_dict(cytbd_knockout_model, Tulip.Optimizer)\nsol[\"BIOMASS_Ecoli_core_w_GAM\"] # Cytochrome oxidase knockout μ (growth rate)","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"atps4r_knockout_model = remove_reaction(base_model, \"ATPS4r\") # knockout the ATP synthase reaction\nsol = flux_balance_analysis_dict(atps4r_knockout_model, Tulip.Optimizer)\nsol[\"BIOMASS_Ecoli_core_w_GAM\"] # ATP synthase knockout μ","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"eno_knockout_model = remove_reaction(base_model, \"ENO\") # knockout the enolase reaction\nsol = flux_balance_analysis_dict(eno_knockout_model, Tulip.Optimizer)\nsol[\"BIOMASS_Ecoli_core_w_GAM\"] # Enolase knockout μ, cannot grow by itself","category":"page"},{"location":"notebooks/7_community_model/#Build-a-community-model-of-the-cytochrome-oxidase-knockout-and-the-ATP-synthase-knockout-models","page":"Building and analysing a small community model","title":"Build a community model of the cytochrome oxidase knockout and the ATP synthase knockout models","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"ex_rxn_mets = Dict(\n    ex_rxn => first(keys(reaction_stoichiometry(base_model, ex_rxn))) for\n    ex_rxn in filter(looks_like_exchange_reaction, reactions(base_model))\n) # identify exchange reactions heuristically","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"model_names = [\"cytbd_ko\", \"atps4r_ko\"]\ncommunity_model = join_with_exchanges(\n    CoreModel,\n    [cytbd_knockout_model, atps4r_knockout_model],\n    ex_rxn_mets;\n    biomass_ids = [\"BIOMASS_Ecoli_core_w_GAM\", \"BIOMASS_Ecoli_core_w_GAM\"],\n    model_names = model_names,\n)","category":"page"},{"location":"notebooks/7_community_model/#Set-exchange-reaction-bounds-of-community-model-based-on-the-bounds-of-the-individual-models","page":"Building and analysing a small community model","title":"Set exchange reaction bounds of community model based on the bounds of the individual models","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"env_ex_rxn_idxs = indexin(keys(ex_rxn_mets), reactions(community_model)) # identify the global (environmental exchange reactions)\ncytbd_ex_rxn_idxs = indexin(keys(ex_rxn_mets), reactions(cytbd_knockout_model)) # identify the indices of the corresponding exchange reactions in the original models\natps4r_ex_rxn_idxs = indexin(keys(ex_rxn_mets), reactions(atps4r_knockout_model))","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"In case some exchange reactions are not present in both models, set environmental exchange bound to the sum of the individual exchange bounds","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"for (env_ex, m2_ex, m1_ex) in zip(env_ex_rxn_idxs, cytbd_ex_rxn_idxs, atps4r_ex_rxn_idxs)\n    m2lb = isnothing(m2_ex) ? 0.0 : atps4r_knockout_model.xl[m2_ex]\n    m2ub = isnothing(m2_ex) ? 0.0 : atps4r_knockout_model.xu[m2_ex]\n    m1lb = isnothing(m1_ex) ? 0.0 : cytbd_knockout_model.xl[m1_ex]\n    m1ub = isnothing(m1_ex) ? 0.0 : cytbd_knockout_model.xu[m1_ex]\n    change_bounds!(community_model, [env_ex]; lower = [m1lb + m2lb], upper = [m1ub + m2ub])\nend","category":"page"},{"location":"notebooks/7_community_model/#Add-objective-function-to-community-model","page":"Building and analysing a small community model","title":"Add objective function to community model`","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"biomass_ids_weights = Dict(model_names .* \"_BIOMASS_Ecoli_core_w_GAM\" .=> 1.0)\nupdate_community_objective!(community_model, \"community_biomass\", biomass_ids_weights)","category":"page"},{"location":"notebooks/7_community_model/#Perform-community-FBA","page":"Building and analysing a small community model","title":"Perform community FBA","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"d = flux_balance_analysis_dict(\n    community_model,\n    Tulip.Optimizer;\n    modifications = [change_optimizer_attribute(\"IPM_IterationsLimit\", 1000)],\n)\nd[\"community_biomass\"] # community μ","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Notice, the growth rate is limited to the slowest organism as per the objective function","category":"page"},{"location":"notebooks/7_community_model/#Add-the-enolase-knockout-to-the-community-model","page":"Building and analysing a small community model","title":"Add the enolase knockout to the community model","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"community_model = add_model_with_exchanges(\n    community_model,\n    eno_knockout_model,\n    ex_rxn_mets;\n    model_name = \"eno_ko\",\n    biomass_id = \"BIOMASS_Ecoli_core_w_GAM\",\n)\n\npush!(model_names, \"eno_ko\")\nbiomass_ids_weights = Dict(model_names .* \"_BIOMASS_Ecoli_core_w_GAM\" .=> 1.0)\nupdate_community_objective!(community_model, \"community_biomass\", biomass_ids_weights)\n\nd = flux_balance_analysis_dict(\n    community_model,\n    Tulip.Optimizer;\n    modifications = [change_optimizer_attribute(\"IPM_IterationsLimit\", 1000)],\n)\nprintln(\"Community μ = \", d[\"community_biomass\"])","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Notice that the high communal growth rate is 0, due to the enolase knockout. The reason for this behaviour: enolase is a central reaction in glycolysis - without it the organism cannot access the lower glycolysis pathways or the TCA cycle, hence the model predicts no growth for the knockout, and hence no growth for the system since they all have to have the same growth rate.","category":"page"},{"location":"notebooks/7_community_model/#Allow-the-mutants-to-rescue-each-other-by-sharing-pyruvate","page":"Building and analysing a small community model","title":"Allow the mutants to rescue each other by sharing pyruvate","text":"","category":"section"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"pyr_exs = model_names .* \"_EX_pyr_e\"\nchange_bounds!(community_model, pyr_exs; lower = fill(-1000.0, 3), upper = fill(1000.0, 3))\n\nd = flux_balance_analysis_dict(\n    community_model,\n    Tulip.Optimizer;\n    modifications = [change_optimizer_attribute(\"IPM_IterationsLimit\", 1000)],\n)\nd[\"community_biomass\"] # community μ","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"Notice that the growth rate is now above 0! Nutrient sharing saved the day!","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"","category":"page"},{"location":"notebooks/7_community_model/","page":"Building and analysing a small community model","title":"Building and analysing a small community model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/io/#Input-and-output","page":"Input and output","title":"Input and output","text":"","category":"section"},{"location":"functions/io/#File-I/O-and-serialization","page":"Input and output","title":"File I/O and serialization","text":"","category":"section"},{"location":"functions/io/","page":"Input and output","title":"Input and output","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", file), readdir(\"../src/io\"))","category":"page"},{"location":"functions/io/#Base.close-Tuple{HDF5Model}","page":"Input and output","title":"Base.close","text":"Base.close(model::HDF5Model)\n\nClose (and un-cache) the HDF5Model data. This allows the associated file to be opened for writing again.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_h5_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_h5_model","text":"load_h5_model(file_name::String)::HDF5Model\n\nReturn a HDF5Model associated with the given file. Does not actually load anything (for efficiency) – use precache! to start pulling data into the memory.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_h5_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_h5_model","text":"save_h5_model(model::MetabolicModel, file_name::String)::HDF5Model\n\nConverts and writes a metabolic model to disk in the HDF5 format.\n\nAdditionally returns an (uncached) HDF5Model that represents the contents of the saved file. Because all HDF5-based models need to be backed by disk storage, writing the data to disk (using this function) is the only way to make new HDF5 models.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_model","text":"load_model(file_name::String)::MetabolicModel\n\nGeneric function for loading models that chooses a specific loader function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nSBML models (*.xml, loaded with load_sbml_model)\nJSON models (*.json, loaded with load_json_model)\nMATLAB models (*.mat, loaded with load_mat_model)\nHDF5 models (*.h5, loaded with load_h5_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_model-Union{Tuple{T}, Tuple{Type{T}, String}} where T<:MetabolicModel","page":"Input and output","title":"COBREXA.load_model","text":"load_model(type::Type{T}, file_name::String)::T where T\n\nHelper function tht loads the model using load_model and return it converted to type.\n\nExample:\n\nload_model(CoreModel, \"mySBMLModel.xml\")\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_model","text":"save_model(model::MetabolicModel, file_name::String)\n\nGeneric function for saving models that chooses a specific writer function from the file_name extension, or throws an error.\n\nCurrently, these model types are supported:\n\nSBML models (*.xml, saved with save_sbml_model)\nJSON models (*.json, saved with save_json_model)\nMATLAB models (*.mat, saved with save_mat_model)\nHDF5 models (*.h5, saved with save_h5_model)\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_json_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_json_model","text":"load_json_model(filename::String)::JSONModel\n\nLoad and return a JSON-formatted model that is stored in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_json_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_json_model","text":"save_json_model(model::MetabolicModel, file_name::String)\n\nSave a JSONModel in model to a JSON file file_name.\n\nIn case the model is not JSONModel, it will be converted automatically.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_mat_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_mat_model","text":"load_mat_model(file_name::String)\n\nLoad and return a MATLAB file file_name that contains a COBRA-compatible model.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_mat_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_mat_model","text":"save_mat_model(model::MetabolicModel, file_name::String; model_name::String=\"model\")\n\nSave a MATModel in model to a MATLAB file file_name in a format compatible with other MATLAB-based COBRA software.\n\nIn case the model is not MATModel, it will be converted automatically.\n\nmodel_name is the identifier name for the whole model written to the MATLAB file; defaults to just \"model\".\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.load_sbml_model-Tuple{String}","page":"Input and output","title":"COBREXA.load_sbml_model","text":"load_sbml_model(file_name::String)::SBMLModel\n\nLoad and return a SBML XML model in file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA.save_sbml_model-Tuple{MetabolicModel, String}","page":"Input and output","title":"COBREXA.save_sbml_model","text":"write_sbml_model(model::MetabolicModel, file_name::String)\n\nWrite a given SBML model to file_name.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#Pretty-printing","page":"Input and output","title":"Pretty printing","text":"","category":"section"},{"location":"functions/io/","page":"Input and output","title":"Input and output","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"io\", \"show\", file), readdir(\"../src/io/show\"))","category":"page"},{"location":"functions/io/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, MetabolicModel}","page":"Input and output","title":"Base.show","text":"Pretty printing of everything metabolic-modelish.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_substances-Tuple{Vector{String}}","page":"Input and output","title":"COBREXA._pretty_substances","text":"_pretty_substances(ss::Vector{String})::String\n\nNicely format a substance list.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#Base.show-Union{Tuple{M}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Serialized{M}}} where M","page":"Input and output","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", m::Serialized{M}) where {M}\n\nShow the Serialized model without unnecessarily loading it.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Any}","page":"Input and output","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(io, def::String, payload; kwargs...)\n\nNicely prints keys and values.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_print_keyvals-Tuple{Any, String, Dict}","page":"Input and output","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(\n    io,\n    def::String,\n    payload::Dict\n)\n\nSpecialization of _pretty_print_keyvals for dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"functions/io/#COBREXA._pretty_print_keyvals-Tuple{Any, String, String}","page":"Input and output","title":"COBREXA._pretty_print_keyvals","text":"_pretty_print_keyvals(\n    io,\n    def::String,\n    payload::String\n)\n\nSpecialization of _pretty_print_keyvals for plain strings.\n\n\n\n\n\n","category":"method"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/6_screening.jl\"","category":"page"},{"location":"notebooks/6_screening/#Exploring-model-variants-with-screen","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This notebooks demonstrates a simple use of screen to explore large number of model variants. On the toy E. Coli model, we try to map the impact of knocking out single reactions and 2-reaction combinations.","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"First, let's download the data and load the packages and the model","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n\nusing COBREXA, Tulip\n\nmodel = load_model(StandardModel, \"e_coli_core.json\")","category":"page"},{"location":"notebooks/6_screening/#Preparing-the-functions","page":"Exploring model variants with screen","title":"Preparing the functions","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"While we could use the with_changed_bound to limit the reaction rates, but we will make a slightly more precise, usage-tailored modification. This is a straightforward modification of the with_changed_bound that does not set bounds \"outside\" of the original bounds:","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"with_limited_rate(reaction_id::String, limit) =\n    model::StandardModel -> begin\n        m = copy(model)\n        m.reactions = copy(model.reactions)\n        r = m.reactions[reaction_id] = copy(model.reactions[reaction_id])\n        if -limit > r.lb\n            r.lb = -limit\n        end\n        if limit < r.ub\n            r.ub = limit\n        end\n        m\n    end","category":"page"},{"location":"notebooks/6_screening/#Knocking-out-single-reactions","page":"Exploring model variants with screen","title":"Knocking out single reactions","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This can be applied to see how much biomass can the model produce with certain reactions limited to almost zero:","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"get_biomass(x) = isnothing(x) ? 0 : x[\"BIOMASS_Ecoli_core_w_GAM\"]\n\nproductions = screen_variants(\n    model,\n    [[with_limited_rate(rxn, 0.1)] for rxn in reactions(model)],\n    model -> get_biomass(flux_balance_analysis_dict(model, Tulip.Optimizer)),\n)","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This can be nicely plotted to give a more comprehensive overview of which reactions are critical or not:","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"using CairoMakie\n\ndisp_rxns = rand(1:95, 20) # only display 20 random fluxes to save space\nbarplot(\n    productions[disp_rxns],\n    direction = :x,\n    axis = (\n        yticks = (1:20, reactions(model)[disp_rxns]),\n        xlabel = \"Flux [mmol/gDW/h]\",\n        ylabel = \"Reaction ID\",\n    ),\n)","category":"page"},{"location":"notebooks/6_screening/#Knocking-out-reaction-combinations","page":"Exploring model variants with screen","title":"Knocking out reaction combinations","text":"","category":"section"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"It is very easy to prepare matrices of biomass productions from all possible two-reaction knockouts. To make it more interesting, we will restrict one of the reactions of the pair a bit less, to see more possible outcomes.","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"We do not process all reactions here to make the notebook rendering efficient, but you can easily remove the restriction, and speed the process up using parallel execution, by specifying workers argument (see documentation of screen for details)","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"rxns = reactions(model)\n\nproductions = screen_variants(\n    model,\n    [\n        [with_limited_rate(rxn1, 3), with_limited_rate(rxn2, 0.1)] for rxn1 in rxns,\n        rxn2 in rxns\n    ],\n    model -> get_biomass(flux_balance_analysis_dict(model, Tulip.Optimizer)),\n)\n\nf = Figure()\nax = Axis(\n    f[1, 1],\n    ylabel = \"Reaction KO\",\n    xlabel = \"Reaction KO\",\n    yticks = (1:20, reactions(model)[disp_rxns]),\n    xticks = (1:20, reactions(model)[disp_rxns]),\n    xticklabelrotation = -pi / 4,\n)\nhm = heatmap!(ax, productions[disp_rxns, disp_rxns])\nColorbar(f[1, 2], hm, label = \"Flux [mmol/gDW/h]\")\nf","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"","category":"page"},{"location":"notebooks/6_screening/","page":"Exploring model variants with screen","title":"Exploring model variants with screen","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howToContribute/#Contributing-to-COBREXA.jl","page":"How to contribute","title":"Contributing to COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"👍🎉 Thanks for taking the time to contribute to COBREXA.jl! 🎉👍","category":"page"},{"location":"howToContribute/#How-to-report-a-bug-or-suggest-an-enhancement","page":"How to contribute","title":"How to report a bug or suggest an enhancement","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Please use the GitHub issue tracker to report any problems with the software, and discuss any potential questions about COBREXA use.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Before creating bug reports, please check the open issues, you might find out that the issue is already reported and known.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"General guidelines for reporting issues:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If creating a bug report, include a complete description of how we can reproduce the bug, including e.g. links to datasets and any external scripts used. Ideally, try to create a code snippet that causes the problem on a fresh installation of COBREXA.jl (often called the \"minimal crashing example\")\nIf possible, use the supplied issue templates and fill in all fields.\nIf your issue is already described in an issue that is \"closed\", do not reopen it. Instead, open a new issue and include a link to the original issue. (The fact that the original issue might have been mistakenly closed may be an issue on its own.)\nEnhancement proposals should refer a viable way for implementing the enhancement. If there are multiple possibilities for implementation, we will welcome a discussion about which one is optimal for COBREXA.jl.","category":"page"},{"location":"howToContribute/#How-to-test-a-development-version-of-the-package?","page":"How to contribute","title":"How to test a development version of the package?","text":"","category":"section"},{"location":"howToContribute/#Step-1:-Load-COBREXA.jl-from-the-source-from-the-git-repository","page":"How to contribute","title":"Step 1: Load COBREXA.jl from the source from the git repository","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"There are two ways that you can retrieve a local copy of the development repo: you can either clone the repository manually, or use Julia package manager to get a development version for you.","category":"page"},{"location":"howToContribute/#Option-1:-Using-Julia-package-manager","page":"How to contribute","title":"Option 1: Using Julia package manager","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When you are used to using the Julia package manager for developing or contributing to packages, you can type:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This will install the COBREXA package locally and check it out for development. You can check the location of the package with:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status\n    Status `~/.julia/environments/v1.4/Project.toml`\n  [a03a9c34] COBREXA v0.0.5 [`~/.julia/dev/COBREXA`]","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The default location of the package is ~/.julia/dev/COBREXA.","category":"page"},{"location":"howToContribute/#Option-2:-Cloning-with-git-manually","page":"How to contribute","title":"Option 2: Cloning with git manually","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You can use git to get the sources as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git clone git@github.com:LCSB-BioCore/COBREXA.jl.git","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the cloning process finishes, you shold see the package cloned in a new directory COBREXA.jl. To install this version to your Julia, change to the directory first, and start Julia:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd COBREXA.jl\n$ julia","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With Julia, you can install the development version of the package from the directory as follows:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> add .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(press ] to get into the packaging environment)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This adds the COBREXA.jl package and all its dependencies. You can verify that the installation worked by typing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> status","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"If you are planning to develop the package, it is often easier to install the package in development mode, with dev command:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> dev .","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"That causes the package to always load with whatever code changes that you added to the source directory.","category":"page"},{"location":"howToContribute/#Finally:-load-COBREXA.jl","page":"How to contribute","title":"Finally: load COBREXA.jl","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"With both of above options, you should get COBREXA.jl installed, which means that the following command should, without errors, load the package and make COBREXA.jl functions available for testing:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"julia> using COBREXA","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You may now freely modify the code and test the result.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Remember that if you want to work in the environment of the package, you need to activate it. That causes, among other, that the additional dependencies specified with packaging add command will be written automaticaly to Project.toml file of your local COBREXA.jl clone, not to your global environment. Activation is simple: when in the directory of the package, just type the command into the packaging shell:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"(v1.6) pkg> activate","category":"page"},{"location":"howToContribute/#Step-2:-Publish-your-changes","page":"How to contribute","title":"Step 2: Publish your changes","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"You are expected to make a fork of the main COBREXA.jl repository, and open a pull request from that one to the develop branch of the main repository. For creating the fork, just hit the \"Fork\" button on GitHub.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After that, change the directory to your repository and adjust the remotes:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ cd ~/.julia/dev/COBREXA             # or any other directory, as needed\n$ git remote rename origin upstream   # renames the origin (the main COBREXA.jl repo) to upstream\n$ git remote add origin git@github.com:yourUsername/COBREXA.jl.git  # adds the link to your clone as new origin\n$ git fetch origin                    # fetches the refs from your repo","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"In the above code, change yourUsername is your GitHub username.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"When the renaming is done, start a new branch at upstream/master. In the code snippet, substitute yn for your initials (Your Name here) and give the new feature a better name than somefeature:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git checkout -b yn-somefeature origin/master","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Commit any changes and features that you like to the new branch. When the commits look complete to you, push the branch to your repository fork:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"$ git push -u origin yn-somefeature","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"This makes your changes visible in your repository. After that, you can navigate to GitHub's pull request page, where you should immediately see a big green button that helps you to create a pull request for this branch. Read the section below for precise details and guidelines on submitting the pull requests.","category":"page"},{"location":"howToContribute/#How-to-submit-a-pull-request-(PR)-with-your-modification/enhancement?","page":"How to contribute","title":"How to submit a pull request (PR) with your modification/enhancement?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Make a fork of the repository, commit the modifications in a separate branch and push the branch to your fork.\nMake a pull request where you describe the motivation and expected outcome for the users. Specifically, consider any possible incompatibilities, and the necessity to increment the version number after your changes are applied. Set the target branch to develop.\nAfter submitting the pull request, verify that all status checks (tests, documentation) are passing. Make sure any new contribution is properly documented and tested (you may want to check with coverage tools, using test --coverage from the Julia packaging shell)","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"After you submitted a pull request, a label might be assigned that allows us to track and manage issues and pull requests.","category":"page"},{"location":"howToContribute/#Code-culture-and-style-recommendations","page":"How to contribute","title":"Code culture and style recommendations","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Follow basic rules for software maintainability and extensibility:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Do not reimplement functionality that is available in other packages, unless the reimplementation is either trivial and short, or there is a grave need to do so because the other implementations are deficient in some manner.\nTry to keep the function names and interfaces consistent with ecosystem standards and the other functions in the package. Consistency reduces the amount of surprise on the user side, thus lowers the need to reach for documentation, and in turn makes the software much easier and faster to use.\nCode less. Shorter code is almost always better unless demonstrated otherwise, e.g. with a benchmark. Avoid repetitive boilerplate (there should be ways to generate it, if needed).\nKeep the functionality \"open\" and composable. In particular, avoid all unnecessarily opaque and leaky abstractions (common in object-oriented programming).\nAvoid producing lots of \"informative\" text side-output by default, unless that is what the user asked for.\nAdhere to the code formatting rules defined by JuliaFormatter. We usually have a bot running that checks all PRs and reports whether the code is properly formatted.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Follow the common rules for making easily mergable and reviewable PRs:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"Create one PR for each logical \"feature\" you want to merge. If your change is more complex and contains multiple \"stages\", open multiple PRs.\nKeep the test coverage reasonably high.\nIf you commit many small, partial changes in a PR, you may help us save energy by prefixing your commit names with [skip ci], which deactivates the CI trigger on that commit. With each skipped CI, you save a few watt-hours of energy. Testing just the \"final\" commit of the pull-request branch is sufficient.","category":"page"},{"location":"howToContribute/#For-developers:-What-is-the-expected-branch-management/workflow?","page":"How to contribute","title":"For developers: What is the expected branch management/workflow?","text":"","category":"section"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The workflow is based on GitLab flow, i.e., a develop branch with feature branches being merged into the develop branch, all periodically merged to master branch. Depending on your access rights, you may open the feature branch in this repository, or in your fork.","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"The guidelines can be summarized as such:","category":"page"},{"location":"howToContribute/","page":"How to contribute","title":"How to contribute","text":"when making a contribution, create one new branch and open one new PR for each new independent feature or bugfix\ndo not push to another branch unless it is your own\ntry to get a review before merging unless the change is trivial and non-impacting\nconsider prefixing your branch names with your initials, so that one can easily see who owns which branch (e.g. ad-somefeature would be committed by Arthur Dent)","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/9_max_min_driving_force_analysis.jl\"","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/#Maximum-minimum-driving-force-analysis","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"","category":"section"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"In this notebook we use the max-min driving force analysis (MMDFA) to find optimal concentrations for the metabolites in glycolysis to ensure that the smallest driving force across all the reactions in the model is as large as possible. For more information, see Flamholz, Avi, et al.  \"Glycolytic strategy as a tradeoff between energy yield and protein cost.\", Proceedings of the National Academy of Sciences 110.24 (2013): 10039-10044.","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"using COBREXA, GLPK, Tulip","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"Let's load the core E. coli model","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"model = load_model(\"e_coli_core.json\")","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"We need some thermodynamic data. You can get reaction Gibbs free energies (ΔG⁰) from e.g. eQuilibrator, possibly using the Julia wrapper that allows you to automate this step. Here, we make a dictionary that maps the reaction IDs to calculated Gibbs free energy of reaction for each reaction (including the transporters).","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"reaction_standard_gibbs_free_energies = Dict( # kJ/mol\n    \"ACALD\" => -21.26,\n    \"PTAr\" => 8.65,\n    \"ALCD2x\" => 17.47,\n    \"PDH\" => -34.24,\n    \"PYK\" => -24.48,\n    \"CO2t\" => 0.00,\n    \"MALt2_2\" => -6.83,\n    \"CS\" => -39.33,\n    \"PGM\" => -4.47,\n    \"TKT1\" => -1.49,\n    \"ACONTa\" => 8.46,\n    \"GLNS\" => -15.77,\n    \"ICL\" => 9.53,\n    \"FBA\" => 23.37,\n    \"SUCCt3\" => -43.97,\n    \"FORt2\" => -3.42,\n    \"G6PDH2r\" => -7.39,\n    \"AKGDH\" => -28.23,\n    \"TKT2\" => -10.31,\n    \"FRD7\" => 73.61,\n    \"SUCOAS\" => -1.15,\n    \"FBP\" => -11.60,\n    \"ICDHyr\" => 5.39,\n    \"AKGt2r\" => 10.08,\n    \"GLUSy\" => -47.21,\n    \"TPI\" => 5.62,\n    \"FORt\" => 13.50,\n    \"ACONTb\" => -1.62,\n    \"GLNabc\" => -30.19,\n    \"RPE\" => -3.38,\n    \"ACKr\" => 14.02,\n    \"THD2\" => -33.84,\n    \"PFL\" => -19.81,\n    \"RPI\" => 4.47,\n    \"D_LACt2\" => -3.42,\n    \"TALA\" => -0.94,\n    \"PPCK\" => 10.65,\n    \"ACt2r\" => -3.41,\n    \"NH4t\" => -13.60,\n    \"PGL\" => -25.94,\n    \"NADTRHD\" => -0.01,\n    \"PGK\" => 19.57,\n    \"LDH_D\" => 20.04,\n    \"ME1\" => 12.08,\n    \"PIt2r\" => 10.41,\n    \"ATPS4r\" => -37.57,\n    \"PYRt2\" => -3.42,\n    \"GLCpts\" => -45.42,\n    \"GLUDy\" => 32.83,\n    \"CYTBD\" => -59.70,\n    \"FUMt2_2\" => -6.84,\n    \"FRUpts2\" => -42.67,\n    \"GAPD\" => 0.53,\n    \"H2Ot\" => 0.00,\n    \"PPC\" => -40.81,\n    \"NADH16\" => -80.37,\n    \"PFK\" => -18.54,\n    \"MDH\" => 25.91,\n    \"PGI\" => 2.63,\n    \"O2t\" => 0.00,\n    \"ME2\" => 12.09,\n    \"GND\" => 10.31,\n    \"SUCCt2_2\" => -6.82,\n    \"GLUN\" => -14.38,\n    \"ETOHt2r\" => -16.93,\n    \"ADK1\" => 0.38,\n    \"ACALDt\" => 0.00,\n    \"SUCDi\" => -73.61,\n    \"ENO\" => -3.81,\n    \"MALS\" => -39.22,\n    \"GLUt2r\" => -3.49,\n    \"PPS\" => -6.05,\n    \"FUM\" => -3.42,\n);\nnothing #hide","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"In general we cannot be certain that all fluxes will be positive for a given flux solution. This poses problems for systematically enforcing that ΔᵣG ≤ 0 for each reaction, because it implicitly assumes that all fluxes are positive, as done in the original formulation of MMDF. In max_min_driving_force we instead enforce ΔᵣG ⋅ vᵢ ≤ 0, where vᵢ is the flux of reaction i. By default all fluxes are assumed to be positive, but by supplying thermodynamically consistent flux solution it is possible to drop this implicit assumption and makes it easier to directly incorporate the max min driving force into non-customized models. Here, customized model means a model written such that a negative ΔᵣG is associated with each positive flux in the model, and only positive fluxes are used by the model.","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"flux_solution = flux_balance_analysis_dict( # find a thermodynamically consistent solution\n    model,\n    GLPK.Optimizer;\n    modifications = [add_loopless_constraints()],\n)","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"Run max min driving force analysis with some reasonable constraints on metabolite concentration bounds. To remove protons and water from the concentration calculations, we explicitly specify their IDs. Note, protons and water need to be removed from the concentration calculation of the optimization problem, because the Gibbs free energies of biochemical reactions are measured at constant pH, so proton concentration is fixed, and reactions occur in aqueous environments, hence water concentration does not change.","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"sol = max_min_driving_force(\n    model,\n    reaction_standard_gibbs_free_energies,\n    Tulip.Optimizer;\n    flux_solution = flux_solution,\n    proton_ids = [\"h_c\", \"h_e\"],\n    water_ids = [\"h2o_c\", \"h2o_e\"],\n    concentration_ratios = Dict(\n        (\"atp_c\", \"adp_c\") => 10.0,\n        (\"nadh_c\", \"nad_c\") => 0.13,\n        (\"nadph_c\", \"nadp_c\") => 1.3,\n    ),\n    concentration_lb = 1e-6, # M\n    concentration_ub = 100e-3, # M\n    ignore_reaction_ids = [\n        \"H2Ot\", # ignore water transporter\n    ],\n)\n\nsol.mmdf","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"note: Note: transporters\nTransporters can be included in MMDF analysis, however water and proton   transporters must be excluded explicitly in ignore_reaction_ids. Due to   the way the method is implemented, the ΔᵣG for these transport reactions   will always be 0. If not excluded, the MMDF will only have a zero solution (if   these reactions are used in the flux solution).","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"Next, we plot the results to show how the concentrations can be used to ensure that each reach proceeds \"down hill\" (ΔᵣG < 0) and that the driving force is as large as possible across all the reactions in the model. Compare this to the driving forces at standard conditions. Note, we only plot glycolysis for simplicity.","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"We additionally scale the fluxes according to their stoichiometry in the pathway. From the output, we can clearly see that that metabolite concentrations play a large role in ensuring the thermodynamic consistency of in vivo reactions.","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"rids = [\"GLCpts\", \"PGI\", \"PFK\", \"FBA\", \"TPI\", \"GAPD\", \"PGK\", \"PGM\", \"ENO\", \"PYK\"] # glycolysis\nrid_rf = [flux_solution[rid] for rid in rids]\ndg_standard = cumsum([\n    reaction_standard_gibbs_free_energies[rid] * flux_solution[rid] for rid in rids\n])\ndg_standard .-= first(dg_standard)\ndg_opt = cumsum([sol.dg_reactions[rid] * flux_solution[rid] for rid in rids])\ndg_opt .-= first(dg_opt)\n\nusing CairoMakie\n\nfig = Figure();\nax = Axis(\n    fig[1, 1],\n    xticklabelrotation = -pi / 2,\n    xlabel = \"Reaction\",\n    ylabel = \"Cumulative ΔG [kJ/mol]\",\n);\n\nlines!(ax, 1:length(rids), dg_standard; color = :red, label = \"Standard\")\nlines!(ax, 1:length(rids), dg_opt, color = :blue, label = \"Optimized\")\nax.xticks = (1:length(rids), rids)\nfig[1, 2] = Legend(fig, ax, \"ΔG'\", framevisible = false)\nfig","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"tip: Tip: Thermodynamic variability\nMuch like flux variability, thermodynamic constraints in a model are also   degenerate. Check out max_min_driving_force_variability for ways   to explore the thermodynamic solution space.","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"","category":"page"},{"location":"notebooks/9_max_min_driving_force_analysis/","page":"Maximum-minimum driving force analysis","title":"Maximum-minimum driving force analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"functions/types/#Base-types","page":"Types","title":"Base types","text":"","category":"section"},{"location":"functions/types/","page":"Types","title":"Types","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", \"abstract\", file), readdir(\"../src/base/types/abstract\"))","category":"page"},{"location":"functions/types/#COBREXA.Maybe","page":"Types","title":"COBREXA.Maybe","text":"Maybe{T} = Union{Nothing, T}\n\nA nice name for \"nullable\" type.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._default-Union{Tuple{T}, Tuple{T, Union{Nothing, T}}} where T","page":"Types","title":"COBREXA._default","text":"_default(d::T, x::Maybe{T})::T where {T}\n\nFold the Maybe{T} down to T by defaulting.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA._maybemap-Tuple{Any, Any}","page":"Types","title":"COBREXA._maybemap","text":"_maybemap(f, x::Maybe)::Maybe\n\nApply a function to x only if it is not nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Annotations","page":"Types","title":"COBREXA.Annotations","text":"Annotations = Dict{String,Vector{String}}\n\nDictionary used to store (possible multiple) standardized annotations of something, such as a Metabolite and a Reaction.\n\nExample\n\nAnnotations(\"PubChem\" => [\"CID12345\", \"CID54321\"])\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.GeneAssociation","page":"Types","title":"COBREXA.GeneAssociation","text":"GeneAssociation = Vector{Vector{String}}\n\nAn association to genes, represented as a logical formula in a positive disjunctive normal form (DNF). (The 2nd-level vectors of strings are connected by \"and\" to form conjunctions, and the 1st-level vectors of these conjunctions are connected by \"or\" to form the DNF.)\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.MetabolicModel","page":"Types","title":"COBREXA.MetabolicModel","text":"abstract type MetabolicModel end\n\nA helper supertype of everything usable as a linear-like model for COBREXA functions.\n\nIf you want your model type to work with COBREXA, add the MetabolicModel as its supertype, and implement the accessor functions. Accessors reactions, metabolites, stoichiometry, bounds and objective must be implemented; others are not mandatory and default to safe \"empty\" values.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.MetaboliteFormula","page":"Types","title":"COBREXA.MetaboliteFormula","text":"MetaboliteFormula = Dict{String,Int}\n\nDictionary of atoms and their abundances in a molecule.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.ModelWrapper","page":"Types","title":"COBREXA.ModelWrapper","text":"abstract type ModelWrapper <: MetabolicModel end\n\nA helper supertype of all \"wrapper\" types that contain precisely one other MetabolicModel.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Notes","page":"Types","title":"COBREXA.Notes","text":"Notes = Dict{String,Vector{String}}\n\nFree-form notes about something (e.g. a Gene), categorized by \"topic\".\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Model-types-and-contents","page":"Types","title":"Model types and contents","text":"","category":"section"},{"location":"functions/types/","page":"Types","title":"Types","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", file), readdir(\"../src/base/types\"))","category":"page"},{"location":"functions/types/#COBREXA.CoreModel","page":"Types","title":"COBREXA.CoreModel","text":"struct CoreModel <: MetabolicModel\n\nA \"bare bones\" core linear optimization problem of the form, with reaction and metabolite names.\n\nmin c^T x\ns.t. S x = b\n      xₗ ≤ x ≤ xᵤ\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Union{Tuple{M}, Tuple{Type{CoreModel}, M}} where M<:MetabolicModel","page":"Types","title":"Base.convert","text":"Base.convert(::Type{CoreModel}, m::M) where {M <: MetabolicModel}\n\nMake a CoreModel out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{CoreModel}","page":"Types","title":"COBREXA.balance","text":"balance(a::CoreModel)::SparseVec\n\nCoreModel target flux balance.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{CoreModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(a::CoreModel)::Tuple{Vector{Float64},Vector{Float64}}\n\nCoreModel flux bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{CoreModel}","page":"Types","title":"COBREXA.genes","text":"genes(a::CoreModel)::Vector{String}\n\nCollect all genes contained in the CoreModel. The call is expensive for large models, because the vector is not stored and instead gets rebuilt each time this function is called.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{CoreModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(a::CoreModel)::Vector{String}\n\nMetabolites in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{CoreModel}","page":"Types","title":"COBREXA.objective","text":"objective(a::CoreModel)::SparseVec\n\nCoreModel objective vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{CoreModel, Int64}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::CoreModel, ridx::Int)::Maybe{GeneAssociation}\n\nRetrieve the GeneAssociation from CoreModel by reaction index.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{CoreModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::CoreModel, rid::String)::Maybe{GeneAssociation}\n\nRetrieve the GeneAssociation from CoreModel by reaction ID.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association_vec-Tuple{CoreModel}","page":"Types","title":"COBREXA.reaction_gene_association_vec","text":"reaction_gene_association_vec(model::CoreModel)::Vector{Maybe{GeneAssociation}}\n\nRetrieve a vector of all gene associations in a CoreModel, in the same order as reactions(model).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{CoreModel, Any}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModel, ridx)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction at index ridx.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{CoreModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{CoreModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(a::CoreModel)::Vector{String}\n\nGet the reactions in a CoreModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{CoreModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(a::CoreModel)::SparseMat\n\nCoreModel stoichiometry matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.CoreCoupling","page":"Types","title":"COBREXA.CoreCoupling","text":"mutable struct CoreCoupling{M} <: ModelWrapper where {M<:MetabolicModel}\n\nA matrix-based wrap that adds reaction coupling matrix to the inner model. A flux x feasible in this model must satisfy:\n\n    cₗ ≤ C x ≤ cᵤ\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.CoreModelCoupled","page":"Types","title":"COBREXA.CoreModelCoupled","text":"const CoreModelCoupled = CoreCoupling{CoreModel}\n\nA matrix-based linear model with additional coupling constraints in the form:\n\n    cₗ ≤ C x ≤ cᵤ\n\nInternally, the model is implemented using CoreCoupling that contains a single CoreModel.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Union{Tuple{M}, Tuple{Type{CoreCoupling{M}}, MetabolicModel}} where M","page":"Types","title":"Base.convert","text":"Base.convert(::Type{CoreCoupling{M}}, mm::MetabolicModel; clone_coupling = true) where {M}\n\nMake a CoreCoupling out of any compatible model type.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.coupling","text":"coupling(a::CoreCoupling)::SparseMat\n\nCoupling constraint matrix for a CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::CoreCoupling)::Tuple{Vector{Float64},Vector{Float64}}\n\nCoupling bounds for a CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::CoreCoupling)::Int\n\nThe number of coupling constraints in a CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association_vec-Tuple{CoreModelCoupled}","page":"Types","title":"COBREXA.reaction_gene_association_vec","text":"reaction_gene_association_vec(model::CoreModelCoupled)\n\nEvaluates reaction_gene_association_vec on the model contained in CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{CoreModelCoupled, Int64}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::CoreModelCoupled, ridx::Int)\n\nEvaluates reaction_stoichiometry on the model contained in CoreModelCoupled.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.unwrap_model-Tuple{CoreCoupling}","page":"Types","title":"COBREXA.unwrap_model","text":"unwrap_model(a::CoreCoupling)\n\nGet the internal CoreModel out of CoreCoupling.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.FluxSummary","page":"Types","title":"COBREXA.FluxSummary","text":"FluxSummary\n\nA struct used to store summary information about the solution of a constraint based analysis result.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.FluxSummary-Tuple{}","page":"Types","title":"COBREXA.FluxSummary","text":"FluxSummary()\n\nA default empty constructor for FluxSummary.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.flux_summary-Tuple{Union{Nothing, Dict{String, Float64}}}","page":"Types","title":"COBREXA.flux_summary","text":"flux_summary(flux_result::Dict{String, Float64};\n    exclude_exchanges = false,\n    exchange_prefixes = _constants.exchange_prefixes,\n    biomass_strings = _constants.biomass_strings,\n    exclude_biomass = false,\n    small_flux_bound = 1.0/_constants.default_reaction_bound^2,\n    large_flux_bound = _constants.default_reaction_bound,\n    keep_unbounded = false,\n)::FluxSummary\n\nSummarize a dictionary of fluxes into small, useful representation of the most important information contained. Useful for pretty-printing and quickly exploring the results. Internally this function uses looks_like_biomass_reaction and looks_like_exchange_reaction. The corresponding keyword arguments passed to these functions. Use this if your model has non-standard ids for reactions. Fluxes smaller than small_flux_bound are not stored, while fluxes larger than large_flux_bound are only stored if keep_unbounded is true.\n\nExample\n\njulia> sol = flux_dict(flux_balance_analysis(model, Tulip.Optimizer))\njulia> fr = flux_summary(sol)\nBiomass:\n  BIOMASS_Ecoli_core_w_GAM: 0.8739\nImport:\n  EX_o2_e:     -21.7995\n  EX_glc__D_e: -10.0\n  EX_nh4_e:    -4.7653\n  EX_pi_e:     -3.2149\nExport:\n  EX_h_e:      17.5309\n  EX_co2_e:    22.8098\n  EX_h2o_e:    29.1758\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.FluxVariabilitySummary","page":"Types","title":"COBREXA.FluxVariabilitySummary","text":"FluxVariabilitySummary\n\nStores summary information about the result of a flux variability analysis.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.FluxVariabilitySummary-Tuple{}","page":"Types","title":"COBREXA.FluxVariabilitySummary","text":"FluxVariabilitySummary()\n\nA default empty constructor for FluxVariabilitySummary.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.flux_variability_summary-Tuple{Tuple{Dict{String, Dict{String, Float64}}, Dict{String, Dict{String, Float64}}}}","page":"Types","title":"COBREXA.flux_variability_summary","text":"flux_variability_summary(flux_result::Tuple{Dict{String, Dict{String, Float64}}, Dict{String, Dict{String, Float64}}};\n    exclude_exchanges = false,\n    exchange_prefixes = _constants.exchange_prefixes,\n    biomass_strings = _constants.biomass_strings,\n    exclude_biomass = false,\n    )::FluxVariabilitySummary\n\nSummarize a dictionary of flux dictionaries obtained eg. from flux_variability_analysis_dict. The simplified summary representation is useful for pretty-printing and easily showing the most important results.\n\nInternally this function uses looks_like_biomass_reaction and looks_like_exchange_reaction. The corresponding keyword arguments are passed to these functions. Use this if your model has an uncommon naming of reactions.\n\nExample\n\njulia> sol = flux_variability_analysis_dict(model, Gurobi.Optimizer; bounds = objective_bounds(0.99))\njulia> flux_res = flux_variability_summary(sol)\nBiomass                     Lower bound   Upper bound\n  BIOMASS_Ecoli_core_w_GAM: 0.8652        0.8652\nExchange\n  EX_h2o_e:                 28.34         28.34\n  EX_co2_e:                 22.0377       22.0377\n  EX_o2_e:                  -22.1815      -22.1815\n  EX_h_e:                   17.3556       17.3556\n  EX_glc__D_e:              -10.0         -10.0\n  EX_nh4_e:                 -4.8448       -4.8448\n  EX_pi_e:                  -3.2149       -3.2149\n  EX_for_e:                 0.0           0.0\n  ...                       ...           ...\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Gene","page":"Types","title":"COBREXA.Gene","text":"Gene struct.\n\nFields\n\nid :: String\nname :: Maybe{String}\nnotes :: Dict{String, Vector{String}}\nannotation :: Dict{String, Union{Vector{String}, String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.HDF5Model","page":"Types","title":"COBREXA.HDF5Model","text":"struct HDF5Model\n\nA model that is stored in HDF5 format. The model data is never really pulled into memory, but instead mmap'ed as directly as possible into the Julia structures.  This makes reading the HDF5Models extremely fast, at the same time the (uncached) HDF5Models can be sent around efficiently among distributed nodes just like Serialized models, provided the nodes share a common storage.\n\nAll HDF5Models must have the backing disk storage. To create one, use save_h5_model or save_model with .h5 file extension. To create a temporary model that behaves like a model \"in memory\", save it to a temporary file. For related reasons, you can not use convert models to HDF5Model format, because the conversion would impliy having the model saved somewhere.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Isozyme","page":"Types","title":"COBREXA.Isozyme","text":"mutable struct Isozyme\n\nInformation about isozyme composition and activity.\n\nFields\n\ngene_product_count :: Dict{String, Int} assigns each gene product ID its count in the isozyme complex (which is used to determine the total mass of the isozyme)\nkcat_forward, kcat_reverse – forward and reverse turnover numbers of the isozyme\n\n````\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.JSONModel","page":"Types","title":"COBREXA.JSONModel","text":"struct JSONModel <: MetabolicModel\n    json::Dict{String,Any}\n    rxn_index::Dict{String,Int}\n    rxns::Vector{Any}\n    met_index::Dict{String,Int}\n    mets::Vector{Any}\n    gene_index::Dict{String,Int}\n    genes::Vector{Any}\nend\n\nA struct used to store the contents of a JSON model, i.e. a model read from a file ending with .json. These model files typically store all the model data in arrays of JSON objects (represented in Julia as vectors of dictionaries).\n\nUsually, not all of the fields of the input JSON can be easily represented when converting to other models, care should be taken to avoid losing information.\n\nDirect work with the json structure is not very efficient; the model structure therefore caches some of the internal structure in the extra fields. The single-parameter JSONModel constructor creates these caches correctly from the json. The model structure is designed as read-only, and changes in json invalidate the cache.\n\nExample\n\nmodel = load_json_model(\"some_model.json\")\nmodel.json # see the actual underlying JSON\nreactions(model) # see the list of reactions\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{JSONModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"Base.convert(::Type{JSONModel}, mm::MetabolicModel)\n\nConvert any MetabolicModel to JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{JSONModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::JSONModel)\n\nGet the bounds for reactions, assuming the information is stored in .lower_bound and .upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(model::JSONModel, gid::String)::Annotations\n\nGene annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(model::JSONModel, gid::String)\n\nReturn the name of gene with ID gid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::JSONModel, gid::String)::Notes\n\nGene notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{JSONModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::JSONModel)\n\nExtract gene names from a JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::JSONModel, mid::String)::Annotations\n\nMetabolite annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::JSONModel, mid::String)\n\nReturn the metabolite .charge\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::JSONModel, mid::String)\n\nReturn the metabolite .compartment\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::JSONModel, mid::String)\n\nParse and return the metabolite .formula\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(model::JSONModel, mid::String)\n\nReturn the name of metabolite with ID mid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::JSONModel, mid::String)::Notes\n\nMetabolite notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{JSONModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::JSONModel)\n\nExtract metabolite names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{JSONModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::JSONModel)\n\nCollect .objective_coefficient keys from model reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::JSONModel, rid::String)::Annotations\n\nReaction annotations from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_associaton(model::JSONModel, rid::String)\n\nParses the .gene_reaction_rule from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(model::JSONModel, rid::String)\n\nReturn the name of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::JSONModel, rid::String)::Notes\n\nReaction notes from the JSONModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::JSONModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{JSONModel, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::JSONModel, rid::String)\n\nParses the .subsystem out from reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{JSONModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::JSONModel)\n\nExtract reaction names (stored as .id) from JSON model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{JSONModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::JSONModel)\n\nGet the stoichiometry. Assuming the information is stored in reaction object under key .metabolites.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.MATModel","page":"Types","title":"COBREXA.MATModel","text":"struct MATModel\n\nWrapper around the models loaded in dictionaries from the MATLAB representation.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{MATModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"Base.convert(::Type{MATModel}, m::MetabolicModel)\n\nConvert any metabolic model to MATModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA._mat_has_squashed_coupling-Tuple{Any}","page":"Types","title":"COBREXA._mat_has_squashed_coupling","text":"_mat_has_squashed_coupling(mat)\n\nGuesses whether C in the MAT file is stored in A=[S;C].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{MATModel}","page":"Types","title":"COBREXA.balance","text":"balance(m::MATModel)\n\nExtracts balance from the MAT model, defaulting to zeroes if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{MATModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(m::MATModel)\n\nExtracts bounds from the MAT file, saved under lb and ub.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{MATModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(m::MATModel)\n\nExtract coupling matrix stored, in C key.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{MATModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(m::MATModel)\n\nExtracts the coupling constraints. Currently, there are several accepted ways to store these in MATLAB models; this takes the constraints from vectors cl and cu.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{MATModel}","page":"Types","title":"COBREXA.genes","text":"genes(m::MATModel)\n\nExtracts the possible gene list from genes key.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(m::MATModel, mid::String)\n\nExtract metabolite charge from metCharge or metCharges.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(m::MATModel, mid::String)\n\nExtract metabolite compartment from metCompartment or metCompartments.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(m::MATModel, mid::String)\n\nExtract metabolite formula from key metFormula or metFormulas.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{MATModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(m::MATModel, mid::String)\n\nExtract metabolite name from metNames.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{MATModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(m::MATModel)::Vector{String}\n\nExtracts metabolite names from mets key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{MATModel}","page":"Types","title":"COBREXA.objective","text":"objective(m::MATModel)\n\nExtracts the objective from the MAT model (defaults to zeroes).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{MATModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(m::MATModel, rid::String)\n\nExtracts the associations from grRules key, if present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{MATModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(m::MATModel, mid::String)\n\nExtract reaction name from rxnNames.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{MATModel, Any}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::MATModel, ridx)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction at index ridx.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{MATModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::MATModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{MATModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(m::MATModel)::Vector{String}\n\nExtracts reaction names from rxns key in the MAT file.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{MATModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(m::MATModel)\n\nExtract the stoichiometry matrix, stored under key S.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.balance","text":"balance(a::MetabolicModel)::SparseVec\n\nGet the sparse balance vector of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(a::MetabolicModel)::Tuple{Vector{Float64},Vector{Float64}}\n\nGet the lower and upper solution bounds of a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(a::MetabolicModel)::SparseMat\n\nGet a matrix of coupling constraint definitions of a model. By default, there is no coupling in the models.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(a::MetabolicModel)::Tuple{Vector{Float64},Vector{Float64}}\n\nGet the lower and upper bounds for each coupling bound in a model, as specified by coupling. By default, the model does not have any coupling bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.fluxes-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.fluxes","text":"fluxes(a::MetabolicModel)::Vector{String}\n\nIn some models, the reactions that correspond to the columns of stoichiometry matrix do not fully represent the semantic contents of the model; for example, fluxes may be split into forward and reverse reactions, reactions catalyzed by distinct enzymes, etc. Together with reaction_flux (and n_fluxes) this specifies how the flux is decomposed into individual reactions.\n\nBy default (and in most models), fluxes and reactions perfectly correspond.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(a::MetabolicModel, gene_id::String)::Annotations\n\nReturn standardized names that identify the corresponding gene or product. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"PDB\" => [\"PROT01\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(model::MetabolicModel, gid::String)\n\nReturn the name of gene with ID gid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::MetabolicModel, gene_id::String)::Notes\n\nReturn the notes associated with the gene gene_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.genes","text":"genes(a::MetabolicModel)::Vector{String}\n\nReturn identifiers of all genes contained in the model. By default, there are no genes.\n\nIn SBML, these are usually called \"gene products\" but we write genes for simplicity.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(a::MetabolicModel, metabolite_id::String)::Annotations\n\nReturn standardized names that may help to reliably identify the metabolite. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"ChEMBL\" => [\"123\"] or \"PubChem\" => [\"CID123\", \"CID654645645\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::MetabolicModel, metabolite_id::String)::Maybe{Int}\n\nReturn the charge associated with metabolite metabolite_id in model. Returns nothing if charge not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::MetabolicModel, metabolite_id::String)::Maybe{String}\n\nReturn the compartment of metabolite metabolite_id in model if it is assigned. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(\n    a::MetabolicModel,\n    metabolite_id::String,\n)::Maybe{MetaboliteFormula}\n\nReturn the formula of metabolite metabolite_id in model. Return nothing in case the formula is not known or irrelevant.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(model::MetabolicModel, mid::String)\n\nReturn the name of metabolite with ID mid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::MetabolicModel, metabolite_id::String)::Notes\n\nReturn the notes associated with metabolite reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(a::MetabolicModel)::Vector{String}\n\nReturn a vector of metabolite identifiers in a model. The vector precisely corresponds to the rows in stoichiometry matrix.\n\nAs with reactionss, some metabolites in models may be virtual, representing purely technical equality constraints.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(a::MetabolicModel)::Int\n\nGet the number of coupling constraints in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(a::MetabolicModel)::Int\n\nReturn the number of genes in the model (as returned by genes). If you just need the number of the genes, this may be much more efficient than calling genes and measuring the array.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(a::MetabolicModel)::Int\n\nGet the number of metabolites in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(a::MetabolicModel)::Int\n\nGet the number of reactions in a model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.objective","text":"objective(a::MetabolicModel)::SparseVec\n\nGet the objective vector of the model. Analysis functions, such as flux_balance_analysis, are supposed to maximize dot(objective, x) where x is a feasible solution of the model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.precache!-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.precache!","text":"precache!(a::MetabolicModel)::Nothing\n\nDo whatever is feasible to get the model into a state that can be read from as-quickly-as-possible. This may include e.g. generating helper index structures and loading delayed parts of the model from disk. The model should be modified \"transparently\" in-place. Analysis functions call this right before applying modifications or converting the model to the optimization model using make_optimization_model; usually on the same machine where the optimizers (and, generally, the core analysis algorithms) will run. The calls are done in a good hope that the performance will be improved.\n\nBy default, it should be safe to do nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(a::MetabolicModel, reaction_id::String)::Annotations\n\nReturn standardized names that may help identifying the reaction. The dictionary assigns vectors of possible identifiers to identifier system names, e.g. \"Reactome\" => [\"reactomeID123\"].\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(a::MetabolicModel)::SparseMat\n\nRetrieve a sparse matrix that describes the correspondence of a solution of the linear system to the fluxes (see fluxes for rationale). Returns a sparse matrix of size (n_reactions(a), n_fluxes(a)). For most models, this is an identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(a::MetabolicModel, gene_id::String)::Maybe{GeneAssociation}\n\nReturns the sets of genes that need to be present so that the reaction can work (technically, a DNF on gene availability, with positive atoms only).\n\nFor simplicity, nothing may be returned, meaning that the reaction always takes place. (in DNF, that would be equivalent to returning [[]].)\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(model::MetabolicModel, rid::String)\n\nReturn the name of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::MetabolicModel, reaction_id::String)::Notes\n\nReturn the notes associated with reaction reaction_id in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::MetaboliteModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid in the model. The dictionary maps the metabolite IDs to their stoichiometric coefficients.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{MetabolicModel, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::MetabolicModel, reaction_id::String)::Maybe{String}\n\nReturn the subsystem of reaction reaction_id in model if it is assigned. If not, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(a::MetabolicModel)::Vector{String}\n\nReturn a vector of reaction identifiers in a model. The vector precisely corresponds to the columns in stoichiometry matrix.\n\nFor technical reasons, the \"reactions\" may sometimes not be true reactions but various virtual and helper pseudo-reactions that are used in the metabolic modeling, such as metabolite exchanges, separate forward and reverse reactions, supplies of enzymatic and genetic material and virtual cell volume, etc. To simplify the view of the model contents use reaction_flux.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{MetabolicModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(a::MetabolicModel)::SparseMat\n\nGet the sparse stoichiometry matrix of a model. A feasible solution x of a model m is defined as satisfying the equations:\n\nstoichiometry(m) * x .== balance(m)\nx .>= lbs\ny .<= ubs\n`(lbs, ubs) == bounds(m)\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Metabolite","page":"Types","title":"COBREXA.Metabolite","text":"Metabolite structure.\n\nFields\n\nid :: String\nname :: Maybe{String}\nformula :: String\ncharge :: Int\ncompartment :: String\nnotes :: Dict{String, Vector{String}}\nannotation :: Dict{String, Union{Vector{String}, String}}\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.balance-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.balance","text":"balance(model::ModelWrapper)\n\nEvaluates balance on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::ModelWrapper)\n\nEvaluates bounds on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.coupling","text":"coupling(model::ModelWrapper)\n\nEvaluates coupling on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(model::ModelWrapper)\n\nEvaluates coupling_bounds on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.fluxes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.fluxes","text":"fluxes(model::ModelWrapper)\n\nEvaluates fluxes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(model::ModelWrapper, gid::String)\n\nEvaluates gene_annotations on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::ModelWrapper, gid::String)\n\nEvaluates gene_notes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.genes","text":"genes(model::ModelWrapper)\n\nEvaluates genes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_annotations on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_charge on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_compartment on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_formula on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::ModelWrapper, mid::String)\n\nEvaluates metabolite_notes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::ModelWrapper)\n\nEvaluates metabolites on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(model::ModelWrapper)\n\nEvaluates n_coupling_constraints on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_fluxes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.n_fluxes","text":"n_fluxes(model::ModelWrapper)\n\nEvaluates n_fluxes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::ModelWrapper)\n\nEvaluates n_genes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.objective","text":"objective(model::ModelWrapper)\n\nEvaluates objective on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.precache!-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.precache!","text":"precache!(model::ModelWrapper)\n\nEvaluates precache! on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::ModelWrapper, rid::String)\n\nEvaluates reaction_annotations on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(model::ModelWrapper)\n\nEvaluates reaction_flux on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::ModelWrapper, rid::String)\n\nEvaluates reaction_gene_association on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::ModelWrapper, rid::String)\n\nEvaluates reaction_notes on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::ModelWrapper, rid::String)\n\nEvaluates reaction_stoichiometry on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{ModelWrapper, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(model::ModelWrapper, rid::String)\n\nEvaluates reaction_subsystem on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::ModelWrapper)\n\nEvaluates reactions on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::ModelWrapper)\n\nEvaluates stoichiometry on the model contained in ModelWrapper.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.unwrap_model-Tuple{ModelWrapper}","page":"Types","title":"COBREXA.unwrap_model","text":"unwrap_model(a::ModelWrapper)\n\nA simple helper to pick the single w\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Reaction","page":"Types","title":"COBREXA.Reaction","text":"Reaction(\n    id::String,\n    metabolites::Dict{String,Union{Int, Float64}},\n    dir = :bidirectional;\n    default_bound = _constants.default_reaction_bound,\n)\n\nConvenience constructor for Reaction. The reaction equation is specified using metabolites, which is a dictionary mapping metabolite ids to stoichiometric coefficients. The direcion of the reaction is set through dir which can take :bidirectional, :forward, and :reverse as values. Finally, the default_bound is the value taken to mean infinity in the context of constraint based models, often this is set to a very high flux value like 1000.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Reaction-2","page":"Types","title":"COBREXA.Reaction","text":"Reaction(\n    id = \"\";\n    name = nothing,\n    metabolites = Dict{String,Float64}(),\n    lb = -_constants.default_reaction_bound,\n    ub = _constants.default_reaction_bound,\n    grr = nothing,\n    subsystem = nothing,\n    notes = Notes(),\n    annotations = Annotations(),\n    objective_coefficient = 0.0,\n)\n\nA constructor for Reaction that only takes a reaction id and assigns default/uninformative values to all the fields that are not explicitely assigned.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.Reaction-3","page":"Types","title":"COBREXA.Reaction","text":"mutable struct Reaction\n    id::String\n    name::Maybe{String}\n    metabolites::Dict{String,Float64}\n    lb::Float64\n    ub::Float64\n    grr::Maybe{GeneAssociation}\n    subsystem::Maybe{String}\n    notes::Notes\n    annotations::Annotations\n    objective_coefficient::Float64\nend\n\nA structure for representing a single reaction in a StandardModel.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.ReactionStatus","page":"Types","title":"COBREXA.ReactionStatus","text":"Used for concise reporting of modeling results.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.SBMLModel","page":"Types","title":"COBREXA.SBMLModel","text":"struct SBMLModel\n\nThin wrapper around the model from SBML.jl library. Allows easy conversion from SBML to any other model format.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{SBMLModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"Base.convert(::Type{SBMLModel}, mm::MetabolicModel)\n\nConvert any metabolic model to SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{SBMLModel}","page":"Types","title":"COBREXA.balance","text":"balance(model::SBMLModel)::SparseVec\n\nBalance vector of a SBMLModel. This is always zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{SBMLModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::SBMLModel)::Tuple{Vector{Float64},Vector{Float64}}\n\nGet the lower and upper flux bounds of model SBMLModel. Throws DomainError in case if the SBML contains mismatching units.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(model::SBMLModel, gid::String)\n\nReturn the name of gene with ID gid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{SBMLModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::SBMLModel)::Vector{String}\n\nGet genes of a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::SBMLModel, mid::String)::Maybe{Int}\n\nGet charge of a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::SBMLModel, mid::String)::Maybe{MetaboliteFormula}\n\nGet MetaboliteFormula from a chosen metabolite from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(model::SBMLModel, mid::String)\n\nReturn the name of metabolite with ID mid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{SBMLModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::SBMLModel)::Vector{String}\n\nGet metabolites from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{SBMLModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::SBMLModel)::Int\n\nGet number of genes in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{SBMLModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(model::SBMLModel)::Int\n\nEfficient counting of metabolites in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{SBMLModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::SBMLModel)::Int\n\nEfficient counting of reactions in SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{SBMLModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::SBMLModel)::SparseVec\n\nObjective of the SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::SBMLModel, rid::String)::Maybe{GeneAssociation}\n\nRetrieve the GeneAssociation from SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(model::SBMLModel, rid::String)\n\nReturn the name of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{SBMLModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::SBMLModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{SBMLModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::SBMLModel)::Vector{String}\n\nGet reactions from a SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{SBMLModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::SBMLModel)::SparseMat\n\nRecreate the stoichiometry matrix from the SBMLModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.Serialized","page":"Types","title":"COBREXA.Serialized","text":"mutable struct Serialized{M <: MetabolicModel}\n    m::Maybe{M}\n    filename::String\nend\n\nA meta-model that represents a model that is serialized on the disk. The internal model will be loaded on-demand by using any accessor, or by calling precache! directly.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.precache!-Tuple{Serialized}","page":"Types","title":"COBREXA.precache!","text":"precache!(model::Serialized{MetabolicModel})::Nothing\n\nLoad the Serialized model from disk in case it's not alreadly loaded.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.unwrap_model-Tuple{Serialized}","page":"Types","title":"COBREXA.unwrap_model","text":"unwrap_model(m::Serialized)\n\nUnwrap the serialized model (precaching it transparently).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.StandardModel","page":"Types","title":"COBREXA.StandardModel","text":"mutable struct StandardModel\n\nStandardModel is used to store a constraint based metabolic model with meta-information.  Meta-information is defined as annotation details, which include gene-reaction-rules, formulas, etc.\n\nThis model type seeks to keep as much meta-information as possible, as opposed to CoreModel and CoreModelCoupled, which keep the bare neccessities only. When merging models and keeping meta-information is important, use this as the model type.  If meta-information is not important, use the more efficient core model types.  See CoreModel and CoreModelCoupled for comparison.\n\nIn this model, reactions, metabolites, and genes are stored in ordered dictionaries indexed by each struct's id field.  For example, model.reactions[\"rxn1_id\"] returns a Reaction where the field id equals \"rxn1_id\".  This makes adding and removing reactions efficient.\n\nNote that the stoichiometric matrix (or any other core data, e.g. flux bounds) is not stored directly as in CoreModel.  When this model type is used in analysis functions, these core data structures are built from scratch each time an analysis function is called.  This can cause performance issues if you run many small analysis functions sequentially.  Consider using the core model types if performance is critical.\n\nSee also: Reaction, Metabolite, Gene\n\nFields\n\nid :: String\nreactions :: OrderedDict{String, Reaction}\nmetabolites :: OrderedDict{String, Metabolite}\ngenes :: OrderedDict{String, Gene}\n\nExample\n\nmodel = load_model(StandardModel, \"my_model.json\")\nkeys(model.reactions)\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#Base.convert-Tuple{Type{StandardModel}, MetabolicModel}","page":"Types","title":"Base.convert","text":"Base.convert(::Type{StandardModel}, model::MetabolicModel)\n\nConvert any MetabolicModel into a StandardModel. Note, some data loss may occur since only the generic interface is used during the conversion process.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.balance-Tuple{StandardModel}","page":"Types","title":"COBREXA.balance","text":"balance(model::StandardModel)\n\nReturn the balance of the linear problem, i.e. b in Sv = 0 where S is the stoichiometric matrix and v is the flux vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{StandardModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::StandardModel)::Tuple{Vector{Float64},Vector{Float64}}\n\nReturn the lower and upper bounds, respectively, for reactions in model. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_annotations-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.gene_annotations","text":"gene_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_name-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.gene_name","text":"gene_name(m::StandardModel, gid::String)\n\nReturn the name of gene with ID id.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.gene_notes-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.gene_notes","text":"gene_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with gene id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{StandardModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::StandardModel)\n\nReturn a vector of gene id strings in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.lower_bounds-Tuple{StandardModel}","page":"Types","title":"COBREXA.lower_bounds","text":"lower_bounds(model::StandardModel)::Vector{Float64}\n\nReturn the lower bounds for all reactions in model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_annotations-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_annotations","text":"metabolite_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_charge-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_charge","text":"metabolite_charge(model::StandardModel, id::String)\n\nReturn the charge associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_compartment-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_compartment","text":"metabolite_compartment(model::StandardModel, id::String)\n\nReturn compartment associated with metabolite id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_formula-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_formula","text":"metabolite_formula(model::StandardModel, id::String)\n\nReturn the formula of reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_name-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_name","text":"metabolite_name(m::StandardModel, mid::String)\n\nReturn the name of metabolite with ID id.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolite_notes-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.metabolite_notes","text":"metabolite_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with metabolite id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{StandardModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::StandardModel)\n\nReturn a vector of metabolite id strings contained in model. The order of metabolite strings returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{StandardModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::StandardModel)\n\nReturn the number of genes in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{StandardModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(model::StandardModel)\n\nReturn the number of metabolites in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{StandardModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::StandardModel)\n\nReturn the number of reactions contained in model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{StandardModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::StandardModel)\n\nReturn sparse objective vector for model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_annotations-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_annotations","text":"reaction_annotations(model::StandardModel, id::String)::Annotations\n\nReturn the annotation associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_gene_association-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_gene_association","text":"reaction_gene_association(model::StandardModel, id::String)\n\nReturn the gene reaction rule in string format for reaction with id in model. Return nothing if not available.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_name-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_name","text":"reaction_name(m::StandardModel, rid::String)\n\nReturn the name of reaction with ID id.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_notes-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_notes","text":"reaction_notes(model::StandardModel, id::String)::Notes\n\nReturn the notes associated with reaction id in model. Return an empty Dict if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_stoichiometry-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_stoichiometry","text":"reaction_stoichiometry(model::StandardModel, rid::String)::Dict{String, Float64}\n\nReturn the stoichiometry of reaction with ID rid.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_subsystem-Tuple{StandardModel, String}","page":"Types","title":"COBREXA.reaction_subsystem","text":"reaction_subsystem(id::String, model::StandardModel)\n\nReturn the subsystem associated with reaction id in model. Return nothing if not present.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{StandardModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::StandardModel)\n\nReturn a vector of reaction id strings contained in model. The order of reaction ids returned here matches the order used to construct the stoichiometric matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{StandardModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::StandardModel)\n\nReturn the stoichiometric matrix associated with model in sparse format.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.upper_bounds-Tuple{StandardModel}","page":"Types","title":"COBREXA.upper_bounds","text":"upper_bounds(model::StandardModel)::Vector{Float64}\n\nReturn the upper bounds for all reactions in model in sparse format. Order matches that of the reaction ids returned in reactions().\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#Model-type-wrappers","page":"Types","title":"Model type wrappers","text":"","category":"section"},{"location":"functions/types/","page":"Types","title":"Types","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"types\", \"wrappers\", file), readdir(\"../src/base/types/wrappers\"))","category":"page"},{"location":"functions/types/#COBREXA.GeckoModel","page":"Types","title":"COBREXA.GeckoModel","text":"struct GeckoModel <: ModelWrapper\n\nA model with complex enzyme concentration and capacity bounds, as described in Sánchez, Benjamín J., et al. \"Improving the phenotype predictions of a yeast genome-scale metabolic model by incorporating enzymatic constraints.\" Molecular systems biology 13.8 (2017): 935.\n\nUse make_gecko_model or with_gecko to construct this kind of model.\n\nThe model wraps another \"internal\" model, and adds following modifications:\n\nenzymatic reactions with known enzyme information are split into multiple forward and reverse variants for each isozyme,\nreaction coupling is added to ensure the groups of isozyme reactions obey the global reaction flux bounds from the original model,\ngene concentrations specified by each reaction and its gene product stoichiometry, can constrained by the user to reflect measurements, such as from mass spectrometry,\nadditional coupling is added to simulate total masses of different proteins grouped by type (e.g., membrane-bound and free-floating proteins), which can be again constrained by the user (this is slightly generalized from original GECKO algorithm, which only considers a single group of indiscernible proteins).\n\nThe structure contains fields columns that describe the contents of the stoichiometry matrix columns, coupling_row_reaction, coupling_row_gene_product and coupling_row_mass_group that describe correspondence of the coupling rows to original model and determine the coupling bounds (note: the coupling for gene product is actually added to stoichiometry, not in coupling), and inner, which is the original wrapped model. The objective of the model includes also the extra columns for individual genes, as held by coupling_row_gene_product.\n\nImplementation exposes the split reactions (available as reactions(model)), but retains the original \"simple\" reactions accessible by fluxes. The related constraints are implemented using coupling and coupling_bounds.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._gecko_capacity","page":"Types","title":"COBREXA._gecko_capacity","text":"struct _gecko_capacity\n\nA helper struct that contains the gene product capacity terms organized by the grouping type, e.g. metabolic or membrane groups etc.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._gecko_reaction_column","page":"Types","title":"COBREXA._gecko_reaction_column","text":"struct _gecko_reaction_column\n\nA helper type for describing the contents of GeckoModels.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.balance-Tuple{GeckoModel}","page":"Types","title":"COBREXA.balance","text":"balance(model::GeckoModel)\n\nReturn the balance of the reactions in the inner model, concatenated with a vector of zeros representing the enzyme balance of a GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.bounds-Tuple{GeckoModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::GeckoModel)\n\nReturn variable bounds for GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{GeckoModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(model::GeckoModel)\n\nReturn the coupling of GeckoModel. That combines the coupling of the wrapped model, coupling for split (arm) reactions, and the coupling for the total enzyme capacity.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{GeckoModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(model::GeckoModel)\n\nThe coupling bounds for GeckoModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.genes-Tuple{GeckoModel}","page":"Types","title":"COBREXA.genes","text":"genes(model::GeckoModel)\n\nReturn the gene ids of genes that have enzymatic constraints associated with them.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.metabolites-Tuple{GeckoModel}","page":"Types","title":"COBREXA.metabolites","text":"metabolites(model::GeckoModel)\n\nReturn the ids of all metabolites, both real and pseudo, for a GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(model::GeckoModel)\n\nCount the coupling constraints in GeckoModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_genes-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_genes","text":"n_genes(model::GeckoModel)\n\nReturn the number of genes that have enzymatic constraints associated with them.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_metabolites-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_metabolites","text":"n_metabolites(model::GeckoModel)\n\nReturn the number of metabolites, both real and pseudo, for a GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{GeckoModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::GeckoModel)\n\nReturns the number of all irreversible reactions in model as well as the number of gene products that take part in enzymatic reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{GeckoModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::GeckoModel)\n\nReturn the objective of the GeckoModel. Note, the objective is with respect to the internal variables, i.e. reactions(model), which are the unidirectional reactions and the genes involved in enzymatic reactions that have kinetic data.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{GeckoModel}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(model::GeckoModel)\n\nGet the mapping of the reaction rates in GeckoModel to the original fluxes in the wrapped model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{GeckoModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::GeckoModel)\n\nReturns the internal reactions in a GeckoModel (these may be split to forward- and reverse-only parts with different isozyme indexes; reactions IDs are mangled accordingly with suffixes).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{GeckoModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::GeckoModel)\n\nReturn a stoichiometry of the GeckoModel. The enzymatic reactions are split into unidirectional forward and reverse ones, each of which may have multiple variants per isozyme.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.SMomentModel","page":"Types","title":"COBREXA.SMomentModel","text":"struct SMomentModel <: ModelWrapper\n\nAn enzyme-capacity-constrained model using sMOMENT algorithm, as described by Bekiaris, Pavlos Stephanos, and Steffen Klamt, \"Automatic construction of metabolic models with enzyme constraints\" BMC bioinformatics, 2020.\n\nUse make_smoment_model or with_smoment to construct the models.\n\nThe model is constructed as follows:\n\nstoichiometry of the original model is retained as much as possible, but enzymatic reations are split into forward and reverse parts (marked by a suffix like ...#forward and ...#reverse),\ncoupling is added to simulate a virtual metabolite \"enzyme capacity\", which is consumed by all enzymatic reactions at a rate given by enzyme mass divided by the corresponding kcat,\nthe total consumption of the enzyme capacity is constrained to a fixed maximum.\n\nThe SMomentModel structure contains a worked-out representation of the optimization problem atop a wrapped MetabolicModel, in particular the separation of certain reactions into unidirectional forward and reverse parts, an \"enzyme capacity\" required for each reaction, and the value of the maximum capacity constraint. Original coupling in the inner model is retained.\n\nIn the structure, the field columns describes the correspondence of stoichiometry columns to the stoichiometry and data of the internal wrapped model, and total_enzyme_capacity is the total bound on the enzyme capacity consumption as specified in sMOMENT algorithm.\n\nThis implementation allows easy access to fluxes from the split reactions (available in reactions(model)), while the original \"simple\" reactions from the wrapped model are retained as fluxes. All additional constraints are implemented using coupling and coupling_bounds.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA._smoment_column","page":"Types","title":"COBREXA._smoment_column","text":"struct _smoment_column\n\nA helper type that describes the contents of SMomentModels.\n\n\n\n\n\n","category":"type"},{"location":"functions/types/#COBREXA.bounds-Tuple{SMomentModel}","page":"Types","title":"COBREXA.bounds","text":"bounds(model::SMomentModel)\n\nReturn the variable bounds for SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling-Tuple{SMomentModel}","page":"Types","title":"COBREXA.coupling","text":"coupling(model::SMomentModel)\n\nReturn the coupling of SMomentModel. That combines the coupling of the wrapped model, coupling for split reactions, and the coupling for the total enzyme capacity.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.coupling_bounds-Tuple{SMomentModel}","page":"Types","title":"COBREXA.coupling_bounds","text":"coupling_bounds(model::SMomentModel)\n\nThe coupling bounds for SMomentModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_coupling_constraints-Tuple{SMomentModel}","page":"Types","title":"COBREXA.n_coupling_constraints","text":"n_coupling_constraints(model::SMomentModel)\n\nCount the coupling constraints in SMomentModel (refer to coupling for details).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.n_reactions-Tuple{SMomentModel}","page":"Types","title":"COBREXA.n_reactions","text":"n_reactions(model::SMomentModel)\n\nThe number of reactions (including split ones) in SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.objective-Tuple{SMomentModel}","page":"Types","title":"COBREXA.objective","text":"objective(model::SMomentModel)\n\nReconstruct an objective of the SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reaction_flux-Tuple{SMomentModel}","page":"Types","title":"COBREXA.reaction_flux","text":"reaction_flux(model::SMomentModel)\n\nGet the mapping of the reaction rates in SMomentModel to the original fluxes in the wrapped model.\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.reactions-Tuple{SMomentModel}","page":"Types","title":"COBREXA.reactions","text":"reactions(model::SMomentModel)\n\nReturns the internal reactions in a SMomentModel (these may be split to forward- and reverse-only parts; reactions IDs are mangled accordingly with suffixes).\n\n\n\n\n\n","category":"method"},{"location":"functions/types/#COBREXA.stoichiometry-Tuple{SMomentModel}","page":"Types","title":"COBREXA.stoichiometry","text":"stoichiometry(model::SMomentModel)\n\nReturn a stoichiometry of the SMomentModel. The enzymatic reactions are split into unidirectional forward and reverse ones.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"functions/utils/#Helper-functions","page":"Utilities","title":"Helper functions","text":"","category":"section"},{"location":"functions/utils/","page":"Utilities","title":"Utilities","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"utils\", file), readdir(\"../src/base/utils\"))","category":"page"},{"location":"functions/utils/#COBREXA.ambiguously_identified_items-Tuple{Dict{String, Dict{String, Set{String}}}}","page":"Utilities","title":"COBREXA.ambiguously_identified_items","text":"ambiguously_identified_items(\n    index::Dict{String,Dict{String,[String]}},\n)::Vector{String}\n\nFind items (genes, metabolites, ...) from the annotation index that are identified non-uniquely by at least one of their annotations.\n\nThis often indicates that the items are duplicate or miscategorized.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.annotation_index-Tuple{AbstractDict{String}}","page":"Utilities","title":"COBREXA.annotation_index","text":"annotation_index(\n    xs::AbstractDict{String};\n    annotations = _annotations,\n)::Dict{String,Dict{String,[String]}}\n\nExtract annotations from a dictionary of items xs and build an index that maps annotation \"kinds\" (e.g. \"PubChem\") to the mapping from the annotations (e.g.  \"COMPOUND_12345\") to item IDs that carry the annotations.\n\nFunction annotations is used to access the Annotations object in the dictionary values.\n\nThis is extremely useful for finding items by annotation data.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.check_duplicate_reaction-Tuple{Reaction, OrderedCollections.OrderedDict{String, Reaction}}","page":"Utilities","title":"COBREXA.check_duplicate_reaction","text":"check_duplicate_reaction(rxn::Reaction, rxns::Dict{String, Reaction}; only_metabolites=true)\n\nCheck if rxn already exists in rxns but has another id. If only_metabolites is true then only the metabolite ids are checked. Otherwise, compares metabolite ids and the absolute value of their stoichiometric coefficients to those of rxn. If rxn has the same reaction equation as another reaction in rxns, the return the id. Otherwise return nothing.\n\nSee also: reaction_mass_balanced\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.is_boundary-Tuple{Dict{String, Float64}}","page":"Utilities","title":"COBREXA.is_boundary","text":"is_boundary(rxn_dict::Dict{String, Float64})\n\nReturn true if the reaction denoted by rxn_dict is a boundary reaction, otherwise return false. Checks if on boundary by inspecting the number of metabolites in rxn_dict. Boundary reactions have only one metabolite, e.g. an exchange reaction, or a sink/demand reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.reaction_atom_balance-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Utilities","title":"COBREXA.reaction_atom_balance","text":"reaction_atom_balance(model::StandardModel, rxn)\n\nReturns a dictionary mapping the stoichiometry of atoms through a single reaction. Uses the metabolite information in model to determine the mass balance. Accepts a reaction dictionary, a reaction string id or a Reaction as an argument for rxn.\n\nSee also: reaction_mass_balanced\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.reaction_mass_balanced-Tuple{StandardModel, String}","page":"Utilities","title":"COBREXA.reaction_mass_balanced","text":"reaction_mass_balanced(model::StandardModel, rxn)\n\nChecks if rxn is atom balanced. Returns a boolean for whether the reaction is balanced, and the associated balance of atoms for convenience (useful if not balanced). Calls reaction_atom_balance internally.\n\nSee also: check_duplicate_reaction, reaction_atom_balance\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.stoichiometry_string-Tuple{Any}","page":"Utilities","title":"COBREXA.stoichiometry_string","text":"stoichiometry_string(rxn_dict::Dict{String, Float64}; format_id = x -> x)\n\nReturn the reaction equation as a string. The metabolite strings can be manipulated by setting format_id.\n\nExample\n\njulia> req = Dict(\"coa_c\" => -1, \"for_c\" => 1, \"accoa_c\" => 1, \"pyr_c\" => -1)\njulia> stoichiometry_string(req)\n\"coa_c + pyr_c = for_c + accoa_c\"\n\njulia> stoichiometry_string(req; format_id = x -> x[1:end-2])\n\"coa + pyr = for + accoa\"\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.stoichiometry_string-Tuple{Reaction}","page":"Utilities","title":"COBREXA.stoichiometry_string","text":"stoichiometry_string(rxn::Reaction; kwargs)\n\nAlternative of stoichiometry_string take takes a Reaction as an argument.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.serialize_model-Tuple{Serialized, String}","page":"Utilities","title":"COBREXA.serialize_model","text":"serialize_model(model::Serialized, filename::String)::Serialized\n\nSpecialization of serialize_model that prevents nested serialization of already-serialized models.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.serialize_model-Union{Tuple{MM}, Tuple{MM, String}} where MM<:MetabolicModel","page":"Utilities","title":"COBREXA.serialize_model","text":"serialize_model(model::MM, filename::String)::Serialized{MM} where {MM<:MetabolicModel}\n\nSerialize the model to file filename, returning a Serialized model that can be loaded back transparently by precache!. The result does not contain the actual model data that are deferred to the disk; it may thus be used to save memory, or send the model efficiently to remote workers within distributed shared-storage environments.\n\nThe benefit of using this over \"raw\" Serialization.serialize is that the resulting Serialized model will reload itself automatically with precache! at first usage, which needs to be done manually when using the Serialization package directly.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{Gene}","page":"Utilities","title":"Base.copy","text":"Base.copy(g::Gene)\n\nShallow copy of a Gene\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{Metabolite}","page":"Utilities","title":"Base.copy","text":"Base.copy(m::Metabolite)\n\nShallow copy of a Metabolite\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{Reaction}","page":"Utilities","title":"Base.copy","text":"Base.copy(r::Reaction)\n\nShallow copy of a Reaction\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Base.copy-Tuple{StandardModel}","page":"Utilities","title":"Base.copy","text":"Base.copy(m::StandardModel)\n\nShallow copy of a StandardModel\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gamma_bounds-Tuple{Any}","page":"Utilities","title":"COBREXA.gamma_bounds","text":"gamma_bounds(gamma)\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to be at least gamma*Z₀, as usual in COBRA packages. Use as the bounds argument:\n\nflux_variability_analysis(model, some_optimizer; bounds = gamma_bounds(0.9))\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.objective_bounds-Tuple{Any}","page":"Utilities","title":"COBREXA.objective_bounds","text":"objective_bounds(tolerance)\n\nA bounds-generating function for flux_variability_analysis that limits the objective value to a small multiple of Z₀. Use as bounds argument, similarly to gamma_bounds.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_formula-Tuple{String}","page":"Utilities","title":"COBREXA._parse_formula","text":"_parse_formula(f::String)::MetaboliteFormula\n\nParse a formula in format C2H6O into a MetaboliteFormula, which is basically a dictionary of atom counts in the molecule.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._unparse_formula-Tuple{Dict{String, Int64}}","page":"Utilities","title":"COBREXA._unparse_formula","text":"_unparse_formula(f::MetaboliteFormula)::String\n\nFormat MetaboliteFormula to String.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_dict-Tuple{GeckoModel, Any}","page":"Utilities","title":"COBREXA.gene_product_dict","text":"gene_product_dict(model::GeckoModel, opt_model)\n\nReturn a dictionary mapping protein molar concentrations to their ids. The argument opt_model is a solved optimization problem, typically returned by flux_balance_analysis. See flux_dict for the corresponding function that returns a dictionary of solved fluxes.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_dict-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA.gene_product_dict","text":"gene_product_dict(model::GeckoModel)\n\nA pipe-able variant of gene_product_dict.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass-Tuple{SMomentModel, Any}","page":"Utilities","title":"COBREXA.gene_product_mass","text":"gene_product_mass(model::SMomentModel)\n\nExtract the total mass utilization in a solved SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass-Tuple{SMomentModel}","page":"Utilities","title":"COBREXA.gene_product_mass","text":"gene_product_mass(model::SMomentModel)\n\nA pipe-able variant of gene_product_mass.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass_group_dict-Tuple{GeckoModel, Any}","page":"Utilities","title":"COBREXA.gene_product_mass_group_dict","text":"gene_product_mass_group_dict(model::GeckoModel, opt_model)\n\nExtract the mass utilization in mass groups from a solved GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gene_product_mass_group_dict-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA.gene_product_mass_group_dict","text":"gene_product_mass_group_dict(model::GeckoModel)\n\nA pipe-able variant of gene_product_mass_group_dict.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.atom_fluxes-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Utilities","title":"COBREXA.atom_fluxes","text":"atom_fluxes(model::MetabolicModel, reaction_fluxes::Dict{String, Float64})\n\nReturn a dictionary mapping the flux of atoms across a flux solution given by reaction_fluxes using the reactions in model to determine the appropriate stoichiometry.\n\nNote, this function ignores metabolites with no formula assigned to them, no error message will be displayed.\n\nNote, if a model is mass balanced there should be not net flux of any atom. By removing reactions from the flux_solution you can investigate how that impacts the mass balances.\n\nExample\n\n# Find flux of Carbon through all metabolic reactions except the biomass reaction\ndelete!(fluxes, \"BIOMASS_Ecoli_core_w_GAM\")\natom_fluxes(model, fluxes)[\"C\"]\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.metabolite_fluxes-Tuple{MetabolicModel, Dict{String, Float64}}","page":"Utilities","title":"COBREXA.metabolite_fluxes","text":"metabolite_fluxes(model::MetabolicModel, flux_dict::Dict{String, Float64})\n\nReturn two dictionaries of metabolite ids mapped to reactions that consume or produce them, given the flux distribution supplied in flux_dict.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_gene_product_coupling-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_gene_product_coupling","text":"_gecko_gene_product_coupling(model::GeckoModel)\n\nCompute the part of the coupling for GeckoModel that limits the amount of each kind of protein available.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_mass_group_coupling-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_mass_group_coupling","text":"_gecko_mass_group_coupling(model::GeckoModel)\n\nCompute the part of the coupling for GeckoModel that limits the total mass of each group of gene products.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_column_reactions-Tuple{Any, Any}","page":"Utilities","title":"COBREXA._gecko_reaction_column_reactions","text":"_gecko_reaction_column_reactions(columns, inner)\n\nHelper method that doesn't require the whole GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_column_reactions-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_reaction_column_reactions","text":"_gecko_reaction_column_reactions(model::GeckoModel)\n\nRetrieve a utility mapping between reactions and split reactions; rows correspond to \"original\" reactions, columns correspond to \"split\" reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_coupling-Tuple{GeckoModel}","page":"Utilities","title":"COBREXA._gecko_reaction_coupling","text":"_gecko_reaction_coupling(model::GeckoModel)\n\nCompute the part of the coupling for GeckoModel that limits the \"arm\" reactions (which group the individual split unidirectional reactions).\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._gecko_reaction_name-Tuple{String, Int64, Int64}","page":"Utilities","title":"COBREXA._gecko_reaction_name","text":"_gecko_reaction_name(original_name::String, direction::Int)\n\nInternal helper for systematically naming reactions in GeckoModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_grr-Tuple{SBML.GeneProductAssociation}","page":"Utilities","title":"COBREXA._parse_grr","text":"_parse_grr(gpa::SBML.GeneProductAssociation)::GeneAssociation\n\nParse SBML.GeneProductAssociation structure to the simpler GeneAssociation. The input must be (implicitly) in a positive DNF.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_grr-Tuple{String}","page":"Utilities","title":"COBREXA._parse_grr","text":"_parse_grr(s::String)::GeneAssociation\n\nParse a DNF gene association rule in format (YIL010W and YLR043C) or (YIL010W and YGR209C) to GeneAssociation. Also acceptsOR,|,||,AND,&, and&&`.\n\nExample\n\njulia> _parse_grr(\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\")\n2-element Array{Array{String,1},1}:\n [\"YIL010W\", \"YLR043C\"]\n [\"YIL010W\", \"YGR209C\"]\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._parse_grr_to_sbml-Tuple{String}","page":"Utilities","title":"COBREXA._parse_grr_to_sbml","text":"_parse_grr_to_sbml(str::String)::Maybe{SBML.GeneProductAssociation}\n\nInternal helper for parsing the string GRRs into SBML data structures. More general than _parse_grr.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._unparse_grr-Tuple{Type{SBML.GeneProductAssociation}, Vector{Vector{String}}}","page":"Utilities","title":"COBREXA._unparse_grr","text":"_unparse_grr(\n    ::Type{SBML.GeneProductAssociation},\n    x::GeneAssociation,\n)::SBML.GeneAssociation\n\nConvert a GeneAssociation to the corresponding SBML.jl structure.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._unparse_grr-Tuple{Type{String}, Vector{Vector{String}}}","page":"Utilities","title":"COBREXA._unparse_grr","text":"unparse_grr(grr::Vector{Vector{Gene}}\n\nConverts a nested string gene reaction array  back into a gene reaction rule string.\n\nExample\n\njulia> _unparse_grr(String, [[\"YIL010W\", \"YLR043C\"], [\"YIL010W\", \"YGR209C\"]])\n\"(YIL010W and YLR043C) or (YIL010W and YGR209C)\"\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._guesskey-Tuple{Any, Any}","page":"Utilities","title":"COBREXA._guesskey","text":"_guesskey(ks, possibilities)\n\nUnfortunately, many model types that contain dictionares do not have standardized field names, so we need to try a few possibilities and guess the best one. The keys used to look for valid field names should be ideally specified as constants in src/base/constants.jl.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.gets-Tuple{Any, Any, Any}","page":"Utilities","title":"COBREXA.gets","text":"gets(collection, fail, keys)\n\nReturn fail if key in keys is not in collection, otherwise return collection[key]. Useful if may different keys need to be tried due to non-standardized model formats.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_biomass_reaction_ids-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_biomass_reaction_ids","text":"find_biomass_reaction_ids(m::MetabolicModel; kwargs...)\n\nShortcut for finding biomass reaction identifiers in a model; arguments are forwarded to looks_like_biomass_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_biomass_reactions-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_biomass_reactions","text":"find_biomass_reactions(m::MetabolicModel; kwargs...)\n\nShortcut for finding biomass reaction indexes in a model; arguments are forwarded to looks_like_biomass_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_exchange_reaction_ids-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_exchange_reaction_ids","text":"find_exchange_reaction_ids(m::MetabolicModel; kwargs...)\n\nShortcut for finding exchange reaction identifiers in a model; arguments are forwarded to looks_like_exchange_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_exchange_reactions-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_exchange_reactions","text":"find_exchange_reactions(m::MetabolicModel; kwargs...)\n\nShortcut for finding exchange reaction indexes in a model; arguments are forwarded to looks_like_exchange_reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_extracellular_metabolite_ids-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_extracellular_metabolite_ids","text":"find_extracellular_metabolite_ids(m::MetabolicModel; kwargs...)\n\nShortcut for finding extracellular metabolite identifiers in a model; arguments are forwarded to looks_like_extracellular_metabolite.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.find_extracellular_metabolites-Tuple{MetabolicModel}","page":"Utilities","title":"COBREXA.find_extracellular_metabolites","text":"find_extracellular_metabolites(m::MetabolicModel; kwargs...)\n\nShortcut for finding extracellular metabolite indexes in a model; arguments are forwarded to looks_like_extracellular_metabolite.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.looks_like_biomass_reaction-Tuple{String}","page":"Utilities","title":"COBREXA.looks_like_biomass_reaction","text":"looks_like_biomass_reaction(rxn_id::String;\n    exclude_exchanges = false,\n    exchange_prefixes = _constants.exchange_prefixes,\n    biomass_strings = _constants.biomass_strings,\n)::Bool\n\nA predicate that matches reaction identifiers that look like biomass reactions. Biomass reactions are identified by looking for occurences of biomass_strings in the reaction id. If exclude_exchanges is set, the strings that look like exchanges (from looks_like_exchange_reaction) will not match.\n\nExample\n\nfilter(looks_like_biomass_reaction, reactions(model)) # returns strings\nfindall(looks_like_biomass_reaction, reactions(model)) # returns indices\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.looks_like_exchange_reaction-Tuple{String}","page":"Utilities","title":"COBREXA.looks_like_exchange_reaction","text":"looks_like_exchange_reaction(rxn_id::String;\n    exclude_biomass = false,\n    biomass_strings = _constants.biomass_strings,\n    exchange_prefixes = _constants.exchange_prefixes,\n)\n\nA predicate that matches reaction identifiers that look like exchange or biomass reactions, given the usual naming schemes in common model repositories. Exchange reactions are identified based on matching prefixes in the set exchange_prefixes and biomass reactions are identified by looking for occurences of biomass_strings in the reaction id.\n\nAlso see find_exchange_reactions.\n\nExample\n\nfindall(looks_like_exchange_reaction, reactions(model)) # returns indices\nfilter(looks_like_exchange_reaction, reactions(model)) # returns Strings\n\n# to use the optional arguments you need to expand the function's arguments\n# using an anonymous function\nfindall(x -> looks_like_exchange_reaction(x; exclude_biomass=true), reactions(model)) # returns indices\nfilter(x -> looks_like_exchange_reaction(x; exclude_biomass=true), reactions(model)) # returns Strings\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.looks_like_extracellular_metabolite-Tuple{String}","page":"Utilities","title":"COBREXA.looks_like_extracellular_metabolite","text":"looks_like_extracellular_metabolite(rxn_id::String;\n    extracellular_suffixes = _constants.extracellular_suffixes,\n)::Bool\n\nA predicate that matches metabolite identifiers that look like they are extracellular metabolites. Extracellular metabolites are identified by extracellular_suffixes at the end of the metabolite id.\n\nExample\n\nfilter(looks_like_extracellular_metabolite, metabolites(model)) # returns strings\nfindall(looks_like_extracellular_metabolite, metabolites(model)) # returns indices\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._smoment_column_reactions-Tuple{SMomentModel}","page":"Utilities","title":"COBREXA._smoment_column_reactions","text":"_smoment_column_reactions(model::SMomentModel)\n\nRetrieve a utility mapping between reactions and split reactions; rows correspond to \"original\" reactions, columns correspond to \"split\" reactions.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA._smoment_reaction_name-Tuple{String, Int64}","page":"Utilities","title":"COBREXA._smoment_reaction_name","text":"_smoment_reaction_name(original_name::String, direction::Int)\n\nInternal helper for systematically naming reactions in SMomentModel.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.smoment_isozyme_speed-Tuple{Function}","page":"Utilities","title":"COBREXA.smoment_isozyme_speed","text":"smoment_isozyme_speed(gene_product_molar_mass::Function)\n\nA piping- and argmax-friendly overload of smoment_isozyme_speed.\n\nExample\n\ngene_mass_function = gid -> 1.234\n\nbest_isozyme_for_smoment = argmax(\n    smoment_isozyme_speed(gene_mass_function),\n    my_isozyme_vector,\n)\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.smoment_isozyme_speed-Tuple{Isozyme, Any}","page":"Utilities","title":"COBREXA.smoment_isozyme_speed","text":"smoment_isozyme_speed(isozyme::Isozyme, gene_product_molar_mass)\n\nCompute a \"score\" for picking the most viable isozyme for make_smoment_model, based on maximum kcat divided by relative mass of the isozyme. This is used because sMOMENT algorithm can not handle multiple isozymes for one reaction.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#Macro-generated-functions-and-internal-helpers","page":"Utilities","title":"Macro-generated functions and internal helpers","text":"","category":"section"},{"location":"functions/utils/","page":"Utilities","title":"Utilities","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"macros\", file), readdir(\"../src/base/macros\"))","category":"page"},{"location":"functions/utils/#COBREXA.@_change_bounds_fn-Tuple{Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_change_bounds_fn","text":"@_change_bounds_fn ModelType IdxType [plural] [inplace] begin ... end\n\nA helper for creating simple bounds-changing function similar to change_bounds.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA._inherit_model_methods_impl-Tuple{Any, Symbol, Any, Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA._inherit_model_methods_impl","text":"_inherit_model_methods_impl(mtype::Symbol, arglist, access, fwdlist, fns...)\n\nA helper backend for @_inherit_model_methods and @_inherit_model_methods_fn.\n\n\n\n\n\n","category":"method"},{"location":"functions/utils/#COBREXA.@_inherit_model_methods-Tuple{Symbol, Any, Symbol, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_inherit_model_methods","text":"@_inherit_model_methods\n\nGenerates trivial accessor functions listed in fns for a model that is wrapped in type mtype as field member.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA.@_inherit_model_methods_fn-Tuple{Symbol, Any, Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_inherit_model_methods_fn","text":"@_inherit_model_methods_fn\n\nA more generic version of @_inherit_model_methods that accesses the \"inner\" model using an accessor function name.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA.@_remove_fn-Tuple{Any, Any, Any, Vararg{Any}}","page":"Utilities","title":"COBREXA.@_remove_fn","text":"@ _remove_fn objname ModelType IndexType [plural] [inplace] begin ... end\n\nA helper for creating functions that follow the remove_objname template, such as remove_metabolites and remove_reaction.\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#COBREXA.@_serialized_change_unwrap-Tuple{Symbol}","page":"Utilities","title":"COBREXA.@_serialized_change_unwrap","text":"@_serialized_change_unwrap function\n\nCreates a simple wrapper structure that calls the function transparently on the internal precached model. The internal type is returned (otherwise this would break the consistency of serialization).\n\n\n\n\n\n","category":"macro"},{"location":"functions/utils/#Logging-and-debugging-helpers","page":"Utilities","title":"Logging and debugging helpers","text":"","category":"section"},{"location":"functions/utils/","page":"Utilities","title":"Utilities","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", \"logging\", file), readdir(\"../src/base/logging\"))","category":"page"},{"location":"functions/utils/#COBREXA.log_io","page":"Utilities","title":"COBREXA.log_io","text":"log_io(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of messages and warnings from model input/output.\n\n\n\n\n\n","category":"function"},{"location":"functions/utils/#COBREXA.log_models","page":"Utilities","title":"COBREXA.log_models","text":"log_models(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of model-related messages.\n\n\n\n\n\n","category":"function"},{"location":"functions/utils/#COBREXA.log_perf","page":"Utilities","title":"COBREXA.log_perf","text":"log_perf(enable::Bool=true)\n\nEnable (default) or disable (by passing false) output of performance-related tracing information.\n\n\n\n\n\n","category":"function"},{"location":"functions/utils/#COBREXA.@_make_logging_tag-Tuple{Symbol, String}","page":"Utilities","title":"COBREXA.@_make_logging_tag","text":"macro _make_logging_group(sym::Symbol, doc::String)\n\nThis creates a group of functions that allow masking out topic-related logging actions. A call that goes as follows:\n\n@_make_logging_tag XYZ\n\ncreates the following tools:\n\nglobal variable _XYZ_log_enabled defaulted to false\nfunction log_XYZ that can be called to turn the logging on/off\na masking macro @_XYZ_log that can be prepended to commands that should only happen if the logging of tag XYZ is enabled.\n\nThe masking macro is then used as follows:\n\n@_XYZ_log @info \"This is the extra verbose information you wanted!\" a b c\n\nThe user can direct logging with these:\n\nlog_XYZ()\nlog_XYZ(false)\n\ndoc should be a name of the stuff that is being printed if the corresponding log_XYZ() is enabled – it is used to create a friendly documentation for the logging switch. In this case it could say \"X, Y and Z-related messages\".\n\n\n\n\n\n","category":"macro"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/2_finding_balance.jl\"","category":"page"},{"location":"notebooks/2_finding_balance/#Finding-balance-and-variability-of-constraint-based-models","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Here we will use flux_balance_analysis, flux_variability_analysis, parsimonious_flux_balance_analysis, and minimize_metabolic_adjustment_analysis, along with the modification functions of COBREXA.jl, to analyze a toy model of E. coli.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"If it is not already present, download the model.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"tip: Tip: use `?` to get quick help about functions\nWhen you are unsure about how a function works, write ?   function_name to see the function reference documentation.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"notebooks/2_finding_balance/#Optimization-solvers-in-COBREXA","page":"Finding balance and variability of constraint-based models","title":"Optimization solvers in COBREXA","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"To actually perform any optimization based analysis we need to load an optimizer. Any JuMP.jl-supported optimizers will work. Here, we will use Tulip.jl to optimize linear programs and OSQP.jl to optimize quadratic programs.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"note: Note: OSQP can be sensitive\nWe recommend reading the docs of OSQP before using it, since   it may give inconsistent results depending on what settings   you use. Commercial solvers like Gurobi, Mosek, CPLEX, etc.   require less user engagement.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"using Tulip, OSQP, GLPK","category":"page"},{"location":"notebooks/2_finding_balance/#Flux-balance-analysis-(FBA)","page":"Finding balance and variability of constraint-based models","title":"Flux balance analysis (FBA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Most analysis functions come in several variants that produce different types of output. All of them usually require a model and JuMP.jl-compatible optimizer to work in the model.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"In the case of FBA, you may choose from these variants (here using the Tulip optimizer):","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"vec_soln = flux_balance_analysis_vec(model, Tulip.Optimizer)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"notebooks/2_finding_balance/#Extending-FBA-with-modifications","page":"Finding balance and variability of constraint-based models","title":"Extending FBA with modifications","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Often it is desirable to add a slight modification to the problem before performing analysis, to see e.g. differences of the model behavior caused by the change introduced.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"COBREXA.jl supports several modifications by default, which include changing objective sense, optimizer attributes, flux constraints, optimization objective, reaction and gene knockouts, and others. These modifications are applied in the order they are specified. It is up to the user to ensure that the changes are sensible.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [ # modifications are applied in order\n        # this changes the objective to maximize the biomass production\n        change_objective(\"R_BIOMASS_Ecoli_core_w_GAM\"),\n\n        # this fixes a specific rate of the glucose exchange\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12),\n\n        # this knocks out two genes, i.e. constrains their associated reactions to zero.\n        knockout([\"b0978\", \"b0734\"]), ## the gene IDs are cytochrome oxidase (CYTBD)\n\n        # ignore the optimizer specified above and change it to Tulip\n        change_optimizer(Tulip.Optimizer),\n\n        # set a custom attribute of the Tulip optimizer (see Tulip docs for more possibilities)\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 110),\n\n        # explicitly tell the optimizer to maximize the new objective\n        change_sense(MAX_SENSE),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"This solution can be display using flux_summary. Note, this pretty printing only works on flux solutions that are represented as dictionaries.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"flux_summary(dict_soln)","category":"page"},{"location":"notebooks/2_finding_balance/#Flux-variability-analysis-(FVA)","page":"Finding balance and variability of constraint-based models","title":"Flux variability analysis (FVA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"The default FVA in flux_variability_analysis returns maximized and minimized reaction fluxes in a matrix. Here we use the dictionary variant in fluxvariabilityanalysis_dict, to show how to easily access specific fluxes from its results.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_mins, fva_maxs = flux_variability_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.99), # the objective function is allowed to vary by ~1% from the FBA optimum\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"R_EX_glc__D_e\"; lb = -10, ub = -10),\n        change_constraint(\"R_EX_o2_e\"; lb = 0.0, ub = 0.0),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_maxs[\"R_EX_ac_e\"][\"R_EX_ac_e\"] # get the maximal acetate exchange flux","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Another option is to display this information using flux_variability_summary. This pretty printing only works on flux variability analysis results where dictionary keys indicate which flux is optimized and the associated value is a flux dictionary.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"flux_variability_summary((fva_mins, fva_maxs))","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"More sophisticated variants of flux_variability_analysis can be used to extract specific pieces of information from the solved optimization problems. Here the objective value of the minimized flux and the associated biomass growth rate is returned instead of every flux.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"biomass_idx = first(indexin([\"R_BIOMASS_Ecoli_core_w_GAM\"], reactions(model))) # index of biomass function\nvs = flux_variability_analysis(\n    model,\n    Tulip.Optimizer;\n    bounds = objective_bounds(0.50), # biomass can vary up to 50% less than optimum\n    modifications = [\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500),\n        change_constraint(\"R_EX_glc__D_e\"; lb = -10, ub = -10),\n        change_constraint(\"R_EX_o2_e\"; lb = 0.0, ub = 0.0),\n    ],\n    ret = m ->\n        (COBREXA.JuMP.objective_value(m), COBREXA.JuMP.value(m[:x][biomass_idx])), # m is the model and m[:x] extracts the fluxes from the model\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"fva_mins = Dict(rxn => flux for (rxn, flux) in zip(reactions(model), vs[:, 1]))","category":"page"},{"location":"notebooks/2_finding_balance/#Parsimonious-flux-balance-analysis-(pFBA)","page":"Finding balance and variability of constraint-based models","title":"Parsimonious flux balance analysis (pFBA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Parsimonious flux balance analysis (here in parsimonious_flux_balance_analysis finds a unique flux solution that minimizes the squared sum of fluxes of the system subject, while maintaining the same objective value as the flux balance analysis solution. Since we are optimizing a quadratic objective, we also need to switch to a quadratic optimizer. In this case, OSQP will work. We demonstrate it on the dictionary-returning variant of pFBA, parsimonious_flux_balance_analysis_dict:","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"dict_soln = parsimonious_flux_balance_analysis_dict(\n    model,\n    OSQP.Optimizer;\n    modifications = [\n        silence, # silence the optimizer (OSQP is very verbose by default)\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12),\n        change_optimizer_attribute(\"polish\", true),\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"The function also has the expectable second variant that returns a vector of solutions, in parsimonious_flux_balance_analysis_vec. Here, we utilize it to show how to use different optimizers for finding the optimum and for solving the quadratic problem. That may be preferable if the optimizer qualities differ for the differing tasks. pFBA allows you to specify qp_modifications that are applied after the original optimum is found, and before the quadratic part of the problem solving begins.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"vec_soln = parsimonious_flux_balance_analysis_vec(\n    model,\n    Tulip.Optimizer; # start with Tulip\n    modifications = [\n        change_constraint(\"R_EX_glc__D_e\"; lb = -12, ub = -12),\n        change_optimizer_attribute(\"IPM_IterationsLimit\", 500), # we may change Tulip-specific attributes here\n    ],\n    qp_modifications = [\n        change_optimizer(OSQP.Optimizer), # now switch to OSQP (Tulip wouldn't be able to finish the computation)\n        change_optimizer_attribute(\"polish\", true), # get an accurate solution, see OSQP's documentation\n        silence, # and make it quiet.\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/#Minimizing-metabolic-adjustment-analysis-(MOMA)","page":"Finding balance and variability of constraint-based models","title":"Minimizing metabolic adjustment analysis (MOMA)","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"MOMA is a technique used to find a flux distribution that is closest to some reference distribution with respect to the Euclidian norm.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"reference_fluxes = parsimonious_flux_balance_analysis_dict( # reference distribution\n    model,\n    OSQP.Optimizer;\n    modifications = [silence, change_optimizer_attribute(\"polish\", true)],\n)\n\nmoma = minimize_metabolic_adjustment_analysis_dict(\n    model,\n    reference_fluxes,\n    OSQP.Optimizer;\n    modifications = [\n        silence,\n        change_optimizer_attribute(\"polish\", true),\n        change_constraint(\"R_CYTBD\"; lb = 0.0, ub = 0.0), # find flux distribution closest to the CYTBD knockout\n    ],\n)","category":"page"},{"location":"notebooks/2_finding_balance/#Composing-(more-complicated)-modifications","page":"Finding balance and variability of constraint-based models","title":"Composing (more complicated) modifications","text":"","category":"section"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"COBREXA.jl contains a number of modifications that allow the user to analyze non-standard variants of the classic FBA problem. These include thermodynamic (add_loopless_constraints), capacity (add_crowding_constraints), and kinetic/capacity (add_moment_constraints) modifications. The documentation of each modification details what their purpose is. Here, we will demonstrate how these modifications can be composed to generate even more interesting analyses.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Download the json formatted model so that the reaction identifiers correspond to the Escher map.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nmodel = load_model(\"e_coli_core.json\")","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"First find a flux distribution that is thermodyamically loopless and incorporates enzyme capacity constraints by composing loopless FBA and FBAwMC.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"rid_crowding_weight = Dict(# crowding needs a weight for each flux\n    rid => 0.004 for rid in reactions(model) if\n    !looks_like_biomass_reaction(rid) && !looks_like_exchange_reaction(rid)\n)\n\nloopless_crowding_fluxes = flux_balance_analysis_dict(\n    model,\n    GLPK.Optimizer;\n    modifications = [\n        add_crowding_constraints(rid_crowding_weight),\n        add_loopless_constraints(),\n    ],\n)\nflux_summary(loopless_crowding_fluxes)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Next find a flux distribution that satisfies kinetic/capacity constraints using the moment algorithm that is closest (using MOMA) to the loopless crowding solution.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"ksas = Dict(rid => 1000.0 for rid in reactions(model)) # make up specific activities of the enyzmes\nprotein_mass_fraction = 0.56\n\nmoment_moma = minimize_metabolic_adjustment_analysis_dict(\n    model,\n    loopless_crowding_fluxes,\n    OSQP.Optimizer;\n    modifications = [\n        silence,\n        change_optimizer_attribute(\"polish\", true),\n        change_optimizer_attribute(\"max-iter\", 10_000),\n        change_constraint(\"EX_glc__D_e\", lb = -1000),\n        change_constraint(\"CYTBD\"; lb = 0, ub = 0),\n        add_moment_constraints(ksas, protein_mass_fraction;),\n    ],\n)\nflux_summary(moment_moma)","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"Finally, plot the results to inspect the flux distributions visually","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"using CairoMakie, Escher, ColorSchemes\n\n!isfile(\"e_coli_core_map.json\") && download( # download escher map\n    \"http://bigg.ucsd.edu/escher_map_json/e_coli_core.Core%20metabolism\",\n    \"e_coli_core_map.json\",\n)\n\nmaxflux = maximum(abs.(values(moment_moma)))\nminflux = minimum(abs.(values(moment_moma)))\n\ncolor_interp(x) = begin # Scale color of reaction edges to fluxes (manually binned)\n    normed_x = (abs(x) - minflux) / (maxflux - minflux)\n    if 0 <= normed_x < 0.01\n        ColorSchemes.RdYlBu_4[4]\n    elseif 0.01 <= normed_x < 0.25\n        ColorSchemes.RdYlBu_4[3]\n    elseif 0.25 <= normed_x < 0.5\n        ColorSchemes.RdYlBu_4[2]\n    else\n        ColorSchemes.RdYlBu_4[1]\n    end\nend\nrc = Dict(k => color_interp(v) for (k, v) in moment_moma) # map reaction id to reaction edge color\n\nfig = Figure();\nax = Axis(fig[1, 1]);\nescherplot!(ax, \"e_coli_core_map.json\", reaction_edge_colors = rc)\nhidexdecorations!(ax)\nhideydecorations!(ax)\nfig","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"tip: Tip: code your own modifications\nMaking custom problem modification functions is really simple due to the   tight intergration between COBREXA and JuMP. Look at the source code for   the implemented modifications in src\\analysis\\modifications to get a flavour   for it.","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"","category":"page"},{"location":"notebooks/2_finding_balance/","page":"Finding balance and variability of constraint-based models","title":"Finding balance and variability of constraint-based models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/1_loading_converting_saving.jl\"","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Loading,-converting,-and-saving-models","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"COBREXA can load models stored in .mat, .json, and .xml formats (with the latter denoting SBML formatted models).","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"We will primarily use the E. Coli \"core\" model to demonstrate the utilities found in COBREXA. First, let's download the model in several formats.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"# Downloads the model files if they don't already exist\n!isfile(\"e_coli_core.mat\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.mat\", \"e_coli_core.mat\");\n!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\");\n!isfile(\"e_coli_core.xml\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\");\nnothing #hide","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Now, load the package:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using COBREXA","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"tip: Save bandwidth!\nThe published models usually do not change very often. It is therefore pretty useful to save them to a central location and load them from there. That saves your time, and does not unnecessarily consume the connectivity resources of the model repository.","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Loading-models","page":"Loading, converting, and saving models","title":"Loading models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Load the models using the load_model function. Each model is able to \"pretty-print\" itself, hiding the inner complexity.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"mat_model = load_model(\"e_coli_core.mat\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"json_model = load_model(\"e_coli_core.json\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"sbml_model = load_model(\"e_coli_core.xml\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"note: Note: `load_model` infers the output type from the file extension\nNotice how each model was read into memory as a model type corresponding   to its file type, i.e. the file ending with .json loaded as a   JSONModel, the file ending with .mat loaded as MATModel, and the   file ending with .xml loaded as an SBMLModel.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"You can directly inspect the model objects, although only with a specific way for each specific type.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"JSON models contain their corresponding JSON:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"json_model.json","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"SBML models contain a complicated structure from SBML.jl package:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"typeof(sbml_model.sbml)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"MAT models contain MATLAB data:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"mat_model.mat","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Using-the-generic-interface-to-access-model-details","page":"Loading, converting, and saving models","title":"Using the generic interface to access model details","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"To prevent the complexities of object representation, COBREXA.jl uses a set of generic interface functions that extract various important information from all supported model types. This approach ensures that the analysis functions can work on any data.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"For example, you can check the reactions and metabolites contained in SBML and JSON models using the same accessor:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"reactions(json_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"reactions(sbml_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"issetequal(reactions(json_model), reactions(mat_model)) # do models contain the same reactions?","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"All accessors are defined in a single file in COBREXA source code; you may therefore get a list of all accessors as follows:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using InteractiveUtils\n\nfor method in filter(\n    x -> endswith(string(x.file), \"MetabolicModel.jl\"),\n    InteractiveUtils.methodswith(MetabolicModel, COBREXA),\n)\n    println(method.name)\nend","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Converting-between-model-types","page":"Loading, converting, and saving models","title":"Converting between model types","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"It is possible to convert model types to-and-fro. To do this, use the convert function, which is overloaded from Julia's Base.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"danger: Data loss may occur when converting between models\nThe conversion of models only uses the data accessible through the generic accessors. Other data may get lost.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m = convert(MATModel, json_model)","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m will now contain the MATLAB-style matrix representation of the model:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Matrix(m.mat[\"S\"])","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"The loading and conversion can be combined using a shortcut:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"m = load_model(MATModel, \"e_coli_core.json\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/#Saving-and-exporting-models","page":"Loading, converting, and saving models","title":"Saving and exporting models","text":"","category":"section"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"COBREXA.jl supports exporting the models in JSON and MAT format, using save_model.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"save_model(m, \"converted_model.json\")\nsave_model(m, \"converted_model.mat\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"If you need a non-standard suffix, use the type-specific saving functions:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"save_json_model(m, \"file.without.a.good.suffix\")\nsave_mat_model(m, \"another.file.matlab\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"If you are saving the models only for future processing in Julia environment, it is often wasteful to encode the models to external formats and decode them back. Instead, you can use the \"native\" Julia data format, accessible with package Serialization.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This way, you can use serialize to save even the StandardModel that has no file format associated:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"using Serialization\n\nsm = convert(StandardModel, m)\n\nopen(f -> serialize(f, sm), \"myModel.stdmodel\", \"w\")","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"The models can then be loaded back using deserialize:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"sm2 = deserialize(\"myModel.stdmodel\")\nissetequal(metabolites(sm), metabolites(sm2))","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This form of loading operation is usually pretty quick:","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"t = @elapsed deserialize(\"myModel.stdmodel\")\n@info \"Deserialization took $t seconds\"","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"Notably, large and complicated models with thousands of reactions and annotations can take seconds to decode properly. Serialization allows you to almost completely remove this overhead, and scales well to tens of millions of reactions.","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"","category":"page"},{"location":"notebooks/1_loading_converting_saving/","page":"Loading, converting, and saving models","title":"Loading, converting, and saving models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/3_basic_stdmodel_usage.jl\"","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Basic-usage-of-StandardModel","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"In this tutorial we will use COBREXA's StandardModel and functions that specifically operate on it. As usual we will use the toy model of E. coli for demonstration.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"!isfile(\"e_coli_core.json\") &&\n    download(\"http://bigg.ucsd.edu/static/models/e_coli_core.json\", \"e_coli_core.json\")\n\nusing COBREXA","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Loading-a-model","page":"Basic usage of StandardModel","title":"Loading a model","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model = load_model(StandardModel, \"e_coli_core.json\") # we specifically want to load a StandardModel from the model file","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"note: Note: Loading `StandardModel`s implicitly uses `convert`\nWhen using load_model(StandardModel, file_location) the model at   file_location is first loaded into its inferred format and is then   converted to a StandardModel using the generic accessor interface.   Thus, data loss may occur. Always check your model to ensure that   nothing important has been lost.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Basic-analysis","page":"Basic usage of StandardModel","title":"Basic analysis","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"As before, for optimization based analysis we need to load an optimizer. Here we will use Tulip.jl to solve the linear programs of this tutorial. Refer to the basic constraint-based analysis tutorial for more informaiton.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"All the normal analysis functions work on StandardModel, due to it also having the same generic accessor interface as all the other model types.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"using Tulip\n\nfluxes = flux_balance_analysis_dict(\n    model,\n    Tulip.Optimizer;\n    modifications = [\n        change_objective(\"BIOMASS_Ecoli_core_w_GAM\"),\n        change_constraint(\"EX_glc__D_e\"; lb = -12, ub = -12),\n        change_constraint(\"EX_o2_e\"; lb = 0, ub = 0),\n    ],\n)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"This is not very exciting yet, since every other model type can also do this. However, deeper inspection of flux results is possible when using StandardModel.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Inspecting-the-flux-solution:-atom_fluxes","page":"Basic usage of StandardModel","title":"Inspecting the flux solution: atom_fluxes","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"It is sometimes interesting to keep track of the atoms entering and leaving the system through boundary reactions. This can be inspected by calling atom_fluxes. That gives you the flux of individual atoms getting consumed and produced by all reactions, based on fluxes. We erase the reaction that consumes the atoms for creating biomass, to see how much mass the \"rest\" of the reaction produces for it:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fluxes_without_biomass = copy(fluxes);\ndelete!(fluxes_without_biomass, \"BIOMASS_Ecoli_core_w_GAM\");\natom_fluxes(model, fluxes_without_biomass)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Inspecting-the-flux-solution:-metabolite_fluxes","page":"Basic usage of StandardModel","title":"Inspecting the flux solution: metabolite_fluxes","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another useful flux result analysis function is metabolite_fluxes. This function gives an overview of reactions consuming and producing each metabolite.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"consuming, producing = metabolite_fluxes(model, fluxes)\n\nconsuming[\"atp_c\"] # reactions consuming `atp_c`","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Internals-of-StandardModel","page":"Basic usage of StandardModel","title":"Internals of StandardModel","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another benefit of StandardModel is that it supports a richer internal infrastructure that can be used to manipulate internal model attributes in a systematic way. Specifically, the genes, reactions, and metabolites with of a model each have a type. This is particularly useful when modifying or even constructing a model from scratch.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Genes,-Reactions,-and-Metabolites","page":"Basic usage of StandardModel","title":"Genes, Reactions, and Metabolites","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel is composed of ordered dictionaries of Genes, Metabolites and Reactions. Ordered dictionaries are used because the order of the reactions and metabolites are important for constructing a stoichiometric matrix since the rows and columns should correspond to the order of the metabolites and reactions returned by calling the accessors metabolites and reactions.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Each StandardModel is composed of the following fields:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(StandardModel) # fields of a StandardModel","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The :genes field of a StandardModel contains an ordered dictionary of gene ids mapped to Genes.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"model.genes # the keys of this dictionary are the same as genes(model)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The Gene type is a struct that can be used to store information about genes in a StandardModel. Each Gene is composed of the following fields:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"fieldnames(Gene)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"tip: Tip: Use <tab> complete to explore the structure of types\nUse <tab> to quickly explore the fields of a struct. For example,   Gene.<tab> will list all the fields shown above.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The keys used in the ordered dictionaries in model.genes are the ids returned using the generic accessor genes. Genes have pretty printing, as demonstrated below for a random gene drawn from the model:","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_gene_id = genes(model)[rand(1:n_genes(model))]\nmodel.genes[random_gene_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The same idea holds for both metabolites (stored as Metabolites) and reactions (stored as Reactions). This is demonstrated below.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_metabolite_id = metabolites(model)[rand(1:n_metabolites(model))]\nmodel.metabolites[random_metabolite_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"random_reaction_id = reactions(model)[rand(1:n_reactions(model))]\nmodel.reactions[random_reaction_id]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"StandardModel can be used to build your own metabolic model or modify an existing one. One of the main use cases for StandardModel is that it can be used to merge multiple models or parts of multiple models together. Since the internals are uniform inside each StandardModel, attributes of other model types are squashed into the required format (using the generic accessors). This ensures that the internals of all StandardModels are the same - allowing easy systematic evaluation.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"warning: Warning: Combining models with different namespaces is tricky\nCombining models that use different namespaces requires care.   For example, in some models the water exchange reaction is called   EX_h2o_e, while in others it is called R_EX_h2o_s. This needs to   manually addressed (for now) to prevent duplicate, e.g. reactions,   from being added.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-annotation_index","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: annotation_index","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Often when models are automatically reconstructed duplicate genes, reactions or metabolites end up in a model. COBREXA exports annotation_index to check for cases where the id of a struct may be different, but the annotations the same (possibly suggesting a duplication). annotation_index builds a dictionary mapping annotation features to the ids of whatever struct you are inspecting. This makes it easy to find structs that share certain annotation features.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations = annotation_index(model.reactions)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_annotations[\"ec-code\"]","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"The annotation_index function can also be used on Reactions and Genes in the same way.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-check_duplicate_reaction","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: check_duplicate_reaction","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Another useful function is check_duplicate_reaction, which checks for reactions that have duplicate (or similar) reaction equations.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"pgm_duplicate = Reaction()\npgm_duplicate.id = \"pgm2\" # Phosphoglycerate mutase\npgm_duplicate.metabolites = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1)\npgm_duplicate","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"check_duplicate_reaction(pgm_duplicate, model.reactions; only_metabolites = false) # can also just check if only the metabolites are the same but different stoichiometry is used","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/#Checking-the-internals-of-StandardModels:-reaction_mass_balanced","page":"Basic usage of StandardModel","title":"Checking the internals of StandardModels: reaction_mass_balanced","text":"","category":"section"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Finally, reaction_mass_balanced can be used to check if a reaction is mass balanced based on the formulas of the reaction equation.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"rxn_dict = Dict{String,Float64}(\"3pg_c\" => 1, \"2pg_c\" => -1, \"h2o_c\" => 1)\nreaction_mass_balanced(model, rxn_dict)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Now to determine which atoms are unbalanced, you can use reaction_atom_balance","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"reaction_atom_balance(model, rxn_dict)","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"Note, since pgm_duplicate is not in the model, we cannot use the other variants of this function because they find the reaction equation stored inside the model.","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"","category":"page"},{"location":"notebooks/3_basic_stdmodel_usage/","page":"Basic usage of StandardModel","title":"Basic usage of StandardModel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/base/#Base-functions","page":"Base functions","title":"Base functions","text":"","category":"section"},{"location":"functions/base/","page":"Base functions","title":"Base functions","text":"Modules = [COBREXA]\nPages = map(file -> joinpath(\"base\", file), readdir(\"../src/base\"))","category":"page"},{"location":"functions/base/#COBREXA._constants","page":"Base functions","title":"COBREXA._constants","text":"A named tuple that contains the magic values that are used globally for whatever purposes.\n\n\n\n\n\n","category":"constant"},{"location":"functions/base/#COBREXA.flux_dict-Tuple{MetabolicModel, Any}","page":"Base functions","title":"COBREXA.flux_dict","text":"flux_dict(model::MetabolicModel, opt_model)::Maybe{Dict{String, Float64}, Nothing}\n\nReturns the fluxes of the model as a reaction-keyed dictionary, if solved.\n\nExample\n\nflux_dict(model, flux_balance_analysis(model, ...))\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.flux_dict-Tuple{MetabolicModel}","page":"Base functions","title":"COBREXA.flux_dict","text":"flux_dict(model::MetabolicModel)\n\nA pipeable variant of flux_dict.\n\nExample\n\nflux_balance_analysis(model, ...) |> flux_dict(model)\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.flux_vector-Tuple{MetabolicModel, Any}","page":"Base functions","title":"COBREXA.flux_vector","text":"flux_vector(opt_model)::Maybe{Vector{Float64}}\n\nReturns a vector of fluxes of the model, if solved.\n\nExample\n\nflux_vector(flux_balance_analysis(model, ...))\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.get_optmodel_bounds-Tuple{Any}","page":"Base functions","title":"COBREXA.get_optmodel_bounds","text":"get_optmodel_bounds(opt_model)\n\nReturns vectors of the lower and upper bounds of opt_model constraints, where opt_model is a JuMP model constructed by e.g. make_optimization_model or flux_balance_analysis.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.is_solved-Tuple{Any}","page":"Base functions","title":"COBREXA.is_solved","text":"is_solved(opt_model)\n\nReturn true if opt_model solved successfully (solution is optimal or locally optimal).  Return false if any other termination status is reached. Termination status is defined in the documentation of JuMP.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.make_optimization_model-Tuple{MetabolicModel, Any}","page":"Base functions","title":"COBREXA.make_optimization_model","text":"make_optimization_model(\n    model::MetabolicModel,\n    optimizer;\n    sense = MAX_SENSE,\n)\n\nConvert MetabolicModels to a JuMP model, place objectives and the equality constraint.\n\nHere coupling means inequality constraints coupling multiple variables together.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.optimize_objective-Tuple{Any}","page":"Base functions","title":"COBREXA.optimize_objective","text":"optimize_objective(opt_model)::Maybe{Float64}\n\nShortcut for running JuMP optimize! on a model and returning the objective value, if solved.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.set_optmodel_bound!-Tuple{Any, Any}","page":"Base functions","title":"COBREXA.set_optmodel_bound!","text":"set_optmodel_bound!(vidx, opt_model;\n    ub::Maybe{Real} = nothing,\n    lb::Maybe{Real} = nothing,\n)\n\nHelper function to set the bounds of a variable in the model. Internally calls set_normalized_rhs from JuMP. If the bounds are set to nothing, they will not be changed.\n\n\n\n\n\n","category":"method"},{"location":"functions/base/#COBREXA.solved_objective_value-Tuple{Any}","page":"Base functions","title":"COBREXA.solved_objective_value","text":"solved_objective_value(opt_model)::Maybe{Float64}\n\nReturns the current objective value of a model, if solved.\n\nExample\n\nsolved_objective_value(flux_balance_analysis(model, ...))\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"<br>\n<div align=\"center\">\n    <img class=\"docs-light-only\" src=\"assets/header.svg?maxAge=0\" width=\"80%\">\n    <img class=\"docs-dark-only\" src=\"assets/header-dark.svg?maxAge=0\" width=\"80%\">\n</div>\n<br>","category":"page"},{"location":"#Constraint-Based-Reconstruction-and-EXascale-Analysis","page":"Home","title":"Constraint-Based Reconstruction and EXascale Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository Tests Coverage How to contribute?\n(Image: GitHub) (Image: CI) (Image: codecov) (Image: contrib)","category":"page"},{"location":"","page":"Home","title":"Home","text":"COBREXA is a toolkit for working with large constraint-based metabolic models, and running very large numbers of analysis tasks on these models in parallel. Its main purpose is to make the methods of Constraint-based Reconstruction and Analysis (COBRA) scale to problem sizes that require the use of huge computer clusters and HPC environments, which allows them to be realistically applied to pre-exascale-sized models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package, you will find the usual COBRA-like functions that interface to underlying linear programming solvers. We use JuMP.jl as the unified interface for many solvers; you can plug in whichever compatible solver you want, including the popular Tulip.jl, GLPK.jl, OSQP.jl, and Gurobi.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n<img style=\"width:300px;margin:10px;border-offset:15px;border: 1px solid #eee;border-radius: 50%;padding: 10px;-webkit-border-radius: 50%;-moz-border-radius: 50%;\" src=\"https://gitlab.lcsb.uni.lu/lcsb-biocore/COBREXA.jl/-/jobs/artifacts/master/raw/output.gif?job=gource\" alt=\"history\"><br>\nDevelopment history of COBREXA.jl.\n</div>","category":"page"},{"location":"#Quick-start-guide","page":"Home","title":"Quick start guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install COBREXA from Julia repositories. Start julia, press ] to switch to the Packaging environment, and type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add COBREXA","category":"page"},{"location":"","page":"Home","title":"Home","text":"You also need to install your favorite solver supported by JuMP.jl, typing e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add Tulip","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you may use prebuilt Docker and Apptainer images.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the packages are installed, switch back to the \"normal\" julia shell by pressing Backspace (the prompt should change color back to green). After that, you can download a SBML model from the internet and perform a flux balance analysis as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using COBREXA   # loads the package\nusing Tulip     # loads the optimization solver\n\n# download the model\ndownload(\"http://bigg.ucsd.edu/static/models/e_coli_core.xml\", \"e_coli_core.xml\")\n\n# open the SBML file and load the contents\nmodel = load_model(\"e_coli_core.xml\")\n\n# run a FBA\nfluxes = flux_balance_analysis_dict(model, Tulip.Optimizer)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The variable fluxes will now contain a dictionary of the computed optimal flux of each reaction in the model:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dict{String,Float64} with 95 entries:\n  \"R_EX_fum_e\"    => 0.0\n  \"R_ACONTb\"      => 6.00725\n  \"R_TPI\"         => 7.47738\n  \"R_SUCOAS\"      => -5.06438\n  \"R_GLNS\"        => 0.223462\n  \"R_EX_pi_e\"     => -3.2149\n  \"R_PPC\"         => 2.50431\n  \"R_O2t\"         => 21.7995\n  \"R_G6PDH2r\"     => 4.95999\n  \"R_TALA\"        => 1.49698\n  ⋮               => ⋮","category":"page"},{"location":"#Model-variant-processing","page":"Home","title":"Model variant processing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main feature of COBREXA.jl is the ability to easily specify and process many analyses in parallel. To demonstrate, let's see how the organism would perform if some reactions were disabled independently:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# convert to a model type that is efficient to modify\nm = convert(StandardModel, model)\n\n# find the model objective value if oxygen or carbon dioxide transports are disabled\nscreen(m, # the base model\n    variants=[ # this specifies how to generate the desired model variants\n        [], # one with no modifications, i.e. the base case\n        [with_changed_bound(\"R_O2t\", lower=0.0, upper=0.0)], # disable oxygen\n        [with_changed_bound(\"R_CO2t\", lower=0.0, upper=0.0)], # disable CO2\n        [with_changed_bound(\"R_O2t\", lower=0.0, upper=0.0),\n\t        with_changed_bound(\"R_CO2t\", lower=0.0, upper=0.0)], # disable both\n    ],\n    # this specifies what to do with the model variants (received as the argument `x`)\n    analysis = x ->\n        flux_balance_analysis_dict(x, Tulip.Optimizer)[\"R_BIOMASS_Ecoli_core_w_GAM\"],\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should receive a result showing that missing oxygen transport makes the biomass production much harder:","category":"page"},{"location":"","page":"Home","title":"Home","text":"4-element Vector{Float64}:\n 0.8739215022674809\n 0.21166294973372796\n 0.46166961413944896\n 0.21114065173865457","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most importantly, such analyses can be easily specified by automatically generating long lists of modifications to be applied to the model, and parallelized.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Knocking out each reaction in the model is efficiently accomplished:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# load the task distribution package, add several worker nodes, and load\n# COBREXA and the solver on the nodes\nusing Distributed\naddprocs(4)\n@everywhere using COBREXA, Tulip\n\n# get a list of the workers\nworker_list = workers()\n\n# run the processing in parallel for many model variants\nres = screen(m,\n    variants=[\n\t# create one variant for each reaction in the model, with that reaction knocked out\n        [with_changed_bound(reaction_id, lower=0.0, upper=0.0)]\n\tfor reaction_id in reactions(m)\n    ],\n    analysis = model -> begin\n\t# we need to check if the optimizer even found a feasible solution,\n\t# which may not be the case if we knock out important reactions\n    \tsol = flux_balance_analysis_dict(model, Tulip.Optimizer)\n\tisnothing(sol) ? nothing : sol[\"BIOMASS_Ecoli_core_w_GAM\"]\n    end,\n    # run the screening in parallel on all workers in the list\n    workers = worker_list,\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In result, you should get a long list of the biomass production for each reaction knockout. Let's decorate it with reaction names:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dict(reactions(m) .=> res)","category":"page"},{"location":"","page":"Home","title":"Home","text":"...which should output an easily accessible dictionary with all the objective values named, giving a quick overview of which reactions are critical for the model organism to create biomass:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dict{String, Union{Nothing, Float64}} with 95 entries:\n  \"ACALD\"       => 0.873922\n  \"PTAr\"        => 0.873922\n  \"ALCD2x\"      => 0.873922\n  \"PDH\"         => 0.796696\n  \"PYK\"         => 0.864926\n  \"CO2t\"        => 0.46167\n  \"EX_nh4_e\"    => 1.44677e-15\n  \"MALt2_2\"     => 0.873922\n  \"CS\"          => 2.44779e-14\n  \"PGM\"         => 1.04221e-15\n  \"TKT1\"        => 0.864759\n  ⋮             => ⋮","category":"page"},{"location":"#Basic-and-quick-start-tutorials","page":"Home","title":"Basic and quick-start tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed tutorial content is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"tutorials\", filter(x -> endswith(x, \".md\"), readdir(\"tutorials\")))\nDepth = 1","category":"page"},{"location":"#Advanced-tutorials","page":"Home","title":"Advanced tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed listing of advanced tutorials is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"advanced\", filter(x -> endswith(x, \".md\"), readdir(\"advanced\")))\nDepth = 1","category":"page"},{"location":"#Example-notebooks-and-workflows","page":"Home","title":"Example notebooks and workflows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Detailed notebook content is available here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = joinpath.(\"notebooks\", filter(x -> endswith(x, \".md\"), readdir(\"notebooks\")))\nDepth = 1","category":"page"},{"location":"#Functions-reference","page":"Home","title":"Functions reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"#Contribution-guide","page":"Home","title":"Contribution guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you wish to contribute code, patches or improvements to COBREXA.jl, please read the basic contribution guidelines and hints..","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"COBREXA.jl is developed at the Luxembourg Centre for Systems Biomedicine of the University of Luxembourg (uni.lu/lcsb), cooperating with the Institute for Quantitative and Theoretical Biology at the Heinrich Heine University in Düsseldorf (qtb.hhu.de).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The development was supported by European Union's Horizon 2020 Programme under PerMedCoE project (permedcoe.eu) agreement no. 951773.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/cobrexa.svg\" alt=\"COBREXA logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/unilu.svg\" alt=\"Uni.lu logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/lcsb.svg\" alt=\"LCSB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/hhu.svg\" alt=\"HHU logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/qtb.svg\" alt=\"QTB logo\" height=\"64px\" style=\"height:64px; width:auto\">   <img src=\"https://lcsb-biocore.github.io/COBREXA.jl/stable/assets/permedcoe.svg\" alt=\"PerMedCoE logo\" height=\"64px\" style=\"height:64px; width:auto\">","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"EditURL = \"https://github.com/lcsb-biocore/COBREXA.jl/blob/master/docs/src/notebooks/8_custom_model.jl\"","category":"page"},{"location":"notebooks/8_custom_model/#Using-a-custom-model-data-structure","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"","category":"section"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"(Image: ) (Image: )","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"This notebooks shows how to utilize the generic accessors and modification functions in COBREXA.jl to run the analysis on any custom model type. We will create a simple dictionary-style structure that describes the model, allow COBREXA to run a FVA on it, and create a simple reaction-removing modification.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"First, let's define a very simple stoichiometry-only structure for the model:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"using COBREXA\n\nmutable struct MyReaction\n    max_rate::Float64 # maximum absolute conversion rate\n    stoi::Dict{String,Float64} # stoichimetry of the reaction\n\n    MyReaction() = new(0.0, Dict{String,Float64}())\nend\n\nmutable struct MyModel <: MetabolicModel\n    optimization_target::String # the \"objective\" reaction name\n    reactions::Dict{String,MyReaction} # dictionary of reactions\n\n    MyModel() = new(\"\", Dict{String,MyReaction}())\n    MyModel(o, r) = new(o, r)\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"With this, we can start defining the accessors:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"COBREXA.n_reactions(m::MyModel) = length(m.reactions)\nCOBREXA.reactions(m::MyModel) = sort(collect(keys(m.reactions)))","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Metabolites are defined only very implicitly, so let's just make a function that collects all names. n_metabolites can be left at the default definition that just measures the output of metabolites.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"function COBREXA.metabolites(m::MyModel)\n    mets = Set{String}()\n    for (_, r) in m.reactions\n        for (m, _) in r.stoi\n            push!(mets, m)\n        end\n    end\n    return sort(collect(mets))\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Now, the extraction of the linear model. Remember the order of element in the vectors must match the order in the output of reactions and metabolites.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"using SparseArrays\n\nfunction COBREXA.bounds(m::MyModel)\n    max_rates = [m.reactions[r].max_rate for r in reactions(m)]\n    (sparse(-max_rates), sparse(max_rates))\nend\n\nfunction COBREXA.objective(m::MyModel)\n    if m.optimization_target in keys(m.reactions)\n        c = spzeros(n_reactions(m))\n        c[first(indexin([m.optimization_target], reactions(m)))] = 1.0\n        c\n    else\n        throw(\n            DomainError(\n                m.optimization_target,\n                \"The target reaction for flux optimization not found\",\n            ),\n        )\n    end\nend\n\nfunction COBREXA.stoichiometry(m::MyModel)\n    sparse([\n        get(m.reactions[rxn].stoi, met, 0.0) for met in metabolites(m), rxn in reactions(m)\n    ])\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Now the model is complete! We can generate a random one and see how it performs","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"import Random\nRandom.seed!(123)\n\nrxn_names = [\"Reaction $i\" for i = 'A':'Z'];\nmetabolite_names = [\"Metabolite $i\" for i = 1:20];\n\nm = MyModel();\nfor i in rxn_names\n    m.reactions[i] = MyReaction()\nend\n\nfor i = 1:50\n    rxn = rand(rxn_names)\n    met = rand(metabolite_names)\n    m.reactions[rxn].stoi[met] = rand([-3, -2, -1, 1, 2, 3])\n    m.reactions[rxn].max_rate = rand()\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"Let's see what the model looks like now:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"m","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"We can run most of the standard function on the model data right away:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"using Tulip\nm.optimization_target = \"Reaction A\"\nflux_balance_analysis_dict(m, Tulip.Optimizer)","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"To be able to use the model conveniently in functions such as screen, you usually want to be able to easily specify the modifications. In this example, we enable use of with_removed_reactions by overloading the internal remove_reactions for this specific model type:","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"We need to make an as-shallow-as-possible copy of the model that allows us to remove the reactions without breaking the original model.","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"function COBREXA.remove_reactions(m::MyModel, rxns::AbstractVector{String})\n    m = MyModel(m.optimization_target, copy(m.reactions))\n    delete!.(Ref(m.reactions), rxns)\n    return m\nend","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"The screening is ready now!","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"reactions_to_remove = (\"Reaction $i\" for i = 'B':'Z')\n\nreactions_to_remove .=> screen_variants(\n    m,\n    [[with_removed_reactions([r])] for r in reactions_to_remove],\n    m -> flux_balance_analysis_dict(m, Tulip.Optimizer)[\"Reaction A\"],\n)","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"","category":"page"},{"location":"notebooks/8_custom_model/","page":"Using a custom model data structure","title":"Using a custom model data structure","text":"This page was generated using Literate.jl.","category":"page"}]
}
